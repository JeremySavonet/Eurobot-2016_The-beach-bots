
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
 80001c0:	b672      	cpsid	i
 80001c2:	4825      	ldr	r0, [pc, #148]	; (8000258 <endfiniloop+0x4>)
 80001c4:	f380 8809 	msr	PSP, r0
 80001c8:	2002      	movs	r0, #2
 80001ca:	f380 8814 	msr	CONTROL, r0
 80001ce:	f3bf 8f6f 	isb	sy
 80001d2:	f005 fb45 	bl	8005860 <__core_init>
 80001d6:	f005 fa93 	bl	8005700 <__early_init>
 80001da:	4820      	ldr	r0, [pc, #128]	; (800025c <endfiniloop+0x8>)
 80001dc:	4920      	ldr	r1, [pc, #128]	; (8000260 <endfiniloop+0xc>)
 80001de:	4a21      	ldr	r2, [pc, #132]	; (8000264 <endfiniloop+0x10>)

080001e0 <msloop>:
 80001e0:	4291      	cmp	r1, r2
 80001e2:	bf3c      	itt	cc
 80001e4:	f841 0b04 	strcc.w	r0, [r1], #4
 80001e8:	f7ff bffa 	bcc.w	80001e0 <msloop>
 80001ec:	491e      	ldr	r1, [pc, #120]	; (8000268 <endfiniloop+0x14>)
 80001ee:	4a1a      	ldr	r2, [pc, #104]	; (8000258 <endfiniloop+0x4>)

080001f0 <psloop>:
 80001f0:	4291      	cmp	r1, r2
 80001f2:	bf3c      	itt	cc
 80001f4:	f841 0b04 	strcc.w	r0, [r1], #4
 80001f8:	f7ff bffa 	bcc.w	80001f0 <psloop>
 80001fc:	491b      	ldr	r1, [pc, #108]	; (800026c <endfiniloop+0x18>)
 80001fe:	4a1c      	ldr	r2, [pc, #112]	; (8000270 <endfiniloop+0x1c>)
 8000200:	4b1c      	ldr	r3, [pc, #112]	; (8000274 <endfiniloop+0x20>)

08000202 <dloop>:
 8000202:	429a      	cmp	r2, r3
 8000204:	bf3e      	ittt	cc
 8000206:	f851 0b04 	ldrcc.w	r0, [r1], #4
 800020a:	f842 0b04 	strcc.w	r0, [r2], #4
 800020e:	f7ff bff8 	bcc.w	8000202 <dloop>
 8000212:	2000      	movs	r0, #0
 8000214:	4918      	ldr	r1, [pc, #96]	; (8000278 <endfiniloop+0x24>)
 8000216:	4a19      	ldr	r2, [pc, #100]	; (800027c <endfiniloop+0x28>)

08000218 <bloop>:
 8000218:	4291      	cmp	r1, r2
 800021a:	bf3c      	itt	cc
 800021c:	f841 0b04 	strcc.w	r0, [r1], #4
 8000220:	f7ff bffa 	bcc.w	8000218 <bloop>
 8000224:	f005 fb14 	bl	8005850 <__late_init>
 8000228:	4c15      	ldr	r4, [pc, #84]	; (8000280 <endfiniloop+0x2c>)
 800022a:	4d16      	ldr	r5, [pc, #88]	; (8000284 <endfiniloop+0x30>)

0800022c <initloop>:
 800022c:	42ac      	cmp	r4, r5
 800022e:	f280 8005 	bge.w	800023c <endinitloop>
 8000232:	f854 1b04 	ldr.w	r1, [r4], #4
 8000236:	4788      	blx	r1
 8000238:	f7ff bff8 	b.w	800022c <initloop>

0800023c <endinitloop>:
 800023c:	f005 fb18 	bl	8005870 <main>
 8000240:	4c11      	ldr	r4, [pc, #68]	; (8000288 <endfiniloop+0x34>)
 8000242:	4d12      	ldr	r5, [pc, #72]	; (800028c <endfiniloop+0x38>)

08000244 <finiloop>:
 8000244:	42ac      	cmp	r4, r5
 8000246:	f280 8005 	bge.w	8000254 <endfiniloop>
 800024a:	f854 1b04 	ldr.w	r1, [r4], #4
 800024e:	4788      	blx	r1
 8000250:	f7ff bff8 	b.w	8000244 <finiloop>

08000254 <endfiniloop>:
 8000254:	f005 baf4 	b.w	8005840 <__default_exit>
 8000258:	20000800 	.word	0x20000800
 800025c:	55555555 	.word	0x55555555
 8000260:	20000000 	.word	0x20000000
 8000264:	20000400 	.word	0x20000400
 8000268:	20000400 	.word	0x20000400
 800026c:	08007498 	.word	0x08007498
 8000270:	20000800 	.word	0x20000800
 8000274:	200008b8 	.word	0x200008b8
 8000278:	200008b8 	.word	0x200008b8
 800027c:	2000154c 	.word	0x2000154c
 8000280:	080001c0 	.word	0x080001c0
 8000284:	080001c0 	.word	0x080001c0
 8000288:	080001c0 	.word	0x080001c0
 800028c:	080001c0 	.word	0x080001c0

08000290 <_port_switch>:
 8000290:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000294:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000298:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 800029c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002a0 <_port_thread_start>:
 80002a0:	2300      	movs	r3, #0
 80002a2:	f383 8811 	msr	BASEPRI, r3
 80002a6:	4628      	mov	r0, r5
 80002a8:	47a0      	blx	r4
 80002aa:	2000      	movs	r0, #0
 80002ac:	f005 fa90 	bl	80057d0 <chThdExit>

080002b0 <_port_switch_from_isr>:
 80002b0:	f005 fabe 	bl	8005830 <chSchDoReschedule>

080002b4 <_port_exit_from_isr>:
 80002b4:	df00      	svc	0
 80002b6:	e7fe      	b.n	80002b6 <_port_exit_from_isr+0x2>
	...

080002c0 <dyn2_setup.10845>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 80002c0:	4b03      	ldr	r3, [pc, #12]	; (80002d0 <dyn2_setup.10845+0x10>)
 80002c2:	2200      	movs	r2, #0
  mp->mp_object_size = size;
 80002c4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80002c8:	6059      	str	r1, [r3, #4]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 80002ca:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
  mp->mp_provider = provider;
 80002cc:	609a      	str	r2, [r3, #8]
 80002ce:	4770      	bx	lr
 80002d0:	200008c8 	.word	0x200008c8
 80002d4:	f3af 8000 	nop.w
 80002d8:	f3af 8000 	nop.w
 80002dc:	f3af 8000 	nop.w

080002e0 <tmo.11376>:
 * A virtual timer is set and immediately reset into a continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}
 80002e0:	4770      	bx	lr
 80002e2:	bf00      	nop
 80002e4:	f3af 8000 	nop.w
 80002e8:	f3af 8000 	nop.w
 80002ec:	f3af 8000 	nop.w

080002f0 <sys2_execute.11164>:

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80002f0:	2320      	movs	r3, #32
 80002f2:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80002f6:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80002f8:	b672      	cpsid	i

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80002fa:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80002fe:	b662      	cpsie	i

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000300:	2300      	movs	r3, #0
 8000302:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000306:	b662      	cpsie	i
 8000308:	4770      	bx	lr
 800030a:	bf00      	nop
 800030c:	f3af 8000 	nop.w

08000310 <notify.11016>:

#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)

#define TEST_QUEUES_SIZE 4

static void notify(io_queue_t *qp) {
 8000310:	4770      	bx	lr
 8000312:	bf00      	nop
 8000314:	f3af 8000 	nop.w
 8000318:	f3af 8000 	nop.w
 800031c:	f3af 8000 	nop.w

08000320 <pools1_setup.10705>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8000320:	4b03      	ldr	r3, [pc, #12]	; (8000330 <pools1_setup.10705+0x10>)
 8000322:	2200      	movs	r2, #0
  mp->mp_object_size = size;
 8000324:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8000328:	6059      	str	r1, [r3, #4]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 800032a:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
  mp->mp_provider = provider;
 800032c:	609a      	str	r2, [r3, #8]
 800032e:	4770      	bx	lr
 8000330:	2000080c 	.word	0x2000080c
 8000334:	f3af 8000 	nop.w
 8000338:	f3af 8000 	nop.w
 800033c:	f3af 8000 	nop.w

08000340 <null_provider.10702>:

static void *null_provider(size_t size) {

  (void)size;
  return NULL;
}
 8000340:	2000      	movs	r0, #0
 8000342:	4770      	bx	lr
 8000344:	f3af 8000 	nop.w
 8000348:	f3af 8000 	nop.w
 800034c:	f3af 8000 	nop.w

08000350 <mtx5_setup.9925>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000350:	4b02      	ldr	r3, [pc, #8]	; (800035c <mtx5_setup.9925+0xc>)
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8000352:	2200      	movs	r2, #0
 8000354:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000356:	605b      	str	r3, [r3, #4]
 8000358:	609a      	str	r2, [r3, #8]
 800035a:	4770      	bx	lr
 800035c:	20000830 	.word	0x20000830

08000360 <thread4.11367>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8000360:	4a07      	ldr	r2, [pc, #28]	; (8000380 <thread4.11367+0x20>)
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

static THD_FUNCTION(thread4, p) {
 8000362:	b510      	push	{r4, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000364:	2320      	movs	r3, #32
 8000366:	6994      	ldr	r4, [r2, #24]
 8000368:	f383 8811 	msr	BASEPRI, r3
  thread_t *self = chThdGetSelfX();

  (void)p;
  chSysLock();
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 800036c:	2003      	movs	r0, #3
 800036e:	f003 fce7 	bl	8003d40 <chSchGoSleepS>
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
 8000372:	6a23      	ldr	r3, [r4, #32]
 8000374:	2b00      	cmp	r3, #0
 8000376:	d0f9      	beq.n	800036c <thread4.11367+0xc>
 8000378:	2300      	movs	r3, #0
 800037a:	f383 8811 	msr	BASEPRI, r3
 800037e:	bd10      	pop	{r4, pc}
 8000380:	20001208 	.word	0x20001208
 8000384:	f3af 8000 	nop.w
 8000388:	f3af 8000 	nop.w
 800038c:	f3af 8000 	nop.w

08000390 <thread3.9659.4226>:
static void sem3_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread3, p) {
 8000390:	b510      	push	{r4, lr}

  (void)p;
  chSemWait(&sem1);
 8000392:	4c04      	ldr	r4, [pc, #16]	; (80003a4 <thread3.9659.4226+0x14>)
 8000394:	4620      	mov	r0, r4
 8000396:	f003 fd0b 	bl	8003db0 <chSemWait>
  chSemSignal(&sem1);
 800039a:	4620      	mov	r0, r4
}
 800039c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

static THD_FUNCTION(thread3, p) {

  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
 80003a0:	f003 bc6e 	b.w	8003c80 <chSemSignal>
 80003a4:	20000800 	.word	0x20000800
 80003a8:	f3af 8000 	nop.w
 80003ac:	f3af 8000 	nop.w

080003b0 <thread3.11370>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread3, p) {
 80003b0:	b510      	push	{r4, lr}
 80003b2:	4c06      	ldr	r4, [pc, #24]	; (80003cc <thread3.11370+0x1c>)
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 80003b4:	69a3      	ldr	r3, [r4, #24]
 80003b6:	7f5b      	ldrb	r3, [r3, #29]

  (void)p;
  while (!chThdShouldTerminateX())
 80003b8:	075a      	lsls	r2, r3, #29
 80003ba:	d406      	bmi.n	80003ca <thread3.11370+0x1a>
    chSemWait(&sem1);
 80003bc:	4804      	ldr	r0, [pc, #16]	; (80003d0 <thread3.11370+0x20>)
 80003be:	f003 fcf7 	bl	8003db0 <chSemWait>
 80003c2:	69a3      	ldr	r3, [r4, #24]
 80003c4:	7f5b      	ldrb	r3, [r3, #29]
 */

static THD_FUNCTION(thread3, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 80003c6:	075b      	lsls	r3, r3, #29
 80003c8:	d5f8      	bpl.n	80003bc <thread3.11370+0xc>
 80003ca:	bd10      	pop	{r4, pc}
 80003cc:	20001208 	.word	0x20001208
 80003d0:	200008b8 	.word	0x200008b8
 80003d4:	f3af 8000 	nop.w
 80003d8:	f3af 8000 	nop.w
 80003dc:	f3af 8000 	nop.w

080003e0 <chSemSignalWait.constprop.48.4236>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 80003e0:	b510      	push	{r4, lr}
 80003e2:	2320      	movs	r3, #32
 80003e4:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(((spw->s_cnt >= (cnt_t)0) && queue_isempty(&spw->s_queue)) ||
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
 80003e8:	4c15      	ldr	r4, [pc, #84]	; (8000440 <chSemSignalWait.constprop.48.4236+0x60>)
 80003ea:	68a3      	ldr	r3, [r4, #8]
 80003ec:	3301      	adds	r3, #1
 80003ee:	2b00      	cmp	r3, #0
 80003f0:	60a3      	str	r3, [r4, #8]
 80003f2:	dd1b      	ble.n	800042c <chSemSignalWait.constprop.48.4236+0x4c>
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
 80003f4:	3b01      	subs	r3, #1
 80003f6:	2b00      	cmp	r3, #0
 80003f8:	60a3      	str	r3, [r4, #8]
 80003fa:	4a11      	ldr	r2, [pc, #68]	; (8000440 <chSemSignalWait.constprop.48.4236+0x60>)
 80003fc:	db06      	blt.n	800040c <chSemSignalWait.constprop.48.4236+0x2c>
    ctp->p_u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->p_u.rdymsg;
  }
  else {
    chSchRescheduleS();
 80003fe:	f003 fbd7 	bl	8003bb0 <chSchRescheduleS>
    msg = MSG_OK;
 8000402:	2000      	movs	r0, #0
 8000404:	2300      	movs	r3, #0
 8000406:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return msg;
}
 800040a:	bd10      	pop	{r4, pc}
  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 800040c:	490d      	ldr	r1, [pc, #52]	; (8000444 <chSemSignalWait.constprop.48.4236+0x64>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 800040e:	6853      	ldr	r3, [r2, #4]
 8000410:	698c      	ldr	r4, [r1, #24]
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
 8000412:	2005      	movs	r0, #5
 8000414:	e884 000c 	stmia.w	r4, {r2, r3}
  tp->p_prev->p_next = tp;
 8000418:	601c      	str	r4, [r3, #0]
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
    thread_t *ctp = currp;
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtsemp = spw;
 800041a:	6222      	str	r2, [r4, #32]
  tqp->p_prev = tp;
 800041c:	6054      	str	r4, [r2, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
 800041e:	f003 fc8f 	bl	8003d40 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
 8000422:	6a20      	ldr	r0, [r4, #32]
 8000424:	2300      	movs	r3, #0
 8000426:	f383 8811 	msr	BASEPRI, r3
    msg = MSG_OK;
  }
  chSysUnlock();

  return msg;
}
 800042a:	bd10      	pop	{r4, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 800042c:	6820      	ldr	r0, [r4, #0]

  tqp->p_next = tp->p_next;
 800042e:	6803      	ldr	r3, [r0, #0]
 8000430:	6023      	str	r3, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000432:	605c      	str	r4, [r3, #4]
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
 8000434:	f003 fce4 	bl	8003e00 <chSchReadyI>
 8000438:	2200      	movs	r2, #0
 800043a:	68a3      	ldr	r3, [r4, #8]
 800043c:	6202      	str	r2, [r0, #32]
 800043e:	e7d9      	b.n	80003f4 <chSemSignalWait.constprop.48.4236+0x14>
 8000440:	20000800 	.word	0x20000800
 8000444:	20001208 	.word	0x20001208
 8000448:	f3af 8000 	nop.w
 800044c:	f3af 8000 	nop.w

08000450 <thread.10834>:
 * one to fail.
 */

static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
 8000450:	7800      	ldrb	r0, [r0, #0]
 8000452:	f003 b97d 	b.w	8003750 <test_emit_token>
 8000456:	bf00      	nop
 8000458:	f3af 8000 	nop.w
 800045c:	f3af 8000 	nop.w

08000460 <h1.10417>:
static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 8000460:	2041      	movs	r0, #65	; 0x41
 8000462:	f003 b975 	b.w	8003750 <test_emit_token>
 8000466:	bf00      	nop
 8000468:	f3af 8000 	nop.w
 800046c:	f3af 8000 	nop.w

08000470 <h2.10414>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 8000470:	2042      	movs	r0, #66	; 0x42
 8000472:	f003 b96d 	b.w	8003750 <test_emit_token>
 8000476:	bf00      	nop
 8000478:	f3af 8000 	nop.w
 800047c:	f3af 8000 	nop.w

08000480 <h3.10411>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8000480:	2043      	movs	r0, #67	; 0x43
 8000482:	f003 b965 	b.w	8003750 <test_emit_token>
 8000486:	bf00      	nop
 8000488:	f3af 8000 	nop.w
 800048c:	f3af 8000 	nop.w

08000490 <thread1.9650>:
static void sem1_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread1, p) {
 8000490:	b510      	push	{r4, lr}
 8000492:	4604      	mov	r4, r0

  chSemWait(&sem1);
 8000494:	4803      	ldr	r0, [pc, #12]	; (80004a4 <thread1.9650+0x14>)
 8000496:	f003 fc8b 	bl	8003db0 <chSemWait>
  test_emit_token(*(char *)p);
 800049a:	7820      	ldrb	r0, [r4, #0]
}
 800049c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

static THD_FUNCTION(thread1, p) {

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
 80004a0:	f003 b956 	b.w	8003750 <test_emit_token>
 80004a4:	20000800 	.word	0x20000800
 80004a8:	f3af 8000 	nop.w
 80004ac:	f3af 8000 	nop.w

080004b0 <thread.9380>:
 * priority order regardless of the initial order.
 */

static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
 80004b0:	7800      	ldrb	r0, [r0, #0]
 80004b2:	f003 b94d 	b.w	8003750 <test_emit_token>
 80004b6:	bf00      	nop
 80004b8:	f3af 8000 	nop.w
 80004bc:	f3af 8000 	nop.w

080004c0 <thread12.9913>:
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread12, p) {
 80004c0:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m2);
 80004c2:	4c06      	ldr	r4, [pc, #24]	; (80004dc <thread12.9913+0x1c>)
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread12, p) {
 80004c4:	4605      	mov	r5, r0

  chMtxLock(&m2);
 80004c6:	4620      	mov	r0, r4
 80004c8:	f003 fdfa 	bl	80040c0 <chMtxLock>
  test_emit_token(*(char *)p);
 80004cc:	7828      	ldrb	r0, [r5, #0]
 80004ce:	f003 f93f 	bl	8003750 <test_emit_token>
  chMtxUnlock(&m2);
 80004d2:	4620      	mov	r0, r4
}
 80004d4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

static THD_FUNCTION(thread12, p) {

  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
 80004d8:	f003 bd52 	b.w	8003f80 <chMtxUnlock>
 80004dc:	20000820 	.word	0x20000820

080004e0 <thread1.9901>:
static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread1, p) {
 80004e0:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m1);
 80004e2:	4c06      	ldr	r4, [pc, #24]	; (80004fc <thread1.9901+0x1c>)
static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread1, p) {
 80004e4:	4605      	mov	r5, r0

  chMtxLock(&m1);
 80004e6:	4620      	mov	r0, r4
 80004e8:	f003 fdea 	bl	80040c0 <chMtxLock>
  test_emit_token(*(char *)p);
 80004ec:	7828      	ldrb	r0, [r5, #0]
 80004ee:	f003 f92f 	bl	8003750 <test_emit_token>
  chMtxUnlock(&m1);
 80004f2:	4620      	mov	r0, r4
}
 80004f4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

static THD_FUNCTION(thread1, p) {

  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
 80004f8:	f003 bd42 	b.w	8003f80 <chMtxUnlock>
 80004fc:	20000830 	.word	0x20000830

08000500 <thread10.9910>:

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread10, p) {
 8000500:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000502:	4607      	mov	r7, r0

  chMtxLock(&m1);
 8000504:	4816      	ldr	r0, [pc, #88]	; (8000560 <thread10.9910+0x60>)
 8000506:	f003 fddb 	bl	80040c0 <chMtxLock>
 800050a:	2320      	movs	r3, #32
 800050c:	f383 8811 	msr	BASEPRI, r3
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  thread_t *ctp = currp;
 8000510:	4b14      	ldr	r3, [pc, #80]	; (8000564 <thread10.9910+0x64>)
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->p_u.wtobjp = cp;
 8000512:	4d15      	ldr	r5, [pc, #84]	; (8000568 <thread10.9910+0x68>)
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  thread_t *ctp = currp;
 8000514:	699c      	ldr	r4, [r3, #24]
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {

  return chThdGetSelfX()->p_mtxlist;
 8000516:	6ba6      	ldr	r6, [r4, #56]	; 0x38
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8000518:	4630      	mov	r0, r6
 800051a:	f003 fd09 	bl	8003f30 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->p_u.wtobjp = cp;
 800051e:	6225      	str	r5, [r4, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000520:	462b      	mov	r3, r5
 8000522:	e003      	b.n	800052c <thread10.9910+0x2c>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000524:	6899      	ldr	r1, [r3, #8]
 8000526:	68a2      	ldr	r2, [r4, #8]
 8000528:	4291      	cmp	r1, r2
 800052a:	d302      	bcc.n	8000532 <thread10.9910+0x32>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 800052c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800052e:	42ab      	cmp	r3, r5
 8000530:	d1f8      	bne.n	8000524 <thread10.9910+0x24>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000532:	685a      	ldr	r2, [r3, #4]
 8000534:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000536:	6023      	str	r3, [r4, #0]
  queue_prio_insert(ctp, &cp->c_queue);
  chSchGoSleepS(CH_STATE_WTCOND);
 8000538:	2007      	movs	r0, #7
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800053a:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800053c:	605c      	str	r4, [r3, #4]
 800053e:	f003 fbff 	bl	8003d40 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
  chMtxLockS(mp);
 8000542:	4630      	mov	r0, r6
 8000544:	f003 fd54 	bl	8003ff0 <chMtxLockS>
 8000548:	2300      	movs	r3, #0
 800054a:	f383 8811 	msr	BASEPRI, r3
  chCondWait(&c1);
  test_emit_token(*(char *)p);
 800054e:	7838      	ldrb	r0, [r7, #0]
 8000550:	f003 f8fe 	bl	8003750 <test_emit_token>
  chMtxUnlock(&m1);
 8000554:	4802      	ldr	r0, [pc, #8]	; (8000560 <thread10.9910+0x60>)
}
 8000556:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
static THD_FUNCTION(thread10, p) {

  chMtxLock(&m1);
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
 800055a:	f003 bd11 	b.w	8003f80 <chMtxUnlock>
 800055e:	bf00      	nop
 8000560:	20000830 	.word	0x20000830
 8000564:	20001208 	.word	0x20001208
 8000568:	20000818 	.word	0x20000818
 800056c:	f3af 8000 	nop.w

08000570 <thread8.11373>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread8, p) {
 8000570:	b538      	push	{r3, r4, r5, lr}
 8000572:	4d09      	ldr	r5, [pc, #36]	; (8000598 <thread8.11373+0x28>)
 8000574:	4604      	mov	r4, r0

  do {
    chThdYield();
 8000576:	f003 facb 	bl	8003b10 <chThdYield>
    chThdYield();
 800057a:	f003 fac9 	bl	8003b10 <chThdYield>
    chThdYield();
 800057e:	f003 fac7 	bl	8003b10 <chThdYield>
    chThdYield();
 8000582:	f003 fac5 	bl	8003b10 <chThdYield>
    (*(uint32_t *)p) += 4;
 8000586:	6823      	ldr	r3, [r4, #0]
 8000588:	69aa      	ldr	r2, [r5, #24]
 800058a:	3304      	adds	r3, #4
 800058c:	6023      	str	r3, [r4, #0]
 800058e:	7f53      	ldrb	r3, [r2, #29]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 8000590:	075b      	lsls	r3, r3, #29
 8000592:	d5f0      	bpl.n	8000576 <thread8.11373+0x6>
}
 8000594:	bd38      	pop	{r3, r4, r5, pc}
 8000596:	bf00      	nop
 8000598:	20001208 	.word	0x20001208
 800059c:	f3af 8000 	nop.w

080005a0 <bmk13_execute.11379>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
 80005a0:	b510      	push	{r4, lr}

  test_print("--- System: ");
 80005a2:	482f      	ldr	r0, [pc, #188]	; (8000660 <bmk13_execute.11379+0xc0>)
  test_printn(sizeof(ch_system_t));
  test_println(" bytes");
 80005a4:	4c2f      	ldr	r4, [pc, #188]	; (8000664 <bmk13_execute.11379+0xc4>)
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {

  test_print("--- System: ");
 80005a6:	f003 f8fb 	bl	80037a0 <test_print>
  test_printn(sizeof(ch_system_t));
 80005aa:	f44f 70a8 	mov.w	r0, #336	; 0x150
 80005ae:	f003 f907 	bl	80037c0 <test_printn>
  test_println(" bytes");
 80005b2:	4620      	mov	r0, r4
 80005b4:	f003 f8dc 	bl	8003770 <test_println>
  test_print("--- Thread: ");
 80005b8:	482b      	ldr	r0, [pc, #172]	; (8000668 <bmk13_execute.11379+0xc8>)
 80005ba:	f003 f8f1 	bl	80037a0 <test_print>
  test_printn(sizeof(thread_t));
 80005be:	2044      	movs	r0, #68	; 0x44
 80005c0:	f003 f8fe 	bl	80037c0 <test_printn>
  test_println(" bytes");
 80005c4:	4620      	mov	r0, r4
 80005c6:	f003 f8d3 	bl	8003770 <test_println>
  test_print("--- Timer : ");
 80005ca:	4828      	ldr	r0, [pc, #160]	; (800066c <bmk13_execute.11379+0xcc>)
 80005cc:	f003 f8e8 	bl	80037a0 <test_print>
  test_printn(sizeof(virtual_timer_t));
 80005d0:	2014      	movs	r0, #20
 80005d2:	f003 f8f5 	bl	80037c0 <test_printn>
  test_println(" bytes");
 80005d6:	4620      	mov	r0, r4
 80005d8:	f003 f8ca 	bl	8003770 <test_println>
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
  test_print("--- Semaph: ");
 80005dc:	4824      	ldr	r0, [pc, #144]	; (8000670 <bmk13_execute.11379+0xd0>)
 80005de:	f003 f8df 	bl	80037a0 <test_print>
  test_printn(sizeof(semaphore_t));
 80005e2:	200c      	movs	r0, #12
 80005e4:	f003 f8ec 	bl	80037c0 <test_printn>
  test_println(" bytes");
 80005e8:	4620      	mov	r0, r4
 80005ea:	f003 f8c1 	bl	8003770 <test_println>
#endif
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
 80005ee:	4821      	ldr	r0, [pc, #132]	; (8000674 <bmk13_execute.11379+0xd4>)
 80005f0:	f003 f8d6 	bl	80037a0 <test_print>
  test_printn(sizeof(event_source_t));
 80005f4:	2004      	movs	r0, #4
 80005f6:	f003 f8e3 	bl	80037c0 <test_printn>
  test_println(" bytes");
 80005fa:	4620      	mov	r0, r4
 80005fc:	f003 f8b8 	bl	8003770 <test_println>
  test_print("--- EventL: ");
 8000600:	481d      	ldr	r0, [pc, #116]	; (8000678 <bmk13_execute.11379+0xd8>)
 8000602:	f003 f8cd 	bl	80037a0 <test_print>
  test_printn(sizeof(event_listener_t));
 8000606:	2014      	movs	r0, #20
 8000608:	f003 f8da 	bl	80037c0 <test_printn>
  test_println(" bytes");
 800060c:	4620      	mov	r0, r4
 800060e:	f003 f8af 	bl	8003770 <test_println>
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
 8000612:	481a      	ldr	r0, [pc, #104]	; (800067c <bmk13_execute.11379+0xdc>)
 8000614:	f003 f8c4 	bl	80037a0 <test_print>
  test_printn(sizeof(mutex_t));
 8000618:	2010      	movs	r0, #16
 800061a:	f003 f8d1 	bl	80037c0 <test_printn>
  test_println(" bytes");
 800061e:	4620      	mov	r0, r4
 8000620:	f003 f8a6 	bl	8003770 <test_println>
#endif
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
 8000624:	4816      	ldr	r0, [pc, #88]	; (8000680 <bmk13_execute.11379+0xe0>)
 8000626:	f003 f8bb 	bl	80037a0 <test_print>
  test_printn(sizeof(condition_variable_t));
 800062a:	2008      	movs	r0, #8
 800062c:	f003 f8c8 	bl	80037c0 <test_printn>
  test_println(" bytes");
 8000630:	4620      	mov	r0, r4
 8000632:	f003 f89d 	bl	8003770 <test_println>
#endif
#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
 8000636:	4813      	ldr	r0, [pc, #76]	; (8000684 <bmk13_execute.11379+0xe4>)
 8000638:	f003 f8b2 	bl	80037a0 <test_print>
  test_printn(sizeof(io_queue_t));
 800063c:	2024      	movs	r0, #36	; 0x24
 800063e:	f003 f8bf 	bl	80037c0 <test_printn>
  test_println(" bytes");
 8000642:	4620      	mov	r0, r4
 8000644:	f003 f894 	bl	8003770 <test_println>
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
 8000648:	480f      	ldr	r0, [pc, #60]	; (8000688 <bmk13_execute.11379+0xe8>)
 800064a:	f003 f8a9 	bl	80037a0 <test_print>
  test_printn(sizeof(mailbox_t));
 800064e:	2028      	movs	r0, #40	; 0x28
 8000650:	f003 f8b6 	bl	80037c0 <test_printn>
  test_println(" bytes");
 8000654:	4620      	mov	r0, r4
#endif
}
 8000656:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_println(" bytes");
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
  test_printn(sizeof(mailbox_t));
  test_println(" bytes");
 800065a:	f003 b889 	b.w	8003770 <test_println>
 800065e:	bf00      	nop
 8000660:	08006730 	.word	0x08006730
 8000664:	08006740 	.word	0x08006740
 8000668:	08006748 	.word	0x08006748
 800066c:	08006758 	.word	0x08006758
 8000670:	08006768 	.word	0x08006768
 8000674:	08006778 	.word	0x08006778
 8000678:	08006788 	.word	0x08006788
 800067c:	08006798 	.word	0x08006798
 8000680:	080067a8 	.word	0x080067a8
 8000684:	080067b8 	.word	0x080067b8
 8000688:	080067c8 	.word	0x080067c8
 800068c:	f3af 8000 	nop.w

08000690 <thread.10047>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 8000690:	b510      	push	{r4, lr}

  chMsgSend(p, 'A');
 8000692:	2141      	movs	r1, #65	; 0x41
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 8000694:	4604      	mov	r4, r0

  chMsgSend(p, 'A');
 8000696:	f003 fbcb 	bl	8003e30 <chMsgSend>
  chMsgSend(p, 'B');
 800069a:	4620      	mov	r0, r4
 800069c:	2142      	movs	r1, #66	; 0x42
 800069e:	f003 fbc7 	bl	8003e30 <chMsgSend>
  chMsgSend(p, 'C');
 80006a2:	4620      	mov	r0, r4
 80006a4:	2143      	movs	r1, #67	; 0x43
}
 80006a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

static THD_FUNCTION(thread, p) {

  chMsgSend(p, 'A');
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
 80006aa:	f003 bbc1 	b.w	8003e30 <chMsgSend>
 80006ae:	bf00      	nop

080006b0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 80006b0:	b4f0      	push	{r4, r5, r6, r7}
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80006b2:	4d1c      	ldr	r5, [pc, #112]	; (8000724 <chVTDoSetI+0x74>)
 80006b4:	462e      	mov	r6, r5
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80006b6:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 80006ba:	f856 4f1c 	ldr.w	r4, [r6, #28]!
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 80006be:	6103      	str	r3, [r0, #16]
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 80006c0:	2901      	cmp	r1, #1
 80006c2:	bf98      	it	ls
 80006c4:	2102      	movls	r1, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80006c6:	42b4      	cmp	r4, r6

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 80006c8:	60c2      	str	r2, [r0, #12]
 80006ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80006cc:	d01b      	beq.n	8000706 <chVTDoSetI+0x56>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 80006ce:	6aae      	ldr	r6, [r5, #40]	; 0x28
    if (delta < ch.vtlist.vt_next->vt_delta) {
 80006d0:	68a2      	ldr	r2, [r4, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 80006d2:	4419      	add	r1, r3
 80006d4:	1b8b      	subs	r3, r1, r6
    if (delta < ch.vtlist.vt_next->vt_delta) {
 80006d6:	4293      	cmp	r3, r2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80006d8:	bf38      	it	cc
 80006da:	6379      	strcc	r1, [r7, #52]	; 0x34
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 80006dc:	4293      	cmp	r3, r2
 80006de:	d904      	bls.n	80006ea <chVTDoSetI+0x3a>
    delta -= p->vt_delta;
    p = p->vt_next;
 80006e0:	6824      	ldr	r4, [r4, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 80006e2:	1a9b      	subs	r3, r3, r2
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 80006e4:	68a2      	ldr	r2, [r4, #8]
 80006e6:	429a      	cmp	r2, r3
 80006e8:	d3fa      	bcc.n	80006e0 <chVTDoSetI+0x30>
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 80006ea:	6862      	ldr	r2, [r4, #4]
 80006ec:	6042      	str	r2, [r0, #4]
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 80006ee:	6004      	str	r4, [r0, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
 80006f0:	6010      	str	r0, [r2, #0]
  p->vt_prev = vtp;
 80006f2:	6060      	str	r0, [r4, #4]
  vtp->vt_delta = delta
 80006f4:	6083      	str	r3, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 80006f6:	68a2      	ldr	r2, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80006f8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 80006fc:	1ad3      	subs	r3, r2, r3
 80006fe:	60a3      	str	r3, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8000700:	6269      	str	r1, [r5, #36]	; 0x24
}
 8000702:	bcf0      	pop	{r4, r5, r6, r7}
 8000704:	4770      	bx	lr
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 8000706:	eb01 0c03 	add.w	ip, r1, r3
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  STM32_ST_TIM->SR     = 0;
 800070a:	2600      	movs	r6, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800070c:	2202      	movs	r2, #2
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 800070e:	62ab      	str	r3, [r5, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
 8000710:	61e8      	str	r0, [r5, #28]
      ch.vtlist.vt_prev = vtp;
 8000712:	6228      	str	r0, [r5, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8000714:	6004      	str	r4, [r0, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000716:	6044      	str	r4, [r0, #4]
      vtp->vt_delta = delay;
 8000718:	6081      	str	r1, [r0, #8]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800071a:	f8c7 c034 	str.w	ip, [r7, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800071e:	613e      	str	r6, [r7, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000720:	60fa      	str	r2, [r7, #12]
 8000722:	e7ee      	b.n	8000702 <chVTDoSetI+0x52>
 8000724:	20001208 	.word	0x20001208
 8000728:	f3af 8000 	nop.w
 800072c:	f3af 8000 	nop.w

08000730 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000730:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000732:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000734:	b087      	sub	sp, #28
 8000736:	4605      	mov	r5, r0

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000738:	d011      	beq.n	800075e <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800073a:	4c0c      	ldr	r4, [pc, #48]	; (800076c <chSchGoSleepTimeoutS+0x3c>)
 800073c:	4a0c      	ldr	r2, [pc, #48]	; (8000770 <chSchGoSleepTimeoutS+0x40>)
 800073e:	69a3      	ldr	r3, [r4, #24]
 8000740:	a801      	add	r0, sp, #4
 8000742:	f7ff ffb5 	bl	80006b0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000746:	4628      	mov	r0, r5
 8000748:	f003 fafa 	bl	8003d40 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800074c:	9b04      	ldr	r3, [sp, #16]
 800074e:	b113      	cbz	r3, 8000756 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 8000750:	a801      	add	r0, sp, #4
 8000752:	f003 f91d 	bl	8003990 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8000756:	69a3      	ldr	r3, [r4, #24]
}
 8000758:	6a18      	ldr	r0, [r3, #32]
 800075a:	b007      	add	sp, #28
 800075c:	bd30      	pop	{r4, r5, pc}
 800075e:	4c03      	ldr	r4, [pc, #12]	; (800076c <chSchGoSleepTimeoutS+0x3c>)
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8000760:	f003 faee 	bl	8003d40 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8000764:	69a3      	ldr	r3, [r4, #24]
}
 8000766:	6a18      	ldr	r0, [r3, #32]
 8000768:	b007      	add	sp, #28
 800076a:	bd30      	pop	{r4, r5, pc}
 800076c:	20001208 	.word	0x20001208
 8000770:	080036d1 	.word	0x080036d1
 8000774:	f3af 8000 	nop.w
 8000778:	f3af 8000 	nop.w
 800077c:	f3af 8000 	nop.w

08000780 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8000780:	b410      	push	{r4}
 8000782:	4602      	mov	r2, r0

  if (TIME_IMMEDIATE == timeout) {
 8000784:	b159      	cbz	r1, 800079e <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000786:	4b08      	ldr	r3, [pc, #32]	; (80007a8 <chThdEnqueueTimeoutS+0x28>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8000788:	6844      	ldr	r4, [r0, #4]
 800078a:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800078c:	2004      	movs	r0, #4
 800078e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tp;
 8000792:	6023      	str	r3, [r4, #0]
  tqp->p_prev = tp;
 8000794:	6053      	str	r3, [r2, #4]
}
 8000796:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800079a:	f7ff bfc9 	b.w	8000730 <chSchGoSleepTimeoutS>
}
 800079e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80007a2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80007a6:	4770      	bx	lr
 80007a8:	20001208 	.word	0x20001208
 80007ac:	f3af 8000 	nop.w

080007b0 <chTMStartMeasurementX.constprop.58>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80007b0:	4b01      	ldr	r3, [pc, #4]	; (80007b8 <chTMStartMeasurementX.constprop.58+0x8>)
 80007b2:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 80007b4:	6083      	str	r3, [r0, #8]
 80007b6:	4770      	bx	lr
 80007b8:	e0001000 	.word	0xe0001000
 80007bc:	f3af 8000 	nop.w

080007c0 <chIQPutI>:
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 80007c0:	6943      	ldr	r3, [r0, #20]
 80007c2:	6982      	ldr	r2, [r0, #24]
 80007c4:	4293      	cmp	r3, r2
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 80007c6:	b510      	push	{r4, lr}
 80007c8:	d01d      	beq.n	8000806 <chIQPutI+0x46>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 80007ca:	6884      	ldr	r4, [r0, #8]
  *iqp->q_wrptr++ = b;
 80007cc:	1c5a      	adds	r2, r3, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 80007ce:	3401      	adds	r4, #1
  *iqp->q_wrptr++ = b;
 80007d0:	6142      	str	r2, [r0, #20]

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 80007d2:	6084      	str	r4, [r0, #8]
  *iqp->q_wrptr++ = b;
 80007d4:	7019      	strb	r1, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 80007d6:	6942      	ldr	r2, [r0, #20]
 80007d8:	6903      	ldr	r3, [r0, #16]
 80007da:	429a      	cmp	r2, r3
 80007dc:	d20c      	bcs.n	80007f8 <chIQPutI+0x38>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80007de:	6803      	ldr	r3, [r0, #0]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 80007e0:	4298      	cmp	r0, r3
 80007e2:	d00e      	beq.n	8000802 <chIQPutI+0x42>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80007e4:	681a      	ldr	r2, [r3, #0]
 80007e6:	6002      	str	r2, [r0, #0]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80007e8:	2400      	movs	r4, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 80007ea:	6050      	str	r0, [r2, #4]
  (void) chSchReadyI(tp);
 80007ec:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80007ee:	621c      	str	r4, [r3, #32]
  (void) chSchReadyI(tp);
 80007f0:	f003 fb06 	bl	8003e00 <chSchReadyI>
    iqp->q_wrptr = iqp->q_buffer;
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);

  return Q_OK;
 80007f4:	4620      	mov	r0, r4
 80007f6:	bd10      	pop	{r4, pc}
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top) {
    iqp->q_wrptr = iqp->q_buffer;
 80007f8:	68c3      	ldr	r3, [r0, #12]
 80007fa:	6143      	str	r3, [r0, #20]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80007fc:	6803      	ldr	r3, [r0, #0]
 80007fe:	4298      	cmp	r0, r3
 8000800:	d1f0      	bne.n	80007e4 <chIQPutI+0x24>
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);

  return Q_OK;
 8000802:	2000      	movs	r0, #0
 8000804:	bd10      	pop	{r4, pc}
 8000806:	6882      	ldr	r2, [r0, #8]
 8000808:	2a00      	cmp	r2, #0
 800080a:	d0de      	beq.n	80007ca <chIQPutI+0xa>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
 800080c:	f06f 0003 	mvn.w	r0, #3
 8000810:	bd10      	pop	{r4, pc}
 8000812:	bf00      	nop
 8000814:	f3af 8000 	nop.w
 8000818:	f3af 8000 	nop.w
 800081c:	f3af 8000 	nop.w

08000820 <chCondSignal.constprop.45>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8000820:	b508      	push	{r3, lr}
 8000822:	2320      	movs	r3, #32
 8000824:	f383 8811 	msr	BASEPRI, r3
 8000828:	4b06      	ldr	r3, [pc, #24]	; (8000844 <chCondSignal.constprop.45+0x24>)
 800082a:	6818      	ldr	r0, [r3, #0]

  chDbgCheck(cp != NULL);

  chSysLock();
  if (queue_notempty(&cp->c_queue)) {
 800082c:	4298      	cmp	r0, r3
 800082e:	d005      	beq.n	800083c <chCondSignal.constprop.45+0x1c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000830:	6802      	ldr	r2, [r0, #0]
 8000832:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000834:	6053      	str	r3, [r2, #4]
    chSchWakeupS(queue_fifo_remove(&cp->c_queue), MSG_OK);
 8000836:	2100      	movs	r1, #0
 8000838:	f003 f9f2 	bl	8003c20 <chSchWakeupS>
 800083c:	2300      	movs	r3, #0
 800083e:	f383 8811 	msr	BASEPRI, r3
 8000842:	bd08      	pop	{r3, pc}
 8000844:	20000818 	.word	0x20000818
 8000848:	f3af 8000 	nop.w
 800084c:	f3af 8000 	nop.w

08000850 <chCondSignalI.constprop.44>:
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000850:	4b08      	ldr	r3, [pc, #32]	; (8000874 <chCondSignalI.constprop.44+0x24>)
 8000852:	681a      	ldr	r2, [r3, #0]
void chCondSignalI(condition_variable_t *cp) {

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
 8000854:	429a      	cmp	r2, r3
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 8000856:	b410      	push	{r4}

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
 8000858:	d009      	beq.n	800086e <chCondSignalI.constprop.44+0x1e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800085a:	6811      	ldr	r1, [r2, #0]
 800085c:	6019      	str	r1, [r3, #0]
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
    tp->p_u.rdymsg = MSG_OK;
 800085e:	2400      	movs	r4, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000860:	604b      	str	r3, [r1, #4]
 8000862:	6214      	str	r4, [r2, #32]
    (void) chSchReadyI(tp);
 8000864:	4610      	mov	r0, r2
  }
}
 8000866:	f85d 4b04 	ldr.w	r4, [sp], #4
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
    tp->p_u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
 800086a:	f003 bac9 	b.w	8003e00 <chSchReadyI>
  }
}
 800086e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000872:	4770      	bx	lr
 8000874:	20000818 	.word	0x20000818
 8000878:	f3af 8000 	nop.w
 800087c:	f3af 8000 	nop.w

08000880 <chEvtGetAndClearEvents.constprop.38>:
 8000880:	2320      	movs	r3, #32
 8000882:	f383 8811 	msr	BASEPRI, r3
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->p_epending & events;
 8000886:	4b04      	ldr	r3, [pc, #16]	; (8000898 <chEvtGetAndClearEvents.constprop.38+0x18>)
 8000888:	699a      	ldr	r2, [r3, #24]
  currp->p_epending &= ~events;
 800088a:	2300      	movs	r3, #0
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->p_epending & events;
 800088c:	6b50      	ldr	r0, [r2, #52]	; 0x34
  currp->p_epending &= ~events;
 800088e:	6353      	str	r3, [r2, #52]	; 0x34
 8000890:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8000894:	4770      	bx	lr
 8000896:	bf00      	nop
 8000898:	20001208 	.word	0x20001208
 800089c:	f3af 8000 	nop.w

080008a0 <evt3_setup.10426>:
 * After each test phase the test verifies that there are no stuck event flags.
 */

static void evt3_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
 80008a0:	f7ff bfee 	b.w	8000880 <chEvtGetAndClearEvents.constprop.38>
 80008a4:	f3af 8000 	nop.w
 80008a8:	f3af 8000 	nop.w
 80008ac:	f3af 8000 	nop.w

080008b0 <evt2_setup.10424>:
 * the expected time and that there are no stuck event flags.
 */

static void evt2_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
 80008b0:	f7ff bfe6 	b.w	8000880 <chEvtGetAndClearEvents.constprop.38>
 80008b4:	f3af 8000 	nop.w
 80008b8:	f3af 8000 	nop.w
 80008bc:	f3af 8000 	nop.w

080008c0 <evt1_setup.10422>:
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
 80008c0:	f7ff bfde 	b.w	8000880 <chEvtGetAndClearEvents.constprop.38>
 80008c4:	f3af 8000 	nop.w
 80008c8:	f3af 8000 	nop.w
 80008cc:	f3af 8000 	nop.w

080008d0 <chEvtWaitOne.constprop.34>:
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
  thread_t *ctp = currp;
 80008d0:	4a0b      	ldr	r2, [pc, #44]	; (8000900 <chEvtWaitOne.constprop.34+0x30>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 80008d2:	b510      	push	{r4, lr}
 80008d4:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 80008d6:	6994      	ldr	r4, [r2, #24]
 80008d8:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 80008dc:	6b63      	ldr	r3, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80008de:	b933      	cbnz	r3, 80008ee <chEvtWaitOne.constprop.34+0x1e>
    ctp->p_u.ewmask = events;
 80008e0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80008e4:	6223      	str	r3, [r4, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 80008e6:	200a      	movs	r0, #10
 80008e8:	f003 fa2a 	bl	8003d40 <chSchGoSleepS>
    m = ctp->p_epending & events;
 80008ec:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 80008ee:	4258      	negs	r0, r3
 80008f0:	4018      	ands	r0, r3
  ctp->p_epending &= ~m;
 80008f2:	ea23 0300 	bic.w	r3, r3, r0
 80008f6:	6363      	str	r3, [r4, #52]	; 0x34
 80008f8:	2300      	movs	r3, #0
 80008fa:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 80008fe:	bd10      	pop	{r4, pc}
 8000900:	20001208 	.word	0x20001208
 8000904:	f3af 8000 	nop.w
 8000908:	f3af 8000 	nop.w
 800090c:	f3af 8000 	nop.w

08000910 <chEvtWaitAny.constprop.33>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
  thread_t *ctp = currp;
 8000910:	4a0b      	ldr	r2, [pc, #44]	; (8000940 <chEvtWaitAny.constprop.33+0x30>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8000912:	b510      	push	{r4, lr}
 8000914:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 8000916:	6994      	ldr	r4, [r2, #24]
 8000918:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800091c:	6b60      	ldr	r0, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800091e:	b930      	cbnz	r0, 800092e <chEvtWaitAny.constprop.33+0x1e>
    ctp->p_u.ewmask = events;
 8000920:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    chSchGoSleepS(CH_STATE_WTOREVT);
 8000924:	200a      	movs	r0, #10
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
  if (m == (eventmask_t)0) {
    ctp->p_u.ewmask = events;
 8000926:	6223      	str	r3, [r4, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 8000928:	f003 fa0a 	bl	8003d40 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800092c:	6b60      	ldr	r0, [r4, #52]	; 0x34
  }
  ctp->p_epending &= ~m;
 800092e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8000930:	ea23 0300 	bic.w	r3, r3, r0
 8000934:	6363      	str	r3, [r4, #52]	; 0x34
 8000936:	2300      	movs	r3, #0
 8000938:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 800093c:	bd10      	pop	{r4, pc}
 800093e:	bf00      	nop
 8000940:	20001208 	.word	0x20001208
	...

08000950 <chMBPostI.constprop.25>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8000950:	b538      	push	{r3, r4, r5, lr}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8000952:	4b0c      	ldr	r3, [pc, #48]	; (8000984 <chMBPostI.constprop.25+0x34>)
 8000954:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000956:	2a00      	cmp	r2, #0
 8000958:	dd10      	ble.n	800097c <chMBPostI.constprop.25+0x2c>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 800095a:	689c      	ldr	r4, [r3, #8]
  if (mbp->mb_wrptr >= mbp->mb_top) {
 800095c:	685d      	ldr	r5, [r3, #4]
  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 800095e:	1d21      	adds	r1, r4, #4
 */
static inline void chSemFastWaitI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt--;
 8000960:	3a01      	subs	r2, #1
  if (mbp->mb_wrptr >= mbp->mb_top) {
 8000962:	42a9      	cmp	r1, r5
 8000964:	625a      	str	r2, [r3, #36]	; 0x24
  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 8000966:	6099      	str	r1, [r3, #8]
  if (mbp->mb_wrptr >= mbp->mb_top) {
     mbp->mb_wrptr = mbp->mb_buffer;
 8000968:	bf28      	it	cs
 800096a:	681a      	ldrcs	r2, [r3, #0]
  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 800096c:	6020      	str	r0, [r4, #0]
  if (mbp->mb_wrptr >= mbp->mb_top) {
     mbp->mb_wrptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_fullsem);
 800096e:	4806      	ldr	r0, [pc, #24]	; (8000988 <chMBPostI.constprop.25+0x38>)
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
  if (mbp->mb_wrptr >= mbp->mb_top) {
     mbp->mb_wrptr = mbp->mb_buffer;
 8000970:	bf28      	it	cs
 8000972:	609a      	strcs	r2, [r3, #8]
  }
  chSemSignalI(&mbp->mb_fullsem);
 8000974:	f003 fc6c 	bl	8004250 <chSemSignalI>

  return MSG_OK;
 8000978:	2000      	movs	r0, #0
 800097a:	bd38      	pop	{r3, r4, r5, pc}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 800097c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     mbp->mb_wrptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_fullsem);

  return MSG_OK;
}
 8000980:	bd38      	pop	{r3, r4, r5, pc}
 8000982:	bf00      	nop
 8000984:	20000840 	.word	0x20000840
 8000988:	20000850 	.word	0x20000850
 800098c:	f3af 8000 	nop.w

08000990 <chMBPostAheadI.constprop.23>:
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8000990:	4b0c      	ldr	r3, [pc, #48]	; (80009c4 <chMBPostAheadI.constprop.23+0x34>)
 8000992:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8000994:	2900      	cmp	r1, #0
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8000996:	b510      	push	{r4, lr}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8000998:	dd10      	ble.n	80009bc <chMBPostAheadI.constprop.23+0x2c>
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 800099a:	68da      	ldr	r2, [r3, #12]
 800099c:	681c      	ldr	r4, [r3, #0]
 800099e:	3a04      	subs	r2, #4
 80009a0:	3901      	subs	r1, #1
 80009a2:	42a2      	cmp	r2, r4
 80009a4:	6259      	str	r1, [r3, #36]	; 0x24
 80009a6:	60da      	str	r2, [r3, #12]
 80009a8:	d202      	bcs.n	80009b0 <chMBPostAheadI.constprop.23+0x20>
    mbp->mb_rdptr = mbp->mb_top - 1;
 80009aa:	685a      	ldr	r2, [r3, #4]
 80009ac:	3a04      	subs	r2, #4
 80009ae:	60da      	str	r2, [r3, #12]
  }
  *mbp->mb_rdptr = msg;
 80009b0:	6010      	str	r0, [r2, #0]
  chSemSignalI(&mbp->mb_fullsem);
 80009b2:	4805      	ldr	r0, [pc, #20]	; (80009c8 <chMBPostAheadI.constprop.23+0x38>)
 80009b4:	f003 fc4c 	bl	8004250 <chSemSignalI>

  return MSG_OK;
 80009b8:	2000      	movs	r0, #0
 80009ba:	bd10      	pop	{r4, pc}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 80009bc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  }
  *mbp->mb_rdptr = msg;
  chSemSignalI(&mbp->mb_fullsem);

  return MSG_OK;
}
 80009c0:	bd10      	pop	{r4, pc}
 80009c2:	bf00      	nop
 80009c4:	20000840 	.word	0x20000840
 80009c8:	20000850 	.word	0x20000850
 80009cc:	f3af 8000 	nop.w

080009d0 <chMBFetchI.constprop.21>:
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
 80009d0:	4b0c      	ldr	r3, [pc, #48]	; (8000a04 <chMBFetchI.constprop.21+0x34>)
 80009d2:	699a      	ldr	r2, [r3, #24]
 80009d4:	2a00      	cmp	r2, #0
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 80009d6:	b510      	push	{r4, lr}

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
 80009d8:	dd11      	ble.n	80009fe <chMBFetchI.constprop.21+0x2e>
 80009da:	1e51      	subs	r1, r2, #1
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 80009dc:	68da      	ldr	r2, [r3, #12]
 80009de:	6199      	str	r1, [r3, #24]
  if (mbp->mb_rdptr >= mbp->mb_top) {
 80009e0:	6859      	ldr	r1, [r3, #4]

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 80009e2:	6814      	ldr	r4, [r2, #0]
 80009e4:	3204      	adds	r2, #4
  if (mbp->mb_rdptr >= mbp->mb_top) {
 80009e6:	428a      	cmp	r2, r1

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 80009e8:	60da      	str	r2, [r3, #12]
 80009ea:	6004      	str	r4, [r0, #0]
  if (mbp->mb_rdptr >= mbp->mb_top) {
    mbp->mb_rdptr = mbp->mb_buffer;
 80009ec:	bf28      	it	cs
 80009ee:	681a      	ldrcs	r2, [r3, #0]
  }
  chSemSignalI(&mbp->mb_emptysem);
 80009f0:	4805      	ldr	r0, [pc, #20]	; (8000a08 <chMBFetchI.constprop.21+0x38>)
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
  if (mbp->mb_rdptr >= mbp->mb_top) {
    mbp->mb_rdptr = mbp->mb_buffer;
 80009f2:	bf28      	it	cs
 80009f4:	60da      	strcs	r2, [r3, #12]
  }
  chSemSignalI(&mbp->mb_emptysem);
 80009f6:	f003 fc2b 	bl	8004250 <chSemSignalI>

  return MSG_OK;
 80009fa:	2000      	movs	r0, #0
 80009fc:	bd10      	pop	{r4, pc}

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 80009fe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    mbp->mb_rdptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_emptysem);

  return MSG_OK;
}
 8000a02:	bd10      	pop	{r4, pc}
 8000a04:	20000840 	.word	0x20000840
 8000a08:	2000085c 	.word	0x2000085c
 8000a0c:	00000000 	.word	0x00000000

08000a10 <usbStartReceiveI.constprop.11>:
bool usbStartReceiveI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 8000a10:	8943      	ldrh	r3, [r0, #10]
 8000a12:	f013 0201 	ands.w	r2, r3, #1
 * @retval false        Operation started successfully.
 * @retval true         Endpoint busy, operation not started.
 *
 * @iclass
 */
bool usbStartReceiveI(USBDriver *usbp, usbep_t ep) {
 8000a16:	b410      	push	{r4}

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 8000a18:	d003      	beq.n	8000a22 <usbStartReceiveI.constprop.11+0x12>
    return true;
 8000a1a:	2001      	movs	r0, #1
  }

  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  usb_lld_start_out(usbp, ep);
  return false;
}
 8000a1c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000a20:	4770      	bx	lr
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_CNAK;
 8000a22:	6d01      	ldr	r1, [r0, #80]	; 0x50
 8000a24:	f8d1 4b00 	ldr.w	r4, [r1, #2816]	; 0xb00

  if (usbGetReceiveStatusI(usbp, ep)) {
    return true;
  }

  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000a28:	f043 0301 	orr.w	r3, r3, #1
 8000a2c:	f044 6480 	orr.w	r4, r4, #67108864	; 0x4000000
 8000a30:	8143      	strh	r3, [r0, #10]
  usb_lld_start_out(usbp, ep);
  return false;
 8000a32:	4610      	mov	r0, r2
 8000a34:	f8c1 4b00 	str.w	r4, [r1, #2816]	; 0xb00
}
 8000a38:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000a3c:	4770      	bx	lr
 8000a3e:	bf00      	nop

08000a40 <usbStartTransmitI.constprop.9>:
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 8000a40:	8903      	ldrh	r3, [r0, #8]
 8000a42:	f013 0101 	ands.w	r1, r3, #1
 * @retval false        Operation started successfully.
 * @retval true         Endpoint busy, operation not started.
 *
 * @iclass
 */
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {
 8000a46:	b410      	push	{r4}

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 8000a48:	d003      	beq.n	8000a52 <usbStartTransmitI.constprop.9+0x12>
    return true;
 8000a4a:	2001      	movs	r0, #1
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  usb_lld_start_in(usbp, ep);
  return false;
}
 8000a4c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000a50:	4770      	bx	lr
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8000a52:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8000a54:	f8d2 4900 	ldr.w	r4, [r2, #2304]	; 0x900

  if (usbGetTransmitStatusI(usbp, ep)) {
    return true;
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000a58:	f043 0301 	orr.w	r3, r3, #1
 8000a5c:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 8000a60:	8103      	strh	r3, [r0, #8]
 8000a62:	f8c2 4900 	str.w	r4, [r2, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8000a66:	f8d2 3834 	ldr.w	r3, [r2, #2100]	; 0x834
  usb_lld_start_in(usbp, ep);
  return false;
}
 8000a6a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000a6e:	f043 0301 	orr.w	r3, r3, #1
    return true;
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  usb_lld_start_in(usbp, ep);
  return false;
 8000a72:	4608      	mov	r0, r1
 8000a74:	f8c2 3834 	str.w	r3, [r2, #2100]	; 0x834
}
 8000a78:	4770      	bx	lr
 8000a7a:	bf00      	nop
 8000a7c:	f3af 8000 	nop.w

08000a80 <_pal_lld_setgroupmode.constprop.6>:
 * @param[in] mode      the mode
 *
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
 8000a80:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000a84:	4b1e      	ldr	r3, [pc, #120]	; (8000b00 <_pal_lld_setgroupmode.constprop.6+0x80>)
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8000a86:	2200      	movs	r2, #0
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8000a88:	2402      	movs	r4, #2
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000a8a:	2707      	movs	r7, #7
      m4 = 15 << ((bit & 7) * 4);
 8000a8c:	260f      	movs	r6, #15
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 8000a8e:	f04f 0801 	mov.w	r8, #1
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 8000a92:	f04f 0c03 	mov.w	ip, #3
 8000a96:	e01d      	b.n	8000ad4 <_pal_lld_setgroupmode.constprop.6+0x54>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000a98:	f8d3 9020 	ldr.w	r9, [r3, #32]
 8000a9c:	ea29 0101 	bic.w	r1, r9, r1
 8000aa0:	430d      	orrs	r5, r1
 8000aa2:	621d      	str	r5, [r3, #32]
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000aa4:	6859      	ldr	r1, [r3, #4]
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 8000aa6:	fa08 f502 	lsl.w	r5, r8, r2
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000aaa:	ea21 0105 	bic.w	r1, r1, r5
 8000aae:	6059      	str	r1, [r3, #4]
 8000ab0:	0051      	lsls	r1, r2, #1
      m2 = 3 << (bit * 2);
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000ab2:	689d      	ldr	r5, [r3, #8]
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 8000ab4:	fa0c f101 	lsl.w	r1, ip, r1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000ab8:	43c9      	mvns	r1, r1
 8000aba:	400d      	ands	r5, r1
 8000abc:	609d      	str	r5, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8000abe:	68dd      	ldr	r5, [r3, #12]
 8000ac0:	400d      	ands	r5, r1
 8000ac2:	60dd      	str	r5, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 8000ac4:	681d      	ldr	r5, [r3, #0]
 8000ac6:	4029      	ands	r1, r5
 8000ac8:	4321      	orrs	r1, r4
 8000aca:	6019      	str	r1, [r3, #0]
    }
    mask >>= 1;
    if (!mask)
 8000acc:	0840      	lsrs	r0, r0, #1
 8000ace:	d014      	beq.n	8000afa <_pal_lld_setgroupmode.constprop.6+0x7a>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 8000ad0:	00a4      	lsls	r4, r4, #2
    bit++;
 8000ad2:	3201      	adds	r2, #1
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000ad4:	f002 0107 	and.w	r1, r2, #7
 8000ad8:	0089      	lsls	r1, r1, #2
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 8000ada:	f010 0f01 	tst.w	r0, #1
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000ade:	fa07 f501 	lsl.w	r5, r7, r1
      m4 = 15 << ((bit & 7) * 4);
 8000ae2:	fa06 f101 	lsl.w	r1, r6, r1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 8000ae6:	d0f1      	beq.n	8000acc <_pal_lld_setgroupmode.constprop.6+0x4c>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
 8000ae8:	2a07      	cmp	r2, #7
 8000aea:	d9d5      	bls.n	8000a98 <_pal_lld_setgroupmode.constprop.6+0x18>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000aec:	f8d3 9024 	ldr.w	r9, [r3, #36]	; 0x24
 8000af0:	ea29 0101 	bic.w	r1, r9, r1
 8000af4:	430d      	orrs	r5, r1
 8000af6:	625d      	str	r5, [r3, #36]	; 0x24
 8000af8:	e7d4      	b.n	8000aa4 <_pal_lld_setgroupmode.constprop.6+0x24>
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
  }
}
 8000afa:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8000afe:	4770      	bx	lr
 8000b00:	40020000 	.word	0x40020000
 8000b04:	f3af 8000 	nop.w
 8000b08:	f3af 8000 	nop.w
 8000b0c:	f3af 8000 	nop.w

08000b10 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8000b10:	4b0a      	ldr	r3, [pc, #40]	; (8000b3c <test_terminate_threads+0x2c>)
 8000b12:	b430      	push	{r4, r5}
 8000b14:	f103 0014 	add.w	r0, r3, #20
 8000b18:	2520      	movs	r5, #32
 8000b1a:	2400      	movs	r4, #0
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 8000b1c:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8000b20:	b13a      	cbz	r2, 8000b32 <test_terminate_threads+0x22>
 8000b22:	f385 8811 	msr	BASEPRI, r5
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->p_flags |= CH_FLAG_TERMINATE;
 8000b26:	7f51      	ldrb	r1, [r2, #29]
 8000b28:	f041 0104 	orr.w	r1, r1, #4
 8000b2c:	7751      	strb	r1, [r2, #29]
 8000b2e:	f384 8811 	msr	BASEPRI, r4
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 8000b32:	4283      	cmp	r3, r0
 8000b34:	d1f2      	bne.n	8000b1c <test_terminate_threads+0xc>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 8000b36:	bc30      	pop	{r4, r5}
 8000b38:	4770      	bx	lr
 8000b3a:	bf00      	nop
 8000b3c:	20001354 	.word	0x20001354

08000b40 <_test_assert_time_window>:
    return _test_fail(point);
  clear_tokens();
  return FALSE;
}

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {
 8000b40:	b410      	push	{r4}
 8000b42:	2320      	movs	r3, #32
 8000b44:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000b48:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 8000b4c:	2300      	movs	r3, #0
 8000b4e:	6a64      	ldr	r4, [r4, #36]	; 0x24
 8000b50:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((time - start) < (end - start));
 8000b54:	1a64      	subs	r4, r4, r1
 8000b56:	1a51      	subs	r1, r2, r1
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
 8000b58:	428c      	cmp	r4, r1
 8000b5a:	d306      	bcc.n	8000b6a <_test_assert_time_window+0x2a>
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000b5c:	4c05      	ldr	r4, [pc, #20]	; (8000b74 <_test_assert_time_window+0x34>)
  local_fail = TRUE;
 8000b5e:	4906      	ldr	r1, [pc, #24]	; (8000b78 <_test_assert_time_window+0x38>)
  failpoint = point;
 8000b60:	4a06      	ldr	r2, [pc, #24]	; (8000b7c <_test_assert_time_window+0x3c>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000b62:	2301      	movs	r3, #1
 8000b64:	7023      	strb	r3, [r4, #0]
  local_fail = TRUE;
 8000b66:	700b      	strb	r3, [r1, #0]
  failpoint = point;
 8000b68:	6010      	str	r0, [r2, #0]
}

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {

  return _test_assert(point, chVTIsSystemTimeWithin(start, end));
}
 8000b6a:	4618      	mov	r0, r3
 8000b6c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000b70:	4770      	bx	lr
 8000b72:	bf00      	nop
 8000b74:	20000fc0 	.word	0x20000fc0
 8000b78:	20000f90 	.word	0x20000f90
 8000b7c:	20000f98 	.word	0x20000f98

08000b80 <_test_assert_sequence>:
  if (!condition)
    return _test_fail(point);
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
 8000b80:	b4f0      	push	{r4, r5, r6, r7}
 8000b82:	4e0e      	ldr	r6, [pc, #56]	; (8000bbc <_test_assert_sequence+0x3c>)
  char *cp = tokens_buffer;
 8000b84:	4f0e      	ldr	r7, [pc, #56]	; (8000bc0 <_test_assert_sequence+0x40>)
 8000b86:	6835      	ldr	r5, [r6, #0]
 8000b88:	463b      	mov	r3, r7
 8000b8a:	e005      	b.n	8000b98 <_test_assert_sequence+0x18>
  while (cp < tokp) {
    if (*cp++ != *expected++)
 8000b8c:	f813 4b01 	ldrb.w	r4, [r3], #1
 8000b90:	f811 2b01 	ldrb.w	r2, [r1], #1
 8000b94:	4294      	cmp	r4, r2
 8000b96:	d107      	bne.n	8000ba8 <_test_assert_sequence+0x28>
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
 8000b98:	42ab      	cmp	r3, r5
 8000b9a:	d3f7      	bcc.n	8000b8c <_test_assert_sequence+0xc>
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
 8000b9c:	780b      	ldrb	r3, [r1, #0]
 8000b9e:	b91b      	cbnz	r3, 8000ba8 <_test_assert_sequence+0x28>
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8000ba0:	6037      	str	r7, [r6, #0]
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
}
 8000ba2:	4618      	mov	r0, r3
 8000ba4:	bcf0      	pop	{r4, r5, r6, r7}
 8000ba6:	4770      	bx	lr
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000ba8:	4c06      	ldr	r4, [pc, #24]	; (8000bc4 <_test_assert_sequence+0x44>)
  local_fail = TRUE;
 8000baa:	4907      	ldr	r1, [pc, #28]	; (8000bc8 <_test_assert_sequence+0x48>)
  failpoint = point;
 8000bac:	4a07      	ldr	r2, [pc, #28]	; (8000bcc <_test_assert_sequence+0x4c>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000bae:	2301      	movs	r3, #1
 8000bb0:	7023      	strb	r3, [r4, #0]
  local_fail = TRUE;
  failpoint = point;
 8000bb2:	6010      	str	r0, [r2, #0]
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
 8000bb4:	700b      	strb	r3, [r1, #0]
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
}
 8000bb6:	4618      	mov	r0, r3
 8000bb8:	bcf0      	pop	{r4, r5, r6, r7}
 8000bba:	4770      	bx	lr
 8000bbc:	20000fc4 	.word	0x20000fc4
 8000bc0:	200011f4 	.word	0x200011f4
 8000bc4:	20000fc0 	.word	0x20000fc0
 8000bc8:	20000f90 	.word	0x20000f90
 8000bcc:	20000f98 	.word	0x20000f98

08000bd0 <_test_assert>:
  local_fail = TRUE;
  failpoint = point;
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {
 8000bd0:	b410      	push	{r4}

  if (!condition)
 8000bd2:	b951      	cbnz	r1, 8000bea <_test_assert+0x1a>
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000bd4:	4c07      	ldr	r4, [pc, #28]	; (8000bf4 <_test_assert+0x24>)
  local_fail = TRUE;
 8000bd6:	4908      	ldr	r1, [pc, #32]	; (8000bf8 <_test_assert+0x28>)
  failpoint = point;
 8000bd8:	4a08      	ldr	r2, [pc, #32]	; (8000bfc <_test_assert+0x2c>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000bda:	2301      	movs	r3, #1
 8000bdc:	7023      	strb	r3, [r4, #0]
  local_fail = TRUE;
  failpoint = point;
 8000bde:	6010      	str	r0, [r2, #0]
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
 8000be0:	700b      	strb	r3, [r1, #0]
bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
}
 8000be2:	4618      	mov	r0, r3
 8000be4:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000be8:	4770      	bx	lr

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
 8000bea:	2300      	movs	r3, #0
}
 8000bec:	4618      	mov	r0, r3
 8000bee:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000bf2:	4770      	bx	lr
 8000bf4:	20000fc0 	.word	0x20000fc0
 8000bf8:	20000f90 	.word	0x20000f90
 8000bfc:	20000f98 	.word	0x20000f98

08000c00 <sem3_execute.9684>:
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static void sem3_execute(void) {
 8000c00:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8000c02:	4b1e      	ldr	r3, [pc, #120]	; (8000c7c <sem3_execute.9684+0x7c>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8000c04:	481e      	ldr	r0, [pc, #120]	; (8000c80 <sem3_execute.9684+0x80>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8000c06:	699a      	ldr	r2, [r3, #24]
 8000c08:	4b1e      	ldr	r3, [pc, #120]	; (8000c84 <sem3_execute.9684+0x84>)
 8000c0a:	6892      	ldr	r2, [r2, #8]
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 8000c0c:	4c1e      	ldr	r4, [pc, #120]	; (8000c88 <sem3_execute.9684+0x88>)
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static void sem3_execute(void) {
 8000c0e:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8000c10:	2100      	movs	r1, #0
 8000c12:	3201      	adds	r2, #1
 8000c14:	9100      	str	r1, [sp, #0]
 8000c16:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8000c1a:	f003 f851 	bl	8003cc0 <chThdCreateStatic>
 8000c1e:	4b1b      	ldr	r3, [pc, #108]	; (8000c8c <sem3_execute.9684+0x8c>)
 8000c20:	6018      	str	r0, [r3, #0]
  chSemSignalWait(&sem1, &sem1);
 8000c22:	f7ff fbdd 	bl	80003e0 <chSemSignalWait.constprop.48.4236>
 8000c26:	6821      	ldr	r1, [r4, #0]
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
 8000c28:	1b0a      	subs	r2, r1, r4
 8000c2a:	4251      	negs	r1, r2
 8000c2c:	4151      	adcs	r1, r2
 8000c2e:	2001      	movs	r0, #1
 8000c30:	f7ff ffce 	bl	8000bd0 <_test_assert>
 8000c34:	b108      	cbz	r0, 8000c3a <sem3_execute.9684+0x3a>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
}
 8000c36:	b002      	add	sp, #8
 8000c38:	bd10      	pop	{r4, pc}
static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
  chSemSignalWait(&sem1, &sem1);
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
 8000c3a:	68a1      	ldr	r1, [r4, #8]
 8000c3c:	f1d1 0101 	rsbs	r1, r1, #1
 8000c40:	bf38      	it	cc
 8000c42:	2100      	movcc	r1, #0
 8000c44:	2002      	movs	r0, #2
 8000c46:	f7ff ffc3 	bl	8000bd0 <_test_assert>
 8000c4a:	2800      	cmp	r0, #0
 8000c4c:	d1f3      	bne.n	8000c36 <sem3_execute.9684+0x36>

  chSemSignalWait(&sem1, &sem1);
 8000c4e:	f7ff fbc7 	bl	80003e0 <chSemSignalWait.constprop.48.4236>
 8000c52:	6821      	ldr	r1, [r4, #0]
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
 8000c54:	1b0b      	subs	r3, r1, r4
 8000c56:	4259      	negs	r1, r3
 8000c58:	4159      	adcs	r1, r3
 8000c5a:	2003      	movs	r0, #3
 8000c5c:	f7ff ffb8 	bl	8000bd0 <_test_assert>
 8000c60:	2800      	cmp	r0, #0
 8000c62:	d1e8      	bne.n	8000c36 <sem3_execute.9684+0x36>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 8000c64:	68a1      	ldr	r1, [r4, #8]
 8000c66:	f1d1 0101 	rsbs	r1, r1, #1
 8000c6a:	f04f 0004 	mov.w	r0, #4
 8000c6e:	bf38      	it	cc
 8000c70:	2100      	movcc	r1, #0
}
 8000c72:	b002      	add	sp, #8
 8000c74:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 8000c78:	f7ff bfaa 	b.w	8000bd0 <_test_assert>
 8000c7c:	20001208 	.word	0x20001208
 8000c80:	20000928 	.word	0x20000928
 8000c84:	08000391 	.word	0x08000391
 8000c88:	20000800 	.word	0x20000800
 8000c8c:	20001358 	.word	0x20001358

08000c90 <sys3_execute.11184>:
 * <h2>Description</h2>
 * The chSysIntegrityCheckI() API is invoked in order to asses the state of the
 * system data structures.
 */

static void sys3_execute(void) {
 8000c90:	b538      	push	{r3, r4, r5, lr}
 8000c92:	2420      	movs	r4, #32
 8000c94:	f384 8811 	msr	BASEPRI, r4
  bool result;

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 8000c98:	2001      	movs	r0, #1
 8000c9a:	f003 fb01 	bl	80042a0 <chSysIntegrityCheckI>
 8000c9e:	2300      	movs	r3, #0
 8000ca0:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  test_assert(1, result == false, "ready list check failed");
 8000ca4:	f080 0101 	eor.w	r1, r0, #1
 8000ca8:	b2c9      	uxtb	r1, r1
 8000caa:	2001      	movs	r0, #1
 8000cac:	f7ff ff90 	bl	8000bd0 <_test_assert>
 8000cb0:	4605      	mov	r5, r0
 8000cb2:	b100      	cbz	r0, 8000cb6 <sys3_execute.11184+0x26>
 8000cb4:	bd38      	pop	{r3, r4, r5, pc}
 8000cb6:	f384 8811 	msr	BASEPRI, r4

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 8000cba:	2002      	movs	r0, #2
 8000cbc:	f003 faf0 	bl	80042a0 <chSysIntegrityCheckI>
 8000cc0:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();
  test_assert(2, result == false, "virtual timers list check failed");
 8000cc4:	f080 0101 	eor.w	r1, r0, #1
 8000cc8:	b2c9      	uxtb	r1, r1
 8000cca:	2002      	movs	r0, #2
 8000ccc:	f7ff ff80 	bl	8000bd0 <_test_assert>
 8000cd0:	4605      	mov	r5, r0
 8000cd2:	2800      	cmp	r0, #0
 8000cd4:	d1ee      	bne.n	8000cb4 <sys3_execute.11184+0x24>
 8000cd6:	f384 8811 	msr	BASEPRI, r4

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 8000cda:	2004      	movs	r0, #4
 8000cdc:	f003 fae0 	bl	80042a0 <chSysIntegrityCheckI>
 8000ce0:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();
  test_assert(3, result == false, "registry list check failed");
 8000ce4:	f080 0101 	eor.w	r1, r0, #1
 8000ce8:	b2c9      	uxtb	r1, r1
 8000cea:	2003      	movs	r0, #3
 8000cec:	f7ff ff70 	bl	8000bd0 <_test_assert>
 8000cf0:	4605      	mov	r5, r0
 8000cf2:	2800      	cmp	r0, #0
 8000cf4:	d1de      	bne.n	8000cb4 <sys3_execute.11184+0x24>
 8000cf6:	f384 8811 	msr	BASEPRI, r4

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 8000cfa:	2008      	movs	r0, #8
 8000cfc:	f003 fad0 	bl	80042a0 <chSysIntegrityCheckI>
 8000d00:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();
  test_assert(4, result == false, "port layer check failed");
 8000d04:	f080 0101 	eor.w	r1, r0, #1
 8000d08:	b2c9      	uxtb	r1, r1
 8000d0a:	2004      	movs	r0, #4
}
 8000d0c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  test_assert(3, result == false, "registry list check failed");

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
  chSysUnlock();
  test_assert(4, result == false, "port layer check failed");
 8000d10:	f7ff bf5e 	b.w	8000bd0 <_test_assert>
 8000d14:	f3af 8000 	nop.w
 8000d18:	f3af 8000 	nop.w
 8000d1c:	f3af 8000 	nop.w

08000d20 <heap1_execute.10672>:
static void heap1_setup(void) {

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
}

static void heap1_execute(void) {
 8000d20:	b570      	push	{r4, r5, r6, lr}
 8000d22:	b082      	sub	sp, #8

  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
 8000d24:	a901      	add	r1, sp, #4
 8000d26:	2000      	movs	r0, #0
 8000d28:	f003 f9da 	bl	80040e0 <chHeapStatus>
  p1 = chHeapAlloc(NULL, SIZE);
 8000d2c:	2110      	movs	r1, #16
 8000d2e:	2000      	movs	r0, #0
 8000d30:	f003 fa46 	bl	80041c0 <chHeapAlloc>
  test_assert(1, p1 != NULL, "allocation failed");
 8000d34:	1c01      	adds	r1, r0, #0
 8000d36:	4604      	mov	r4, r0
 8000d38:	bf18      	it	ne
 8000d3a:	2101      	movne	r1, #1
 8000d3c:	2001      	movs	r0, #1
 8000d3e:	f7ff ff47 	bl	8000bd0 <_test_assert>
 8000d42:	4605      	mov	r5, r0
 8000d44:	b108      	cbz	r0, 8000d4a <heap1_execute.10672+0x2a>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
  chHeapFree(p1);

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
  test_assert(12, n == sz, "size changed");
}
 8000d46:	b002      	add	sp, #8
 8000d48:	bd70      	pop	{r4, r5, r6, pc}
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
  p1 = chHeapAlloc(NULL, SIZE);
  test_assert(1, p1 != NULL, "allocation failed");
  chHeapFree(p1);
 8000d4a:	4620      	mov	r0, r4
 8000d4c:	f003 f9e8 	bl	8004120 <chHeapFree>
  p1 = chHeapAlloc(NULL, (size_t)-256);
 8000d50:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 8000d54:	4628      	mov	r0, r5
 8000d56:	f003 fa33 	bl	80041c0 <chHeapAlloc>
  test_assert(2, p1 == NULL, "allocation not failed");
 8000d5a:	f1d0 0101 	rsbs	r1, r0, #1
 8000d5e:	bf38      	it	cc
 8000d60:	2100      	movcc	r1, #0
 8000d62:	2002      	movs	r0, #2
 8000d64:	f7ff ff34 	bl	8000bd0 <_test_assert>
 8000d68:	2800      	cmp	r0, #0
 8000d6a:	d1ec      	bne.n	8000d46 <heap1_execute.10672+0x26>

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);
 8000d6c:	a901      	add	r1, sp, #4
 8000d6e:	487b      	ldr	r0, [pc, #492]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000d70:	f003 f9b6 	bl	80040e0 <chHeapStatus>

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8000d74:	2110      	movs	r1, #16
 8000d76:	4879      	ldr	r0, [pc, #484]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000d78:	f003 fa22 	bl	80041c0 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8000d7c:	2110      	movs	r1, #16

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8000d7e:	4605      	mov	r5, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8000d80:	4876      	ldr	r0, [pc, #472]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000d82:	f003 fa1d 	bl	80041c0 <chHeapAlloc>
  p3 = chHeapAlloc(&test_heap, SIZE);
 8000d86:	2110      	movs	r1, #16
  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
  p2 = chHeapAlloc(&test_heap, SIZE);
 8000d88:	4604      	mov	r4, r0
  p3 = chHeapAlloc(&test_heap, SIZE);
 8000d8a:	4874      	ldr	r0, [pc, #464]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000d8c:	f003 fa18 	bl	80041c0 <chHeapAlloc>
 8000d90:	4606      	mov	r6, r0
  chHeapFree(p1);                               /* Does not merge.*/
 8000d92:	4628      	mov	r0, r5
 8000d94:	f003 f9c4 	bl	8004120 <chHeapFree>
  chHeapFree(p2);                               /* Merges backward.*/
 8000d98:	4620      	mov	r0, r4
 8000d9a:	f003 f9c1 	bl	8004120 <chHeapFree>
  chHeapFree(p3);                               /* Merges both sides.*/
 8000d9e:	4630      	mov	r0, r6
 8000da0:	f003 f9be 	bl	8004120 <chHeapFree>
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8000da4:	4669      	mov	r1, sp
 8000da6:	486d      	ldr	r0, [pc, #436]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000da8:	f003 f99a 	bl	80040e0 <chHeapStatus>
 8000dac:	1e42      	subs	r2, r0, #1
 8000dae:	4251      	negs	r1, r2
 8000db0:	4151      	adcs	r1, r2
 8000db2:	2003      	movs	r0, #3
 8000db4:	f7ff ff0c 	bl	8000bd0 <_test_assert>
 8000db8:	2800      	cmp	r0, #0
 8000dba:	d1c4      	bne.n	8000d46 <heap1_execute.10672+0x26>

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8000dbc:	2110      	movs	r1, #16
 8000dbe:	4867      	ldr	r0, [pc, #412]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000dc0:	f003 f9fe 	bl	80041c0 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8000dc4:	2110      	movs	r1, #16
  chHeapFree(p2);                               /* Merges backward.*/
  chHeapFree(p3);                               /* Merges both sides.*/
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8000dc6:	4604      	mov	r4, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8000dc8:	4864      	ldr	r0, [pc, #400]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000dca:	f003 f9f9 	bl	80041c0 <chHeapAlloc>
  p3 = chHeapAlloc(&test_heap, SIZE);
 8000dce:	2110      	movs	r1, #16
  chHeapFree(p3);                               /* Merges both sides.*/
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
  p2 = chHeapAlloc(&test_heap, SIZE);
 8000dd0:	4605      	mov	r5, r0
  p3 = chHeapAlloc(&test_heap, SIZE);
 8000dd2:	4862      	ldr	r0, [pc, #392]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000dd4:	f003 f9f4 	bl	80041c0 <chHeapAlloc>
  chHeapFree(p3);                               /* Merges forward.*/
 8000dd8:	f003 f9a2 	bl	8004120 <chHeapFree>
  chHeapFree(p2);                               /* Merges forward.*/
 8000ddc:	4628      	mov	r0, r5
 8000dde:	f003 f99f 	bl	8004120 <chHeapFree>
  chHeapFree(p1);                               /* Merges forward.*/
 8000de2:	4620      	mov	r0, r4
 8000de4:	f003 f99c 	bl	8004120 <chHeapFree>
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8000de8:	4669      	mov	r1, sp
 8000dea:	485c      	ldr	r0, [pc, #368]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000dec:	f003 f978 	bl	80040e0 <chHeapStatus>
 8000df0:	1e43      	subs	r3, r0, #1
 8000df2:	4259      	negs	r1, r3
 8000df4:	4159      	adcs	r1, r3
 8000df6:	2004      	movs	r0, #4
 8000df8:	f7ff feea 	bl	8000bd0 <_test_assert>
 8000dfc:	2800      	cmp	r0, #0
 8000dfe:	d1a2      	bne.n	8000d46 <heap1_execute.10672+0x26>

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 8000e00:	2111      	movs	r1, #17
 8000e02:	4856      	ldr	r0, [pc, #344]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000e04:	f003 f9dc 	bl	80041c0 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8000e08:	2110      	movs	r1, #16
  chHeapFree(p2);                               /* Merges forward.*/
  chHeapFree(p1);                               /* Merges forward.*/
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 8000e0a:	4604      	mov	r4, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8000e0c:	4853      	ldr	r0, [pc, #332]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000e0e:	f003 f9d7 	bl	80041c0 <chHeapAlloc>
 8000e12:	4605      	mov	r5, r0
  chHeapFree(p1);
 8000e14:	4620      	mov	r0, r4
 8000e16:	f003 f983 	bl	8004120 <chHeapFree>
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 8000e1a:	4669      	mov	r1, sp
 8000e1c:	484f      	ldr	r0, [pc, #316]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000e1e:	f003 f95f 	bl	80040e0 <chHeapStatus>
 8000e22:	f1b0 0c02 	subs.w	ip, r0, #2
 8000e26:	f1dc 0100 	rsbs	r1, ip, #0
 8000e2a:	eb51 010c 	adcs.w	r1, r1, ip
 8000e2e:	2005      	movs	r0, #5
 8000e30:	f7ff fece 	bl	8000bd0 <_test_assert>
 8000e34:	2800      	cmp	r0, #0
 8000e36:	d186      	bne.n	8000d46 <heap1_execute.10672+0x26>
  p1 = chHeapAlloc(&test_heap, SIZE);
 8000e38:	2110      	movs	r1, #16
 8000e3a:	4848      	ldr	r0, [pc, #288]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000e3c:	f003 f9c0 	bl	80041c0 <chHeapAlloc>
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8000e40:	4669      	mov	r1, sp
  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
  p2 = chHeapAlloc(&test_heap, SIZE);
  chHeapFree(p1);
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
  p1 = chHeapAlloc(&test_heap, SIZE);
 8000e42:	4604      	mov	r4, r0
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8000e44:	4845      	ldr	r0, [pc, #276]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000e46:	f003 f94b 	bl	80040e0 <chHeapStatus>
 8000e4a:	2801      	cmp	r0, #1
 8000e4c:	f000 8083 	beq.w	8000f56 <heap1_execute.10672+0x236>
 8000e50:	4669      	mov	r1, sp
 8000e52:	4842      	ldr	r0, [pc, #264]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000e54:	f003 f944 	bl	80040e0 <chHeapStatus>
 8000e58:	f1b0 0e02 	subs.w	lr, r0, #2
 8000e5c:	f1de 0100 	rsbs	r1, lr, #0
 8000e60:	eb51 010e 	adcs.w	r1, r1, lr
 8000e64:	2006      	movs	r0, #6
 8000e66:	f7ff feb3 	bl	8000bd0 <_test_assert>
 8000e6a:	2800      	cmp	r0, #0
 8000e6c:	f47f af6b 	bne.w	8000d46 <heap1_execute.10672+0x26>
                 (chHeapStatus(&test_heap, &n) == 2), "heap fragmented");
  chHeapFree(p2);
 8000e70:	4628      	mov	r0, r5
 8000e72:	f003 f955 	bl	8004120 <chHeapFree>
  chHeapFree(p1);
 8000e76:	4620      	mov	r0, r4
 8000e78:	f003 f952 	bl	8004120 <chHeapFree>
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8000e7c:	4669      	mov	r1, sp
 8000e7e:	4837      	ldr	r0, [pc, #220]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000e80:	f003 f92e 	bl	80040e0 <chHeapStatus>
 8000e84:	1e46      	subs	r6, r0, #1
 8000e86:	4271      	negs	r1, r6
 8000e88:	4171      	adcs	r1, r6
 8000e8a:	2007      	movs	r0, #7
 8000e8c:	f7ff fea0 	bl	8000bd0 <_test_assert>
 8000e90:	2800      	cmp	r0, #0
 8000e92:	f47f af58 	bne.w	8000d46 <heap1_execute.10672+0x26>

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8000e96:	2110      	movs	r1, #16
 8000e98:	4830      	ldr	r0, [pc, #192]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000e9a:	f003 f991 	bl	80041c0 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8000e9e:	2110      	movs	r1, #16
  chHeapFree(p2);
  chHeapFree(p1);
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8000ea0:	4605      	mov	r5, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8000ea2:	482e      	ldr	r0, [pc, #184]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000ea4:	f003 f98c 	bl	80041c0 <chHeapAlloc>
 8000ea8:	4604      	mov	r4, r0
  chHeapFree(p1);
 8000eaa:	4628      	mov	r0, r5
 8000eac:	f003 f938 	bl	8004120 <chHeapFree>
  test_assert(8, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 8000eb0:	4669      	mov	r1, sp
 8000eb2:	482a      	ldr	r0, [pc, #168]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000eb4:	f003 f914 	bl	80040e0 <chHeapStatus>
 8000eb8:	1e85      	subs	r5, r0, #2
 8000eba:	4269      	negs	r1, r5
 8000ebc:	4169      	adcs	r1, r5
 8000ebe:	2008      	movs	r0, #8
 8000ec0:	f7ff fe86 	bl	8000bd0 <_test_assert>
 8000ec4:	2800      	cmp	r0, #0
 8000ec6:	f47f af3e 	bne.w	8000d46 <heap1_execute.10672+0x26>
  p1 = chHeapAlloc(&test_heap, SIZE * 2);       /* Skips first fragment.*/
 8000eca:	2120      	movs	r1, #32
 8000ecc:	4823      	ldr	r0, [pc, #140]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000ece:	f003 f977 	bl	80041c0 <chHeapAlloc>
  chHeapFree(p1);
 8000ed2:	f003 f925 	bl	8004120 <chHeapFree>
  chHeapFree(p2);
 8000ed6:	4620      	mov	r0, r4
 8000ed8:	f003 f922 	bl	8004120 <chHeapFree>
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8000edc:	4669      	mov	r1, sp
 8000ede:	481f      	ldr	r0, [pc, #124]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000ee0:	f003 f8fe 	bl	80040e0 <chHeapStatus>
 8000ee4:	3801      	subs	r0, #1
 8000ee6:	4241      	negs	r1, r0
 8000ee8:	4141      	adcs	r1, r0
 8000eea:	2009      	movs	r0, #9
 8000eec:	f7ff fe70 	bl	8000bd0 <_test_assert>
 8000ef0:	2800      	cmp	r0, #0
 8000ef2:	f47f af28 	bne.w	8000d46 <heap1_execute.10672+0x26>

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
 8000ef6:	4669      	mov	r1, sp
 8000ef8:	4818      	ldr	r0, [pc, #96]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000efa:	f003 f8f1 	bl	80040e0 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, n);
 8000efe:	9900      	ldr	r1, [sp, #0]
 8000f00:	4816      	ldr	r0, [pc, #88]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000f02:	f003 f95d 	bl	80041c0 <chHeapAlloc>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 8000f06:	4669      	mov	r1, sp
  chHeapFree(p2);
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
  p1 = chHeapAlloc(&test_heap, n);
 8000f08:	4604      	mov	r4, r0
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 8000f0a:	4814      	ldr	r0, [pc, #80]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000f0c:	f003 f8e8 	bl	80040e0 <chHeapStatus>
 8000f10:	f1d0 0101 	rsbs	r1, r0, #1
 8000f14:	bf38      	it	cc
 8000f16:	2100      	movcc	r1, #0
 8000f18:	200a      	movs	r0, #10
 8000f1a:	f7ff fe59 	bl	8000bd0 <_test_assert>
 8000f1e:	2800      	cmp	r0, #0
 8000f20:	f47f af11 	bne.w	8000d46 <heap1_execute.10672+0x26>
  chHeapFree(p1);
 8000f24:	4620      	mov	r0, r4
 8000f26:	f003 f8fb 	bl	8004120 <chHeapFree>

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8000f2a:	4669      	mov	r1, sp
 8000f2c:	480b      	ldr	r0, [pc, #44]	; (8000f5c <heap1_execute.10672+0x23c>)
 8000f2e:	f003 f8d7 	bl	80040e0 <chHeapStatus>
 8000f32:	1e42      	subs	r2, r0, #1
 8000f34:	4251      	negs	r1, r2
 8000f36:	4151      	adcs	r1, r2
 8000f38:	200b      	movs	r0, #11
 8000f3a:	f7ff fe49 	bl	8000bd0 <_test_assert>
 8000f3e:	2800      	cmp	r0, #0
 8000f40:	f47f af01 	bne.w	8000d46 <heap1_execute.10672+0x26>
  test_assert(12, n == sz, "size changed");
 8000f44:	e89d 000a 	ldmia.w	sp, {r1, r3}
 8000f48:	1acb      	subs	r3, r1, r3
 8000f4a:	4259      	negs	r1, r3
 8000f4c:	4159      	adcs	r1, r3
 8000f4e:	200c      	movs	r0, #12
 8000f50:	f7ff fe3e 	bl	8000bd0 <_test_assert>
 8000f54:	e6f7      	b.n	8000d46 <heap1_execute.10672+0x26>
  chHeapFree(p1);
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
  p1 = chHeapAlloc(&test_heap, SIZE);
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8000f56:	4601      	mov	r1, r0
 8000f58:	e784      	b.n	8000e64 <heap1_execute.10672+0x144>
 8000f5a:	bf00      	nop
 8000f5c:	20001508 	.word	0x20001508

08000f60 <thd3_execute.9387>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_CFG_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
 8000f60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8000f62:	4e4b      	ldr	r6, [pc, #300]	; (8001090 <thd3_execute.9387+0x130>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8000f64:	69b3      	ldr	r3, [r6, #24]
 8000f66:	689c      	ldr	r4, [r3, #8]
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
 8000f68:	1c65      	adds	r5, r4, #1
 8000f6a:	4628      	mov	r0, r5
 8000f6c:	f002 fe30 	bl	8003bd0 <chThdSetPriority>
  test_assert(1, p1 == prio,
 8000f70:	ebb0 0c04 	subs.w	ip, r0, r4
 8000f74:	f1dc 0100 	rsbs	r1, ip, #0

static void thd3_execute(void) {
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
 8000f78:	4607      	mov	r7, r0
  test_assert(1, p1 == prio,
 8000f7a:	eb51 010c 	adcs.w	r1, r1, ip
 8000f7e:	2001      	movs	r0, #1
 8000f80:	f7ff fe26 	bl	8000bd0 <_test_assert>
 8000f84:	b100      	cbz	r0, 8000f88 <thd3_execute.9387+0x28>
 8000f86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000f88:	69b3      	ldr	r3, [r6, #24]
              "unexpected returned priority level");
  test_assert(2, chThdGetPriorityX() == prio + 1,
 8000f8a:	6899      	ldr	r1, [r3, #8]
 8000f8c:	ebb5 0e01 	subs.w	lr, r5, r1
 8000f90:	f1de 0100 	rsbs	r1, lr, #0
 8000f94:	eb51 010e 	adcs.w	r1, r1, lr
 8000f98:	2002      	movs	r0, #2
 8000f9a:	f7ff fe19 	bl	8000bd0 <_test_assert>
 8000f9e:	2800      	cmp	r0, #0
 8000fa0:	d1f1      	bne.n	8000f86 <thd3_execute.9387+0x26>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
 8000fa2:	4638      	mov	r0, r7
 8000fa4:	f002 fe14 	bl	8003bd0 <chThdSetPriority>
  test_assert(3, p1 == prio + 1,
 8000fa8:	1a28      	subs	r0, r5, r0
 8000faa:	4241      	negs	r1, r0
 8000fac:	4141      	adcs	r1, r0
 8000fae:	2003      	movs	r0, #3
 8000fb0:	f7ff fe0e 	bl	8000bd0 <_test_assert>
 8000fb4:	2800      	cmp	r0, #0
 8000fb6:	d1e6      	bne.n	8000f86 <thd3_execute.9387+0x26>
 8000fb8:	69b3      	ldr	r3, [r6, #24]
              "unexpected returned priority level");
  test_assert(4, chThdGetPriorityX() == prio,
 8000fba:	6899      	ldr	r1, [r3, #8]
 8000fbc:	1a62      	subs	r2, r4, r1
 8000fbe:	4251      	negs	r1, r2
 8000fc0:	4151      	adcs	r1, r2
 8000fc2:	2004      	movs	r0, #4
 8000fc4:	f7ff fe04 	bl	8000bd0 <_test_assert>
 8000fc8:	2800      	cmp	r0, #0
 8000fca:	d1dc      	bne.n	8000f86 <thd3_execute.9387+0x26>
 8000fcc:	2320      	movs	r3, #32
 8000fce:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8000fd2:	69b3      	ldr	r3, [r6, #24]
              "unexpected priority level");

#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
  chThdGetSelfX()->p_prio += 2;
 8000fd4:	689a      	ldr	r2, [r3, #8]
 8000fd6:	3202      	adds	r2, #2
 8000fd8:	609a      	str	r2, [r3, #8]
 8000fda:	f380 8811 	msr	BASEPRI, r0
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8000fde:	69b3      	ldr	r3, [r6, #24]
  chSysUnlock();
  test_assert(5, chThdGetPriorityX() == prio + 2,
 8000fe0:	6899      	ldr	r1, [r3, #8]
 8000fe2:	1ca7      	adds	r7, r4, #2
 8000fe4:	1a7b      	subs	r3, r7, r1
 8000fe6:	4259      	negs	r1, r3
 8000fe8:	4159      	adcs	r1, r3
 8000fea:	2005      	movs	r0, #5
 8000fec:	f7ff fdf0 	bl	8000bd0 <_test_assert>
 8000ff0:	2800      	cmp	r0, #0
 8000ff2:	d1c8      	bne.n	8000f86 <thd3_execute.9387+0x26>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
 8000ff4:	4628      	mov	r0, r5
 8000ff6:	f002 fdeb 	bl	8003bd0 <chThdSetPriority>
  test_assert(6, p1 == prio,
 8000ffa:	ebb0 0c04 	subs.w	ip, r0, r4
 8000ffe:	f1dc 0100 	rsbs	r1, ip, #0
 8001002:	eb51 010c 	adcs.w	r1, r1, ip
 8001006:	2006      	movs	r0, #6
 8001008:	f7ff fde2 	bl	8000bd0 <_test_assert>
 800100c:	2800      	cmp	r0, #0
 800100e:	d1ba      	bne.n	8000f86 <thd3_execute.9387+0x26>
              "unexpected returned priority level");
  test_assert(7, chThdGetSelfX()->p_prio == prio + 2,
 8001010:	69b3      	ldr	r3, [r6, #24]
 8001012:	6899      	ldr	r1, [r3, #8]
 8001014:	ebb7 0e01 	subs.w	lr, r7, r1
 8001018:	f1de 0100 	rsbs	r1, lr, #0
 800101c:	eb51 010e 	adcs.w	r1, r1, lr
 8001020:	2007      	movs	r0, #7
 8001022:	f7ff fdd5 	bl	8000bd0 <_test_assert>
 8001026:	2800      	cmp	r0, #0
 8001028:	d1ad      	bne.n	8000f86 <thd3_execute.9387+0x26>
              "unexpected priority level");
  test_assert(8, chThdGetSelfX()->p_realprio == prio + 1,
 800102a:	69b3      	ldr	r3, [r6, #24]
 800102c:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 800102e:	1a6f      	subs	r7, r5, r1
 8001030:	4279      	negs	r1, r7
 8001032:	4179      	adcs	r1, r7
 8001034:	2008      	movs	r0, #8
 8001036:	f7ff fdcb 	bl	8000bd0 <_test_assert>
 800103a:	2800      	cmp	r0, #0
 800103c:	d1a3      	bne.n	8000f86 <thd3_execute.9387+0x26>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
 800103e:	1ce7      	adds	r7, r4, #3
 8001040:	4638      	mov	r0, r7
 8001042:	f002 fdc5 	bl	8003bd0 <chThdSetPriority>
  test_assert(9, p1 == prio + 1,
 8001046:	1a28      	subs	r0, r5, r0
 8001048:	4241      	negs	r1, r0
 800104a:	4141      	adcs	r1, r0
 800104c:	2009      	movs	r0, #9
 800104e:	f7ff fdbf 	bl	8000bd0 <_test_assert>
 8001052:	2800      	cmp	r0, #0
 8001054:	d197      	bne.n	8000f86 <thd3_execute.9387+0x26>
              "unexpected returned priority level");
  test_assert(10, chThdGetSelfX()->p_prio == prio + 3,
 8001056:	69b3      	ldr	r3, [r6, #24]
 8001058:	6899      	ldr	r1, [r3, #8]
 800105a:	1a7a      	subs	r2, r7, r1
 800105c:	4251      	negs	r1, r2
 800105e:	4151      	adcs	r1, r2
 8001060:	200a      	movs	r0, #10
 8001062:	f7ff fdb5 	bl	8000bd0 <_test_assert>
 8001066:	2800      	cmp	r0, #0
 8001068:	d18d      	bne.n	8000f86 <thd3_execute.9387+0x26>
              "unexpected priority level");
  test_assert(11, chThdGetSelfX()->p_realprio == prio + 3,
 800106a:	69b3      	ldr	r3, [r6, #24]
 800106c:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 800106e:	1a7b      	subs	r3, r7, r1
 8001070:	4259      	negs	r1, r3
 8001072:	4159      	adcs	r1, r3
 8001074:	200b      	movs	r0, #11
 8001076:	f7ff fdab 	bl	8000bd0 <_test_assert>
 800107a:	2800      	cmp	r0, #0
 800107c:	d183      	bne.n	8000f86 <thd3_execute.9387+0x26>
 800107e:	2320      	movs	r3, #32
 8001080:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001084:	69b3      	ldr	r3, [r6, #24]
              "unexpected real priority level");

  chSysLock();
  chThdGetSelfX()->p_prio = prio;
 8001086:	609c      	str	r4, [r3, #8]
  chThdGetSelfX()->p_realprio = prio;
 8001088:	63dc      	str	r4, [r3, #60]	; 0x3c
 800108a:	f380 8811 	msr	BASEPRI, r0
 800108e:	e77a      	b.n	8000f86 <thd3_execute.9387+0x26>
 8001090:	20001208 	.word	0x20001208
 8001094:	f3af 8000 	nop.w
 8001098:	f3af 8000 	nop.w
 800109c:	f3af 8000 	nop.w

080010a0 <chOQGetI.4191>:
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80010a0:	6983      	ldr	r3, [r0, #24]
 80010a2:	6942      	ldr	r2, [r0, #20]
 80010a4:	429a      	cmp	r2, r3
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 80010a6:	b510      	push	{r4, lr}
 80010a8:	d018      	beq.n	80010dc <chOQGetI.4191+0x3c>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 80010aa:	6884      	ldr	r4, [r0, #8]
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 80010ac:	6901      	ldr	r1, [r0, #16]

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 80010ae:	3401      	adds	r4, #1
  b = *oqp->q_rdptr++;
 80010b0:	1c5a      	adds	r2, r3, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 80010b2:	6084      	str	r4, [r0, #8]
  b = *oqp->q_rdptr++;
 80010b4:	6182      	str	r2, [r0, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
 80010b6:	428a      	cmp	r2, r1
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 80010b8:	781c      	ldrb	r4, [r3, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 80010ba:	d20c      	bcs.n	80010d6 <chOQGetI.4191+0x36>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80010bc:	6803      	ldr	r3, [r0, #0]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 80010be:	4298      	cmp	r0, r3
 80010c0:	d007      	beq.n	80010d2 <chOQGetI.4191+0x32>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80010c2:	681a      	ldr	r2, [r3, #0]
 80010c4:	6002      	str	r2, [r0, #0]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80010c6:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 80010c8:	6050      	str	r0, [r2, #4]
  (void) chSchReadyI(tp);
 80010ca:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80010cc:	6219      	str	r1, [r3, #32]
  (void) chSchReadyI(tp);
 80010ce:	f002 fe97 	bl	8003e00 <chSchReadyI>
    oqp->q_rdptr = oqp->q_buffer;
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);

  return (msg_t)b;
 80010d2:	4620      	mov	r0, r4
 80010d4:	bd10      	pop	{r4, pc}
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
    oqp->q_rdptr = oqp->q_buffer;
 80010d6:	68c3      	ldr	r3, [r0, #12]
 80010d8:	6183      	str	r3, [r0, #24]
 80010da:	e7ef      	b.n	80010bc <chOQGetI.4191+0x1c>
 80010dc:	6882      	ldr	r2, [r0, #8]
 80010de:	2a00      	cmp	r2, #0
 80010e0:	d0e3      	beq.n	80010aa <chOQGetI.4191+0xa>
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
 80010e2:	f06f 0002 	mvn.w	r0, #2
 80010e6:	bd10      	pop	{r4, pc}
 80010e8:	f3af 8000 	nop.w
 80010ec:	f3af 8000 	nop.w

080010f0 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 80010f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 80010f4:	4f4b      	ldr	r7, [pc, #300]	; (8001224 <VectorD8+0x134>)
 80010f6:	6f7d      	ldr	r5, [r7, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 80010f8:	f8d5 800c 	ldr.w	r8, [r5, #12]
  uint16_t sr = u->SR;
 80010fc:	682b      	ldr	r3, [r5, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 80010fe:	05d9      	lsls	r1, r3, #23
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 8001100:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8001102:	d45e      	bmi.n	80011c2 <VectorD8+0xd2>
 8001104:	2320      	movs	r3, #32
 8001106:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800110a:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 800110e:	d108      	bne.n	8001122 <VectorD8+0x32>
 8001110:	e031      	b.n	8001176 <VectorD8+0x86>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 8001112:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8001114:	686e      	ldr	r6, [r5, #4]
    if (sr & USART_SR_RXNE)
 8001116:	d41d      	bmi.n	8001154 <VectorD8+0x64>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 8001118:	682c      	ldr	r4, [r5, #0]
 800111a:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800111c:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001120:	d029      	beq.n	8001176 <VectorD8+0x86>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8001122:	0722      	lsls	r2, r4, #28
 8001124:	d0f5      	beq.n	8001112 <VectorD8+0x22>
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;
 8001126:	f014 0f08 	tst.w	r4, #8
 800112a:	bf14      	ite	ne
 800112c:	2180      	movne	r1, #128	; 0x80
 800112e:	2100      	moveq	r1, #0

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
  if (sr & USART_SR_PE)
 8001130:	07e3      	lsls	r3, r4, #31
    sts |= SD_PARITY_ERROR;
 8001132:	bf48      	it	mi
 8001134:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 8001138:	07a6      	lsls	r6, r4, #30
    sts |= SD_FRAMING_ERROR;
 800113a:	bf48      	it	mi
 800113c:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 8001140:	0760      	lsls	r0, r4, #29
    sts |= SD_NOISE_ERROR;
 8001142:	bf48      	it	mi
 8001144:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001148:	4837      	ldr	r0, [pc, #220]	; (8001228 <VectorD8+0x138>)
 800114a:	f002 fea9 	bl	8003ea0 <chEvtBroadcastFlagsI>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 800114e:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8001150:	686e      	ldr	r6, [r5, #4]
    if (sr & USART_SR_RXNE)
 8001152:	d5e1      	bpl.n	8001118 <VectorD8+0x28>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8001154:	697b      	ldr	r3, [r7, #20]
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8001156:	b37b      	cbz	r3, 80011b8 <VectorD8+0xc8>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 8001158:	b2f1      	uxtb	r1, r6
 800115a:	4834      	ldr	r0, [pc, #208]	; (800122c <VectorD8+0x13c>)
 800115c:	f7ff fb30 	bl	80007c0 <chIQPutI>
 8001160:	2800      	cmp	r0, #0
 8001162:	dad9      	bge.n	8001118 <VectorD8+0x28>
 8001164:	4830      	ldr	r0, [pc, #192]	; (8001228 <VectorD8+0x138>)
 8001166:	2180      	movs	r1, #128	; 0x80
 8001168:	f002 fe9a 	bl	8003ea0 <chEvtBroadcastFlagsI>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 800116c:	682c      	ldr	r4, [r5, #0]
 800116e:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8001170:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001174:	d1d5      	bne.n	8001122 <VectorD8+0x32>
 8001176:	2300      	movs	r3, #0
 8001178:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 800117c:	f018 0f80 	tst.w	r8, #128	; 0x80
 8001180:	d001      	beq.n	8001186 <VectorD8+0x96>
 8001182:	0622      	lsls	r2, r4, #24
 8001184:	d42c      	bmi.n	80011e0 <VectorD8+0xf0>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8001186:	0663      	lsls	r3, r4, #25
 8001188:	d512      	bpl.n	80011b0 <VectorD8+0xc0>
 800118a:	2320      	movs	r3, #32
 800118c:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8001190:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8001192:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8001194:	4823      	ldr	r0, [pc, #140]	; (8001224 <VectorD8+0x134>)
 8001196:	429a      	cmp	r2, r3
 8001198:	d02f      	beq.n	80011fa <VectorD8+0x10a>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800119a:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 800119e:	ea08 0303 	and.w	r3, r8, r3
    u->SR = ~USART_SR_TC;
 80011a2:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80011a6:	60eb      	str	r3, [r5, #12]
 80011a8:	2300      	movs	r3, #0
    u->SR = ~USART_SR_TC;
 80011aa:	602a      	str	r2, [r5, #0]
 80011ac:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
}
 80011b0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 80011b4:	f002 bc24 	b.w	8003a00 <_port_irq_epilogue>
 80011b8:	481b      	ldr	r0, [pc, #108]	; (8001228 <VectorD8+0x138>)
 80011ba:	2104      	movs	r1, #4
 80011bc:	f002 fe70 	bl	8003ea0 <chEvtBroadcastFlagsI>
 80011c0:	e7ca      	b.n	8001158 <VectorD8+0x68>
 80011c2:	2320      	movs	r3, #32
 80011c4:	f383 8811 	msr	BASEPRI, r3
 80011c8:	f44f 7100 	mov.w	r1, #512	; 0x200
 80011cc:	1d38      	adds	r0, r7, #4
 80011ce:	f002 fe67 	bl	8003ea0 <chEvtBroadcastFlagsI>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 80011d2:	f46f 7380 	mvn.w	r3, #256	; 0x100
 80011d6:	602b      	str	r3, [r5, #0]
 80011d8:	2300      	movs	r3, #0
 80011da:	f383 8811 	msr	BASEPRI, r3
 80011de:	e791      	b.n	8001104 <VectorD8+0x14>
 80011e0:	2320      	movs	r3, #32
 80011e2:	f383 8811 	msr	BASEPRI, r3

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
 80011e6:	4812      	ldr	r0, [pc, #72]	; (8001230 <VectorD8+0x140>)
 80011e8:	f7ff ff5a 	bl	80010a0 <chOQGetI.4191>
    if (b < Q_OK) {
 80011ec:	2800      	cmp	r0, #0
 80011ee:	db0c      	blt.n	800120a <VectorD8+0x11a>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 80011f0:	6068      	str	r0, [r5, #4]
 80011f2:	2300      	movs	r3, #0
 80011f4:	f383 8811 	msr	BASEPRI, r3
 80011f8:	e7c5      	b.n	8001186 <VectorD8+0x96>
 80011fa:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80011fc:	2b00      	cmp	r3, #0
 80011fe:	d0cc      	beq.n	800119a <VectorD8+0xaa>
 8001200:	3004      	adds	r0, #4
 8001202:	2110      	movs	r1, #16
 8001204:	f002 fe4c 	bl	8003ea0 <chEvtBroadcastFlagsI>
 8001208:	e7c7      	b.n	800119a <VectorD8+0xaa>
 800120a:	4807      	ldr	r0, [pc, #28]	; (8001228 <VectorD8+0x138>)
 800120c:	2108      	movs	r1, #8
 800120e:	f002 fe47 	bl	8003ea0 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8001212:	f64f 733f 	movw	r3, #65343	; 0xff3f
 8001216:	ea08 0303 	and.w	r3, r8, r3
 800121a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800121e:	60eb      	str	r3, [r5, #12]
 8001220:	e7e7      	b.n	80011f2 <VectorD8+0x102>
 8001222:	bf00      	nop
 8001224:	20001178 	.word	0x20001178
 8001228:	2000117c 	.word	0x2000117c
 800122c:	20001184 	.word	0x20001184
 8001230:	200011a8 	.word	0x200011a8
 8001234:	f3af 8000 	nop.w
 8001238:	f3af 8000 	nop.w
 800123c:	f3af 8000 	nop.w

08001240 <queues2_execute.11035>:

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
}

static void queues2_execute(void) {
 8001240:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001244:	2320      	movs	r3, #32
 8001246:	b082      	sub	sp, #8
 8001248:	f383 8811 	msr	BASEPRI, r3
 800124c:	4e93      	ldr	r6, [pc, #588]	; (800149c <queues2_execute.11035+0x25c>)
 800124e:	6972      	ldr	r2, [r6, #20]
 8001250:	69b3      	ldr	r3, [r6, #24]
 8001252:	429a      	cmp	r2, r3
 8001254:	d061      	beq.n	800131a <queues2_execute.11035+0xda>
 8001256:	2100      	movs	r1, #0
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
 8001258:	2001      	movs	r0, #1
 800125a:	f7ff fcb9 	bl	8000bd0 <_test_assert>
 800125e:	2800      	cmp	r0, #0
 8001260:	d13a      	bne.n	80012d8 <queues2_execute.11035+0x98>
 8001262:	f380 8811 	msr	BASEPRI, r0
 8001266:	2441      	movs	r4, #65	; 0x41
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 8001268:	4d8c      	ldr	r5, [pc, #560]	; (800149c <queues2_execute.11035+0x25c>)
 800126a:	4621      	mov	r1, r4
 800126c:	3401      	adds	r4, #1
 800126e:	4628      	mov	r0, r5
 8001270:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001274:	b2e4      	uxtb	r4, r4
 8001276:	f003 fdcb 	bl	8004e10 <chOQPutTimeout>

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800127a:	2c45      	cmp	r4, #69	; 0x45
 800127c:	d1f4      	bne.n	8001268 <queues2_execute.11035+0x28>
 800127e:	f04f 0a20 	mov.w	sl, #32
 8001282:	f38a 8811 	msr	BASEPRI, sl
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8001286:	68a9      	ldr	r1, [r5, #8]
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
 8001288:	f1d1 0101 	rsbs	r1, r1, #1
 800128c:	f04f 0002 	mov.w	r0, #2
 8001290:	bf38      	it	cc
 8001292:	2100      	movcc	r1, #0
 8001294:	f7ff fc9c 	bl	8000bd0 <_test_assert>
 8001298:	4607      	mov	r7, r0
 800129a:	b9e8      	cbnz	r0, 80012d8 <queues2_execute.11035+0x98>
 800129c:	f380 8811 	msr	BASEPRI, r0
 80012a0:	2404      	movs	r4, #4
 80012a2:	4681      	mov	r9, r0
 80012a4:	f04f 0820 	mov.w	r8, #32
 80012a8:	f38a 8811 	msr	BASEPRI, sl
  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    char c;

    chSysLock();
    c = chOQGetI(&oq);
 80012ac:	4d7b      	ldr	r5, [pc, #492]	; (800149c <queues2_execute.11035+0x25c>)
 80012ae:	4628      	mov	r0, r5
 80012b0:	f7ff fef6 	bl	80010a0 <chOQGetI.4191>
 80012b4:	f389 8811 	msr	BASEPRI, r9
    chSysUnlock();
    test_emit_token(c);
 80012b8:	b2c0      	uxtb	r0, r0
 80012ba:	f002 fa49 	bl	8003750 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 80012be:	3c01      	subs	r4, #1
 80012c0:	d1f0      	bne.n	80012a4 <queues2_execute.11035+0x64>
 80012c2:	f388 8811 	msr	BASEPRI, r8
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80012c6:	696a      	ldr	r2, [r5, #20]
 80012c8:	69ab      	ldr	r3, [r5, #24]
 80012ca:	429a      	cmp	r2, r3
 80012cc:	d02a      	beq.n	8001324 <queues2_execute.11035+0xe4>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
 80012ce:	4639      	mov	r1, r7
 80012d0:	2003      	movs	r0, #3
 80012d2:	f7ff fc7d 	bl	8000bd0 <_test_assert>
 80012d6:	b128      	cbz	r0, 80012e4 <queues2_execute.11035+0xa4>
 80012d8:	2300      	movs	r3, #0
 80012da:	f383 8811 	msr	BASEPRI, r3
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
}
 80012de:	b002      	add	sp, #8
 80012e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80012e4:	f380 8811 	msr	BASEPRI, r0
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
  test_assert_sequence(4, "ABCD");
 80012e8:	2004      	movs	r0, #4
 80012ea:	496d      	ldr	r1, [pc, #436]	; (80014a0 <queues2_execute.11035+0x260>)
 80012ec:	f7ff fc48 	bl	8000b80 <_test_assert_sequence>
 80012f0:	4604      	mov	r4, r0
 80012f2:	2800      	cmp	r0, #0
 80012f4:	d1f3      	bne.n	80012de <queues2_execute.11035+0x9e>
 80012f6:	2720      	movs	r7, #32
 80012f8:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
 80012fc:	4d67      	ldr	r5, [pc, #412]	; (800149c <queues2_execute.11035+0x25c>)
 80012fe:	4628      	mov	r0, r5
 8001300:	f7ff fece 	bl	80010a0 <chOQGetI.4191>
 8001304:	3003      	adds	r0, #3
 8001306:	bf14      	ite	ne
 8001308:	2100      	movne	r1, #0
 800130a:	2101      	moveq	r1, #1
 800130c:	2005      	movs	r0, #5
 800130e:	f7ff fc5f 	bl	8000bd0 <_test_assert>
 8001312:	b160      	cbz	r0, 800132e <queues2_execute.11035+0xee>
 8001314:	f384 8811 	msr	BASEPRI, r4
 8001318:	e7e1      	b.n	80012de <queues2_execute.11035+0x9e>
 800131a:	68b1      	ldr	r1, [r6, #8]
 800131c:	3100      	adds	r1, #0
 800131e:	bf18      	it	ne
 8001320:	2101      	movne	r1, #1
 8001322:	e799      	b.n	8001258 <queues2_execute.11035+0x18>
 8001324:	68af      	ldr	r7, [r5, #8]
 8001326:	3700      	adds	r7, #0
 8001328:	bf18      	it	ne
 800132a:	2701      	movne	r7, #1
 800132c:	e7cf      	b.n	80012ce <queues2_execute.11035+0x8e>
 800132e:	f380 8811 	msr	BASEPRI, r0

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 8001332:	495c      	ldr	r1, [pc, #368]	; (80014a4 <queues2_execute.11035+0x264>)
 8001334:	4603      	mov	r3, r0
 8001336:	2208      	movs	r2, #8
 8001338:	4628      	mov	r0, r5
 800133a:	f003 fdb1 	bl	8004ea0 <chOQWriteTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800133e:	f1b0 0c04 	subs.w	ip, r0, #4
 8001342:	f1dc 0100 	rsbs	r1, ip, #0
 8001346:	eb51 010c 	adcs.w	r1, r1, ip
 800134a:	2006      	movs	r0, #6
 800134c:	f7ff fc40 	bl	8000bd0 <_test_assert>
 8001350:	4604      	mov	r4, r0
 8001352:	2800      	cmp	r0, #0
 8001354:	d1c3      	bne.n	80012de <queues2_execute.11035+0x9e>
 8001356:	f387 8811 	msr	BASEPRI, r7
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 800135a:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
 800135c:	f1d1 0101 	rsbs	r1, r1, #1
 8001360:	f04f 0007 	mov.w	r0, #7
 8001364:	bf38      	it	cc
 8001366:	2100      	movcc	r1, #0
 8001368:	f7ff fc32 	bl	8000bd0 <_test_assert>
 800136c:	4680      	mov	r8, r0
 800136e:	2800      	cmp	r0, #0
 8001370:	d1d0      	bne.n	8001314 <queues2_execute.11035+0xd4>
 8001372:	f380 8811 	msr	BASEPRI, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001376:	4b4c      	ldr	r3, [pc, #304]	; (80014a8 <queues2_execute.11035+0x268>)
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8001378:	484c      	ldr	r0, [pc, #304]	; (80014ac <queues2_execute.11035+0x26c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 800137a:	699a      	ldr	r2, [r3, #24]
 800137c:	4b4c      	ldr	r3, [pc, #304]	; (80014b0 <queues2_execute.11035+0x270>)
 800137e:	6892      	ldr	r2, [r2, #8]
 8001380:	f8cd 8000 	str.w	r8, [sp]
 8001384:	3201      	adds	r2, #1
 8001386:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800138a:	f002 fc99 	bl	8003cc0 <chThdCreateStatic>
 800138e:	4b49      	ldr	r3, [pc, #292]	; (80014b4 <queues2_execute.11035+0x274>)
 8001390:	6018      	str	r0, [r3, #0]
 8001392:	f387 8811 	msr	BASEPRI, r7
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 8001396:	692a      	ldr	r2, [r5, #16]
 8001398:	68eb      	ldr	r3, [r5, #12]
 800139a:	68a9      	ldr	r1, [r5, #8]
 800139c:	1ad3      	subs	r3, r2, r3
 800139e:	1a59      	subs	r1, r3, r1
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
 80013a0:	f1b1 0e04 	subs.w	lr, r1, #4
 80013a4:	f1de 0100 	rsbs	r1, lr, #0
 80013a8:	eb51 010e 	adcs.w	r1, r1, lr
 80013ac:	2008      	movs	r0, #8
 80013ae:	f7ff fc0f 	bl	8000bd0 <_test_assert>
 80013b2:	b110      	cbz	r0, 80013ba <queues2_execute.11035+0x17a>
 80013b4:	f388 8811 	msr	BASEPRI, r8
 80013b8:	e791      	b.n	80012de <queues2_execute.11035+0x9e>
 80013ba:	f380 8811 	msr	BASEPRI, r0
  test_wait_threads();
 80013be:	f000 fd27 	bl	8001e10 <test_wait_threads>
 80013c2:	f387 8811 	msr	BASEPRI, r7
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 80013c6:	68ea      	ldr	r2, [r5, #12]
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 80013c8:	6929      	ldr	r1, [r5, #16]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80013ca:	682b      	ldr	r3, [r5, #0]
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 80013cc:	61aa      	str	r2, [r5, #24]
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 80013ce:	1a89      	subs	r1, r1, r2
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 80013d0:	42ab      	cmp	r3, r5
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
 80013d2:	616a      	str	r2, [r5, #20]
  oqp->q_counter = chQSizeX(oqp);
 80013d4:	60a9      	str	r1, [r5, #8]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80013d6:	bf18      	it	ne
 80013d8:	f06f 0401 	mvnne.w	r4, #1
 80013dc:	d009      	beq.n	80013f2 <queues2_execute.11035+0x1b2>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80013de:	681a      	ldr	r2, [r3, #0]
 80013e0:	6032      	str	r2, [r6, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80013e2:	6056      	str	r6, [r2, #4]
  (void) chSchReadyI(tp);
 80013e4:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80013e6:	621c      	str	r4, [r3, #32]
  (void) chSchReadyI(tp);
 80013e8:	f002 fd0a 	bl	8003e00 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80013ec:	6833      	ldr	r3, [r6, #0]
 80013ee:	42b3      	cmp	r3, r6
 80013f0:	d1f5      	bne.n	80013de <queues2_execute.11035+0x19e>
 80013f2:	2700      	movs	r7, #0
 80013f4:	f387 8811 	msr	BASEPRI, r7
 80013f8:	2520      	movs	r5, #32
 80013fa:	f385 8811 	msr	BASEPRI, r5
 80013fe:	6931      	ldr	r1, [r6, #16]
 8001400:	68f2      	ldr	r2, [r6, #12]
 8001402:	68b3      	ldr	r3, [r6, #8]
 8001404:	4c25      	ldr	r4, [pc, #148]	; (800149c <queues2_execute.11035+0x25c>)
 8001406:	1a89      	subs	r1, r1, r2

  /* Testing reset */
  chSysLock();
  chOQResetI(&oq);
  chSysUnlock();
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
 8001408:	1ace      	subs	r6, r1, r3
 800140a:	4271      	negs	r1, r6
 800140c:	4171      	adcs	r1, r6
 800140e:	2009      	movs	r0, #9
 8001410:	f7ff fbde 	bl	8000bd0 <_test_assert>
 8001414:	4603      	mov	r3, r0
 8001416:	b110      	cbz	r0, 800141e <queues2_execute.11035+0x1de>
 8001418:	f387 8811 	msr	BASEPRI, r7
 800141c:	e75f      	b.n	80012de <queues2_execute.11035+0x9e>
 800141e:	f380 8811 	msr	BASEPRI, r0

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8001422:	4920      	ldr	r1, [pc, #128]	; (80014a4 <queues2_execute.11035+0x264>)
 8001424:	2202      	movs	r2, #2
 8001426:	4620      	mov	r0, r4
 8001428:	f003 fd3a 	bl	8004ea0 <chOQWriteTimeout>
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800142c:	3802      	subs	r0, #2
 800142e:	4241      	negs	r1, r0
 8001430:	4141      	adcs	r1, r0
 8001432:	200a      	movs	r0, #10
 8001434:	f7ff fbcc 	bl	8000bd0 <_test_assert>
 8001438:	4603      	mov	r3, r0
 800143a:	2800      	cmp	r0, #0
 800143c:	f47f af4f 	bne.w	80012de <queues2_execute.11035+0x9e>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8001440:	4918      	ldr	r1, [pc, #96]	; (80014a4 <queues2_execute.11035+0x264>)
 8001442:	2202      	movs	r2, #2
 8001444:	4620      	mov	r0, r4
 8001446:	f003 fd2b 	bl	8004ea0 <chOQWriteTimeout>
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800144a:	1e82      	subs	r2, r0, #2
 800144c:	4251      	negs	r1, r2
 800144e:	4151      	adcs	r1, r2
 8001450:	200b      	movs	r0, #11
 8001452:	f7ff fbbd 	bl	8000bd0 <_test_assert>
 8001456:	4606      	mov	r6, r0
 8001458:	2800      	cmp	r0, #0
 800145a:	f47f af40 	bne.w	80012de <queues2_execute.11035+0x9e>
 800145e:	f385 8811 	msr	BASEPRI, r5
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8001462:	68a1      	ldr	r1, [r4, #8]
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
 8001464:	f1d1 0101 	rsbs	r1, r1, #1
 8001468:	bf38      	it	cc
 800146a:	2100      	movcc	r1, #0
 800146c:	200c      	movs	r0, #12
 800146e:	f7ff fbaf 	bl	8000bd0 <_test_assert>
 8001472:	4601      	mov	r1, r0
 8001474:	b110      	cbz	r0, 800147c <queues2_execute.11035+0x23c>
 8001476:	f386 8811 	msr	BASEPRI, r6
 800147a:	e730      	b.n	80012de <queues2_execute.11035+0x9e>
 800147c:	f380 8811 	msr	BASEPRI, r0

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 8001480:	220a      	movs	r2, #10
 8001482:	4620      	mov	r0, r4
 8001484:	f003 fcc4 	bl	8004e10 <chOQPutTimeout>
 8001488:	f1b0 33ff 	subs.w	r3, r0, #4294967295	; 0xffffffff
 800148c:	4259      	negs	r1, r3
 800148e:	4159      	adcs	r1, r3
 8001490:	200d      	movs	r0, #13
}
 8001492:	b002      	add	sp, #8
 8001494:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 8001498:	f7ff bb9a 	b.w	8000bd0 <_test_assert>
 800149c:	20000890 	.word	0x20000890
 80014a0:	08006810 	.word	0x08006810
 80014a4:	20000a70 	.word	0x20000a70
 80014a8:	20001208 	.word	0x20001208
 80014ac:	20000928 	.word	0x20000928
 80014b0:	08004e71 	.word	0x08004e71
 80014b4:	20001358 	.word	0x20001358
 80014b8:	f3af 8000 	nop.w
 80014bc:	f3af 8000 	nop.w

080014c0 <_usb_ep0setup>:
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 80014c0:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 80014c4:	b570      	push	{r4, r5, r6, lr}
 80014c6:	68cb      	ldr	r3, [r1, #12]
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 80014c8:	2200      	movs	r2, #0
 80014ca:	6a1b      	ldr	r3, [r3, #32]
 80014cc:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
 80014d0:	6819      	ldr	r1, [r3, #0]
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 80014d2:	6842      	ldr	r2, [r0, #4]
 80014d4:	685b      	ldr	r3, [r3, #4]
 80014d6:	6483      	str	r3, [r0, #72]	; 0x48
 80014d8:	6441      	str	r1, [r0, #68]	; 0x44
 80014da:	6893      	ldr	r3, [r2, #8]
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 80014dc:	4604      	mov	r4, r0
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 80014de:	b353      	cbz	r3, 8001536 <_usb_ep0setup+0x76>
      !(usbp->config->requests_hook_cb(usbp))) {
 80014e0:	4798      	blx	r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 80014e2:	b340      	cbz	r0, 8001536 <_usb_ep0setup+0x76>
 80014e4:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 80014e6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 80014ea:	f894 104b 	ldrb.w	r1, [r4, #75]	; 0x4b
 80014ee:	f894 204a 	ldrb.w	r2, [r4, #74]	; 0x4a
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 80014f2:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 80014f6:	42aa      	cmp	r2, r5
    usbp->ep0n = max;
 80014f8:	bf3c      	itt	cc
 80014fa:	63e2      	strcc	r2, [r4, #60]	; 0x3c
 80014fc:	4615      	movcc	r5, r2
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80014fe:	f013 0f80 	tst.w	r3, #128	; 0x80
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8001502:	68e3      	ldr	r3, [r4, #12]
  max = (size_t)get_hword(&usbp->setup[6]);
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001504:	f040 8091 	bne.w	800162a <_usb_ep0setup+0x16a>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8001508:	2d00      	cmp	r5, #0
 800150a:	d177      	bne.n	80015fc <_usb_ep0setup+0x13c>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800150c:	695b      	ldr	r3, [r3, #20]
      osalSysUnlockFromISR();
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 800150e:	2205      	movs	r2, #5
 8001510:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 8001514:	4620      	mov	r0, r4
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8001516:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 8001518:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 800151a:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 800151c:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 800151e:	4629      	mov	r1, r5
 8001520:	f002 f99e 	bl	8003860 <usb_lld_prepare_transmit>
 8001524:	2320      	movs	r3, #32
 8001526:	f383 8811 	msr	BASEPRI, r3
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      usbPrepareTransmit(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      (void) usbStartTransmitI(usbp, 0);
 800152a:	4620      	mov	r0, r4
 800152c:	f7ff fa88 	bl	8000a40 <usbStartTransmitI.constprop.9>
 8001530:	f385 8811 	msr	BASEPRI, r5
 8001534:	bd70      	pop	{r4, r5, r6, pc}
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8001536:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800153a:	f013 0660 	ands.w	r6, r3, #96	; 0x60
 800153e:	d016      	beq.n	800156e <_usb_ep0setup+0xae>
 8001540:	6d22      	ldr	r2, [r4, #80]	; 0x50
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8001542:	f8d2 1900 	ldr.w	r1, [r2, #2304]	; 0x900
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
      usb_lld_stall_out(usbp, 0);
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8001546:	6863      	ldr	r3, [r4, #4]
 8001548:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 800154c:	f8c2 1900 	str.w	r1, [r2, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8001550:	f8d2 1b00 	ldr.w	r1, [r2, #2816]	; 0xb00
 8001554:	681b      	ldr	r3, [r3, #0]
 8001556:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 800155a:	f8c2 1b00 	str.w	r1, [r2, #2816]	; 0xb00
 800155e:	b113      	cbz	r3, 8001566 <_usb_ep0setup+0xa6>
 8001560:	4620      	mov	r0, r4
 8001562:	2105      	movs	r1, #5
 8001564:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 8001566:	2306      	movs	r3, #6
 8001568:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800156c:	bd70      	pop	{r4, r5, r6, pc}
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 800156e:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001572:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 8001576:	ea42 2505 	orr.w	r5, r2, r5, lsl #8
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800157a:	f5b5 7f40 	cmp.w	r5, #768	; 0x300
 800157e:	f000 8116 	beq.w	80017ae <_usb_ep0setup+0x2ee>
 8001582:	d917      	bls.n	80015b4 <_usb_ep0setup+0xf4>
 8001584:	f5b5 6fc0 	cmp.w	r5, #1536	; 0x600
 8001588:	f000 80ee 	beq.w	8001768 <_usb_ep0setup+0x2a8>
 800158c:	d97a      	bls.n	8001684 <_usb_ep0setup+0x1c4>
 800158e:	f5b5 6f10 	cmp.w	r5, #2304	; 0x900
 8001592:	f000 808a 	beq.w	80016aa <_usb_ep0setup+0x1ea>
 8001596:	f640 4202 	movw	r2, #3074	; 0xc02
 800159a:	4295      	cmp	r5, r2
 800159c:	f000 8100 	beq.w	80017a0 <_usb_ep0setup+0x2e0>
 80015a0:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 80015a4:	d1cc      	bne.n	8001540 <_usb_ep0setup+0x80>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 80015a6:	f104 024f 	add.w	r2, r4, #79	; 0x4f
 80015aa:	2501      	movs	r5, #1
 80015ac:	6426      	str	r6, [r4, #64]	; 0x40
 80015ae:	63a2      	str	r2, [r4, #56]	; 0x38
 80015b0:	63e5      	str	r5, [r4, #60]	; 0x3c
 80015b2:	e79a      	b.n	80014ea <_usb_ep0setup+0x2a>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80015b4:	2d02      	cmp	r5, #2
 80015b6:	f000 80be 	beq.w	8001736 <_usb_ep0setup+0x276>
 80015ba:	f240 80b2 	bls.w	8001722 <_usb_ep0setup+0x262>
 80015be:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 80015c2:	f000 809e 	beq.w	8001702 <_usb_ep0setup+0x242>
 80015c6:	f5b5 7f81 	cmp.w	r5, #258	; 0x102
 80015ca:	d1b9      	bne.n	8001540 <_usb_ep0setup+0x80>
        return false;
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80015cc:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 80015d0:	2a00      	cmp	r2, #0
 80015d2:	d1b5      	bne.n	8001540 <_usb_ep0setup+0x80>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80015d4:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 80015d8:	f012 010f 	ands.w	r1, r2, #15
 80015dc:	d060      	beq.n	80016a0 <_usb_ep0setup+0x1e0>
 80015de:	6d23      	ldr	r3, [r4, #80]	; 0x50
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80015e0:	0612      	lsls	r2, r2, #24
 80015e2:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 80015e6:	f100 8112 	bmi.w	800180e <_usb_ep0setup+0x34e>
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 80015ea:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 80015ee:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80015f2:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
 80015f6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80015fa:	e051      	b.n	80016a0 <_usb_ep0setup+0x1e0>
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80015fc:	699b      	ldr	r3, [r3, #24]
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
      usbPrepareReceive(usbp, 0, usbp->ep0next, usbp->ep0n);
 80015fe:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 8001600:	2600      	movs	r6, #0
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 8001602:	2104      	movs	r1, #4
 8001604:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 8001608:	4620      	mov	r0, r4
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
 800160a:	60da      	str	r2, [r3, #12]
  osp->rxsize             = n;
 800160c:	605d      	str	r5, [r3, #4]
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 800160e:	701e      	strb	r6, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 8001610:	609e      	str	r6, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 8001612:	4631      	mov	r1, r6
 8001614:	f002 f94c 	bl	80038b0 <usb_lld_prepare_receive>
 8001618:	2320      	movs	r3, #32
 800161a:	f383 8811 	msr	BASEPRI, r3
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
      usbPrepareReceive(usbp, 0, usbp->ep0next, usbp->ep0n);
      osalSysLockFromISR();
      (void) usbStartReceiveI(usbp, 0);
 800161e:	4620      	mov	r0, r4
 8001620:	f7ff f9f6 	bl	8000a10 <usbStartReceiveI.constprop.11>
 8001624:	f386 8811 	msr	BASEPRI, r6
 8001628:	bd70      	pop	{r4, r5, r6, pc}
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 800162a:	b1b5      	cbz	r5, 800165a <_usb_ep0setup+0x19a>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800162c:	695b      	ldr	r3, [r3, #20]
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
      usbPrepareTransmit(usbp, 0, usbp->ep0next, usbp->ep0n);
 800162e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8001630:	2600      	movs	r6, #0
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 8001632:	2101      	movs	r1, #1
 8001634:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 8001638:	4620      	mov	r0, r4
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
 800163a:	60da      	str	r2, [r3, #12]
  isp->txsize             = n;
 800163c:	605d      	str	r5, [r3, #4]
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 800163e:	701e      	strb	r6, [r3, #0]
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;
 8001640:	609e      	str	r6, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 8001642:	4631      	mov	r1, r6
 8001644:	f002 f90c 	bl	8003860 <usb_lld_prepare_transmit>
 8001648:	2320      	movs	r3, #32
 800164a:	f383 8811 	msr	BASEPRI, r3
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
      usbPrepareTransmit(usbp, 0, usbp->ep0next, usbp->ep0n);
      osalSysLockFromISR();
      (void) usbStartTransmitI(usbp, 0);
 800164e:	4620      	mov	r0, r4
 8001650:	f7ff f9f6 	bl	8000a40 <usbStartTransmitI.constprop.9>
 8001654:	f386 8811 	msr	BASEPRI, r6
 8001658:	bd70      	pop	{r4, r5, r6, pc}
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800165a:	699b      	ldr	r3, [r3, #24]
      osalSysUnlockFromISR();
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 800165c:	2203      	movs	r2, #3
 800165e:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 8001662:	4620      	mov	r0, r4
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 8001664:	701d      	strb	r5, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
 8001666:	60dd      	str	r5, [r3, #12]
  osp->rxsize             = n;
 8001668:	605d      	str	r5, [r3, #4]
  osp->rxcnt              = 0;
 800166a:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 800166c:	4629      	mov	r1, r5
 800166e:	f002 f91f 	bl	80038b0 <usb_lld_prepare_receive>
 8001672:	2320      	movs	r3, #32
 8001674:	f383 8811 	msr	BASEPRI, r3
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      usbPrepareReceive(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      (void) usbStartReceiveI(usbp, 0);
 8001678:	4620      	mov	r0, r4
 800167a:	f7ff f9c9 	bl	8000a10 <usbStartReceiveI.constprop.11>
 800167e:	f385 8811 	msr	BASEPRI, r5
 8001682:	bd70      	pop	{r4, r5, r6, pc}
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001684:	f240 3202 	movw	r2, #770	; 0x302
 8001688:	4295      	cmp	r5, r2
 800168a:	d021      	beq.n	80016d0 <_usb_ep0setup+0x210>
 800168c:	f5b5 6fa0 	cmp.w	r5, #1280	; 0x500
 8001690:	f47f af56 	bne.w	8001540 <_usb_ep0setup+0x80>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8001694:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
 8001698:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 800169c:	f000 809f 	beq.w	80017de <_usb_ep0setup+0x31e>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80016a0:	2500      	movs	r5, #0
 80016a2:	63a5      	str	r5, [r4, #56]	; 0x38
 80016a4:	63e5      	str	r5, [r4, #60]	; 0x3c
 80016a6:	6425      	str	r5, [r4, #64]	; 0x40
 80016a8:	e71f      	b.n	80014ea <_usb_ep0setup+0x2a>
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host.*/
    usbp->configuration = usbp->setup[2];
 80016aa:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 80016ae:	f884 204f 	strb.w	r2, [r4, #79]	; 0x4f
    if (usbp->configuration == 0U) {
 80016b2:	2a00      	cmp	r2, #0
 80016b4:	f040 808b 	bne.w	80017ce <_usb_ep0setup+0x30e>
      usbp->state = USB_SELECTED;
 80016b8:	2203      	movs	r2, #3
 80016ba:	7022      	strb	r2, [r4, #0]
    }
    else {
      usbp->state = USB_ACTIVE;
    }
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 80016bc:	6862      	ldr	r2, [r4, #4]
 80016be:	6812      	ldr	r2, [r2, #0]
 80016c0:	2a00      	cmp	r2, #0
 80016c2:	d0ed      	beq.n	80016a0 <_usb_ep0setup+0x1e0>
 80016c4:	4620      	mov	r0, r4
 80016c6:	2102      	movs	r1, #2
 80016c8:	4790      	blx	r2
 80016ca:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80016ce:	e7e7      	b.n	80016a0 <_usb_ep0setup+0x1e0>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80016d0:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 80016d4:	2a00      	cmp	r2, #0
 80016d6:	f47f af33 	bne.w	8001540 <_usb_ep0setup+0x80>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80016da:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 80016de:	f012 010f 	ands.w	r1, r2, #15
 80016e2:	d0dd      	beq.n	80016a0 <_usb_ep0setup+0x1e0>
 80016e4:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80016e6:	eb03 1141 	add.w	r1, r3, r1, lsl #5
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80016ea:	0613      	lsls	r3, r2, #24
 80016ec:	f100 8098 	bmi.w	8001820 <_usb_ep0setup+0x360>
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 80016f0:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 80016f4:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80016f8:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
 80016fc:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8001700:	e7ce      	b.n	80016a0 <_usb_ep0setup+0x1e0>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8001702:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8001706:	2a01      	cmp	r2, #1
 8001708:	f47f af1a 	bne.w	8001540 <_usb_ep0setup+0x80>
      usbp->status &= ~2U;
 800170c:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8001710:	63a6      	str	r6, [r4, #56]	; 0x38
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 8001712:	f022 0202 	bic.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8001716:	63e6      	str	r6, [r4, #60]	; 0x3c
 8001718:	6426      	str	r6, [r4, #64]	; 0x40
 800171a:	4635      	mov	r5, r6
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 800171c:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
 8001720:	e6e3      	b.n	80014ea <_usb_ep0setup+0x2a>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001722:	2d00      	cmp	r5, #0
 8001724:	d139      	bne.n	800179a <_usb_ep0setup+0x2da>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8001726:	2202      	movs	r2, #2
 8001728:	f104 014c 	add.w	r1, r4, #76	; 0x4c
 800172c:	6425      	str	r5, [r4, #64]	; 0x40
 800172e:	63a1      	str	r1, [r4, #56]	; 0x38
 8001730:	63e2      	str	r2, [r4, #60]	; 0x3c
 8001732:	4615      	mov	r5, r2
 8001734:	e6d9      	b.n	80014ea <_usb_ep0setup+0x2a>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8001736:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 800173a:	0611      	lsls	r1, r2, #24
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 800173c:	bf53      	iteet	pl
 800173e:	f002 010f 	andpl.w	r1, r2, #15
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 8001742:	f002 020f 	andmi.w	r2, r2, #15
 8001746:	f102 0148 	addmi.w	r1, r2, #72	; 0x48
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 800174a:	3158      	addpl	r1, #88	; 0x58
 800174c:	0149      	lsls	r1, r1, #5
 800174e:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8001750:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 8001752:	0408      	lsls	r0, r1, #16
 8001754:	f57f aef5 	bpl.w	8001542 <_usb_ep0setup+0x82>
    return EP_STATUS_DISABLED;
  if (ctl & DOEPCTL_STALL)
 8001758:	f411 1100 	ands.w	r1, r1, #2097152	; 0x200000
 800175c:	d13a      	bne.n	80017d4 <_usb_ep0setup+0x314>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
        /*lint -restore*/
        return true;
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 800175e:	4a35      	ldr	r2, [pc, #212]	; (8001834 <_usb_ep0setup+0x374>)
 8001760:	63e5      	str	r5, [r4, #60]	; 0x3c
 8001762:	6421      	str	r1, [r4, #64]	; 0x40
 8001764:	63a2      	str	r2, [r4, #56]	; 0x38
 8001766:	e6c0      	b.n	80014ea <_usb_ep0setup+0x2a>
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8001768:	6862      	ldr	r2, [r4, #4]

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 800176a:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 800176e:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8001772:	6855      	ldr	r5, [r2, #4]
 8001774:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
 8001778:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 800177c:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8001780:	4620      	mov	r0, r4
 8001782:	47a8      	blx	r5
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 8001784:	2800      	cmp	r0, #0
 8001786:	f43f aedb 	beq.w	8001540 <_usb_ep0setup+0x80>
      return false;
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 800178a:	6843      	ldr	r3, [r0, #4]
 800178c:	6805      	ldr	r5, [r0, #0]
 800178e:	63e5      	str	r5, [r4, #60]	; 0x3c
 8001790:	63a3      	str	r3, [r4, #56]	; 0x38
 8001792:	6426      	str	r6, [r4, #64]	; 0x40
 8001794:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8001798:	e6a7      	b.n	80014ea <_usb_ep0setup+0x2a>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800179a:	2d01      	cmp	r5, #1
 800179c:	f47f aed0 	bne.w	8001540 <_usb_ep0setup+0x80>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 80017a0:	4a25      	ldr	r2, [pc, #148]	; (8001838 <_usb_ep0setup+0x378>)
 80017a2:	63a2      	str	r2, [r4, #56]	; 0x38
 80017a4:	2502      	movs	r5, #2
 80017a6:	2200      	movs	r2, #0
 80017a8:	63e5      	str	r5, [r4, #60]	; 0x3c
 80017aa:	6422      	str	r2, [r4, #64]	; 0x40
 80017ac:	e69d      	b.n	80014ea <_usb_ep0setup+0x2a>
    }
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80017ae:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 80017b2:	2a01      	cmp	r2, #1
 80017b4:	f47f aec4 	bne.w	8001540 <_usb_ep0setup+0x80>
      usbp->status |= 2U;
 80017b8:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80017bc:	63a6      	str	r6, [r4, #56]	; 0x38
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 80017be:	f042 0202 	orr.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80017c2:	63e6      	str	r6, [r4, #60]	; 0x3c
 80017c4:	6426      	str	r6, [r4, #64]	; 0x40
 80017c6:	4635      	mov	r5, r6
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 80017c8:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
 80017cc:	e68d      	b.n	80014ea <_usb_ep0setup+0x2a>
    usbp->configuration = usbp->setup[2];
    if (usbp->configuration == 0U) {
      usbp->state = USB_SELECTED;
    }
    else {
      usbp->state = USB_ACTIVE;
 80017ce:	2204      	movs	r2, #4
 80017d0:	7022      	strb	r2, [r4, #0]
 80017d2:	e773      	b.n	80016bc <_usb_ep0setup+0x1fc>
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 80017d4:	4a19      	ldr	r2, [pc, #100]	; (800183c <_usb_ep0setup+0x37c>)
 80017d6:	63e5      	str	r5, [r4, #60]	; 0x3c
 80017d8:	6426      	str	r6, [r4, #64]	; 0x40
 80017da:	63a2      	str	r2, [r4, #56]	; 0x38
 80017dc:	e685      	b.n	80014ea <_usb_ep0setup+0x2a>
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {

  usbp->address = usbp->setup[2];
 80017de:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 80017e2:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80017e4:	f884 204e 	strb.w	r2, [r4, #78]	; 0x4e

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 80017e8:	f8d3 0800 	ldr.w	r0, [r3, #2048]	; 0x800
  usb_lld_set_address(usbp);
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 80017ec:	6861      	ldr	r1, [r4, #4]
 80017ee:	f420 60fe 	bic.w	r0, r0, #2032	; 0x7f0
 80017f2:	680d      	ldr	r5, [r1, #0]
 80017f4:	ea40 1202 	orr.w	r2, r0, r2, lsl #4
 80017f8:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
 80017fc:	b115      	cbz	r5, 8001804 <_usb_ep0setup+0x344>
 80017fe:	4620      	mov	r0, r4
 8001800:	2101      	movs	r1, #1
 8001802:	47a8      	blx	r5
  usbp->state = USB_SELECTED;
 8001804:	2203      	movs	r2, #3
 8001806:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800180a:	7022      	strb	r2, [r4, #0]
 800180c:	e748      	b.n	80016a0 <_usb_ep0setup+0x1e0>
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 800180e:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8001812:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8001816:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
 800181a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800181e:	e73f      	b.n	80016a0 <_usb_ep0setup+0x1e0>
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8001820:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8001824:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001828:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
 800182c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8001830:	e736      	b.n	80016a0 <_usb_ep0setup+0x1e0>
 8001832:	bf00      	nop
 8001834:	080067e0 	.word	0x080067e0
 8001838:	08006860 	.word	0x08006860
 800183c:	08006800 	.word	0x08006800

08001840 <sem2_execute.9680>:
  chSemSignalI(&sem1); /* For coverage reasons */
  chSchRescheduleS();
  chSysUnlock();
}

static void sem2_execute(void) {
 8001840:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001842:	2520      	movs	r5, #32
 8001844:	b083      	sub	sp, #12
 8001846:	f385 8811 	msr	BASEPRI, r5
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
  msg_t msg;

  chSysLock();
  msg = chSemWaitTimeoutS(sp, time);
 800184a:	4c56      	ldr	r4, [pc, #344]	; (80019a4 <sem2_execute.9680+0x164>)
 800184c:	2100      	movs	r1, #0
 800184e:	4620      	mov	r0, r4
 8001850:	f002 fdb6 	bl	80043c0 <chSemWaitTimeoutS>
 8001854:	2300      	movs	r3, #0
 8001856:	4601      	mov	r1, r0
 8001858:	f383 8811 	msr	BASEPRI, r3

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
 800185c:	f1b1 3eff 	subs.w	lr, r1, #4294967295	; 0xffffffff
 8001860:	f1de 0100 	rsbs	r1, lr, #0
 8001864:	eb51 010e 	adcs.w	r1, r1, lr
 8001868:	2001      	movs	r0, #1
 800186a:	f7ff f9b1 	bl	8000bd0 <_test_assert>
 800186e:	b108      	cbz	r0, 8001874 <sem2_execute.9680+0x34>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
}
 8001870:	b003      	add	sp, #12
 8001872:	bdf0      	pop	{r4, r5, r6, r7, pc}
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 8001874:	6821      	ldr	r1, [r4, #0]
  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
  test_assert(2, queue_isempty(&sem1.s_queue), "queue not empty");
 8001876:	1b0f      	subs	r7, r1, r4
 8001878:	4279      	negs	r1, r7
 800187a:	4179      	adcs	r1, r7
 800187c:	2002      	movs	r0, #2
 800187e:	f7ff f9a7 	bl	8000bd0 <_test_assert>
 8001882:	2800      	cmp	r0, #0
 8001884:	d1f4      	bne.n	8001870 <sem2_execute.9680+0x30>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
 8001886:	68a1      	ldr	r1, [r4, #8]
 8001888:	f1d1 0101 	rsbs	r1, r1, #1
 800188c:	f04f 0003 	mov.w	r0, #3
 8001890:	bf38      	it	cc
 8001892:	2100      	movcc	r1, #0
 8001894:	f7ff f99c 	bl	8000bd0 <_test_assert>
 8001898:	4606      	mov	r6, r0
 800189a:	2800      	cmp	r0, #0
 800189c:	d1e8      	bne.n	8001870 <sem2_execute.9680+0x30>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800189e:	4b42      	ldr	r3, [pc, #264]	; (80019a8 <sem2_execute.9680+0x168>)

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80018a0:	4842      	ldr	r0, [pc, #264]	; (80019ac <sem2_execute.9680+0x16c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80018a2:	699a      	ldr	r2, [r3, #24]
 80018a4:	4b42      	ldr	r3, [pc, #264]	; (80019b0 <sem2_execute.9680+0x170>)
 80018a6:	6892      	ldr	r2, [r2, #8]
 80018a8:	9600      	str	r6, [sp, #0]
 80018aa:	3a01      	subs	r2, #1
 80018ac:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80018b0:	f002 fa06 	bl	8003cc0 <chThdCreateStatic>
 80018b4:	4b3f      	ldr	r3, [pc, #252]	; (80019b4 <sem2_execute.9680+0x174>)
 80018b6:	6018      	str	r0, [r3, #0]
 80018b8:	f385 8811 	msr	BASEPRI, r5
 80018bc:	f241 3188 	movw	r1, #5000	; 0x1388
 80018c0:	4620      	mov	r0, r4
 80018c2:	f002 fd7d 	bl	80043c0 <chSemWaitTimeoutS>
 80018c6:	4607      	mov	r7, r0
 80018c8:	f386 8811 	msr	BASEPRI, r6
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
  test_wait_threads();
 80018cc:	f000 faa0 	bl	8001e10 <test_wait_threads>
  test_assert(4, msg == MSG_OK, "wrong wake-up message");
 80018d0:	f1d7 0101 	rsbs	r1, r7, #1
 80018d4:	bf38      	it	cc
 80018d6:	2100      	movcc	r1, #0
 80018d8:	2004      	movs	r0, #4
 80018da:	f7ff f979 	bl	8000bd0 <_test_assert>
 80018de:	2800      	cmp	r0, #0
 80018e0:	d1c6      	bne.n	8001870 <sem2_execute.9680+0x30>
 80018e2:	6821      	ldr	r1, [r4, #0]
  test_assert(5, queue_isempty(&sem1.s_queue), "queue not empty");
 80018e4:	1b0e      	subs	r6, r1, r4
 80018e6:	4271      	negs	r1, r6
 80018e8:	4171      	adcs	r1, r6
 80018ea:	2005      	movs	r0, #5
 80018ec:	f7ff f970 	bl	8000bd0 <_test_assert>
 80018f0:	2800      	cmp	r0, #0
 80018f2:	d1bd      	bne.n	8001870 <sem2_execute.9680+0x30>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
 80018f4:	68a1      	ldr	r1, [r4, #8]
 80018f6:	f1d1 0101 	rsbs	r1, r1, #1
 80018fa:	f04f 0006 	mov.w	r0, #6
 80018fe:	bf38      	it	cc
 8001900:	2100      	movcc	r1, #0
 8001902:	f7ff f965 	bl	8000bd0 <_test_assert>
 8001906:	4606      	mov	r6, r0
 8001908:	2800      	cmp	r0, #0
 800190a:	d1b1      	bne.n	8001870 <sem2_execute.9680+0x30>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
 800190c:	f003 f980 	bl	8004c10 <test_wait_tick>
 8001910:	f385 8811 	msr	BASEPRI, r5
 8001914:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001918:	6a5f      	ldr	r7, [r3, #36]	; 0x24
 800191a:	f386 8811 	msr	BASEPRI, r6
 800191e:	2641      	movs	r6, #65	; 0x41
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
    test_emit_token('A' + i);
 8001920:	4630      	mov	r0, r6
 8001922:	f001 ff15 	bl	8003750 <test_emit_token>
 8001926:	f385 8811 	msr	BASEPRI, r5
 800192a:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800192e:	481d      	ldr	r0, [pc, #116]	; (80019a4 <sem2_execute.9680+0x164>)
 8001930:	f002 fd46 	bl	80043c0 <chSemWaitTimeoutS>
 8001934:	2300      	movs	r3, #0
 8001936:	4601      	mov	r1, r0
 8001938:	f383 8811 	msr	BASEPRI, r3
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 800193c:	f1b1 32ff 	subs.w	r2, r1, #4294967295	; 0xffffffff
 8001940:	4251      	negs	r1, r2
 8001942:	4151      	adcs	r1, r2
 8001944:	2007      	movs	r0, #7
 8001946:	f7ff f943 	bl	8000bd0 <_test_assert>
 800194a:	2800      	cmp	r0, #0
 800194c:	d190      	bne.n	8001870 <sem2_execute.9680+0x30>
 800194e:	6821      	ldr	r1, [r4, #0]
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 8001950:	1b0b      	subs	r3, r1, r4
 8001952:	4259      	negs	r1, r3
 8001954:	4159      	adcs	r1, r3
 8001956:	2008      	movs	r0, #8
 8001958:	f7ff f93a 	bl	8000bd0 <_test_assert>
 800195c:	2800      	cmp	r0, #0
 800195e:	d187      	bne.n	8001870 <sem2_execute.9680+0x30>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 8001960:	68a1      	ldr	r1, [r4, #8]
 8001962:	f1d1 0101 	rsbs	r1, r1, #1
 8001966:	f04f 0009 	mov.w	r0, #9
 800196a:	bf38      	it	cc
 800196c:	2100      	movcc	r1, #0
 800196e:	f7ff f92f 	bl	8000bd0 <_test_assert>
 8001972:	3601      	adds	r6, #1
 8001974:	b2f6      	uxtb	r6, r6
 8001976:	2800      	cmp	r0, #0
 8001978:	f47f af7a 	bne.w	8001870 <sem2_execute.9680+0x30>
  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
 800197c:	2e46      	cmp	r6, #70	; 0x46
 800197e:	d1cf      	bne.n	8001920 <sem2_execute.9680+0xe0>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
 8001980:	200a      	movs	r0, #10
 8001982:	490d      	ldr	r1, [pc, #52]	; (80019b8 <sem2_execute.9680+0x178>)
 8001984:	f7ff f8fc 	bl	8000b80 <_test_assert_sequence>
 8001988:	2800      	cmp	r0, #0
 800198a:	f47f af71 	bne.w	8001870 <sem2_execute.9680+0x30>
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 800198e:	200b      	movs	r0, #11
 8001990:	f607 11c4 	addw	r1, r7, #2500	; 0x9c4
 8001994:	f607 12d8 	addw	r2, r7, #2520	; 0x9d8
}
 8001998:	b003      	add	sp, #12
 800199a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 800199e:	f7ff b8cf 	b.w	8000b40 <_test_assert_time_window>
 80019a2:	bf00      	nop
 80019a4:	20000800 	.word	0x20000800
 80019a8:	20001208 	.word	0x20001208
 80019ac:	20000928 	.word	0x20000928
 80019b0:	08004be1 	.word	0x08004be1
 80019b4:	20001358 	.word	0x20001358
 80019b8:	08006818 	.word	0x08006818
 80019bc:	f3af 8000 	nop.w

080019c0 <thread2.10405>:

  chThdSleepMilliseconds(50);
  chEvtSignal((thread_t *)p, 1);
}

static THD_FUNCTION(thread2, p) {
 80019c0:	b538      	push	{r3, r4, r5, lr}
 80019c2:	2520      	movs	r5, #32
 80019c4:	f385 8811 	msr	BASEPRI, r5
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 80019c8:	480b      	ldr	r0, [pc, #44]	; (80019f8 <thread2.10405+0x38>)
 80019ca:	2100      	movs	r1, #0
 80019cc:	f002 fa68 	bl	8003ea0 <chEvtBroadcastFlagsI>
 80019d0:	2400      	movs	r4, #0
  chSchRescheduleS();
 80019d2:	f002 f8ed 	bl	8003bb0 <chSchRescheduleS>
 80019d6:	f384 8811 	msr	BASEPRI, r4

  (void)p;
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
 80019da:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80019de:	f003 f897 	bl	8004b10 <chThdSleep>
 80019e2:	f385 8811 	msr	BASEPRI, r5
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 80019e6:	4805      	ldr	r0, [pc, #20]	; (80019fc <thread2.10405+0x3c>)
 80019e8:	4621      	mov	r1, r4
 80019ea:	f002 fa59 	bl	8003ea0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80019ee:	f002 f8df 	bl	8003bb0 <chSchRescheduleS>
 80019f2:	f384 8811 	msr	BASEPRI, r4
 80019f6:	bd38      	pop	{r3, r4, r5, pc}
 80019f8:	200008b4 	.word	0x200008b4
 80019fc:	20000868 	.word	0x20000868

08001a00 <bmk7_execute.11396>:
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8001a00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001a04:	4e3a      	ldr	r6, [pc, #232]	; (8001af0 <bmk7_execute.11396+0xf0>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8001a06:	4b3b      	ldr	r3, [pc, #236]	; (8001af4 <bmk7_execute.11396+0xf4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001a08:	69b2      	ldr	r2, [r6, #24]
 8001a0a:	483b      	ldr	r0, [pc, #236]	; (8001af8 <bmk7_execute.11396+0xf8>)
 8001a0c:	6892      	ldr	r2, [r2, #8]
 8001a0e:	4d3b      	ldr	r5, [pc, #236]	; (8001afc <bmk7_execute.11396+0xfc>)
 8001a10:	f8df 910c 	ldr.w	r9, [pc, #268]	; 8001b20 <bmk7_execute.11396+0x120>
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8001a14:	b083      	sub	sp, #12
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8001a16:	2400      	movs	r4, #0
 8001a18:	3205      	adds	r2, #5
 8001a1a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001a1e:	9400      	str	r4, [sp, #0]
 8001a20:	f002 f94e 	bl	8003cc0 <chThdCreateStatic>
 8001a24:	69b3      	ldr	r3, [r6, #24]
 8001a26:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8001a28:	689a      	ldr	r2, [r3, #8]
 8001a2a:	4835      	ldr	r0, [pc, #212]	; (8001b00 <bmk7_execute.11396+0x100>)
 8001a2c:	4b31      	ldr	r3, [pc, #196]	; (8001af4 <bmk7_execute.11396+0xf4>)
 8001a2e:	9400      	str	r4, [sp, #0]
 8001a30:	3204      	adds	r2, #4
 8001a32:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001a36:	f002 f943 	bl	8003cc0 <chThdCreateStatic>
 8001a3a:	69b3      	ldr	r3, [r6, #24]
 8001a3c:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8001a3e:	689a      	ldr	r2, [r3, #8]
 8001a40:	4830      	ldr	r0, [pc, #192]	; (8001b04 <bmk7_execute.11396+0x104>)
 8001a42:	4b2c      	ldr	r3, [pc, #176]	; (8001af4 <bmk7_execute.11396+0xf4>)
 8001a44:	9400      	str	r4, [sp, #0]
 8001a46:	3203      	adds	r2, #3
 8001a48:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001a4c:	f002 f938 	bl	8003cc0 <chThdCreateStatic>
 8001a50:	69b3      	ldr	r3, [r6, #24]
 8001a52:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8001a54:	689a      	ldr	r2, [r3, #8]
 8001a56:	482c      	ldr	r0, [pc, #176]	; (8001b08 <bmk7_execute.11396+0x108>)
 8001a58:	4b26      	ldr	r3, [pc, #152]	; (8001af4 <bmk7_execute.11396+0xf4>)
 8001a5a:	9400      	str	r4, [sp, #0]
 8001a5c:	3202      	adds	r2, #2
 8001a5e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001a62:	f002 f92d 	bl	8003cc0 <chThdCreateStatic>
 8001a66:	69b3      	ldr	r3, [r6, #24]
 8001a68:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8001a6a:	689a      	ldr	r2, [r3, #8]
 8001a6c:	4827      	ldr	r0, [pc, #156]	; (8001b0c <bmk7_execute.11396+0x10c>)
 8001a6e:	4b21      	ldr	r3, [pc, #132]	; (8001af4 <bmk7_execute.11396+0xf4>)
 8001a70:	9400      	str	r4, [sp, #0]
 8001a72:	3201      	adds	r2, #1
 8001a74:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001a78:	f002 f922 	bl	8003cc0 <chThdCreateStatic>
 8001a7c:	6128      	str	r0, [r5, #16]

  n = 0;
  test_wait_tick();
 8001a7e:	f003 f8c7 	bl	8004c10 <test_wait_tick>
  test_start_timer(1000);
 8001a82:	f002 fc7d 	bl	8004380 <test_start_timer.constprop.2>
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();
  chSemResetI(sp, n);
 8001a86:	46a0      	mov	r8, r4
 8001a88:	2720      	movs	r7, #32
 8001a8a:	2620      	movs	r6, #32
 8001a8c:	f387 8811 	msr	BASEPRI, r7
 8001a90:	481f      	ldr	r0, [pc, #124]	; (8001b10 <bmk7_execute.11396+0x110>)
 8001a92:	2100      	movs	r1, #0
 8001a94:	f002 fbec 	bl	8004270 <chSemResetI>
 8001a98:	2500      	movs	r5, #0
  chSchRescheduleS();
 8001a9a:	f002 f889 	bl	8003bb0 <chSchRescheduleS>
 8001a9e:	f388 8811 	msr	BASEPRI, r8
    chSemReset(&sem1, 0);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001aa2:	f899 3000 	ldrb.w	r3, [r9]
  n = 0;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chSemReset(&sem1, 0);
    n++;
 8001aa6:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001aa8:	2b00      	cmp	r3, #0
 8001aaa:	d0ee      	beq.n	8001a8a <bmk7_execute.11396+0x8a>
  test_terminate_threads();
 8001aac:	f7ff f830 	bl	8000b10 <test_terminate_threads>
 8001ab0:	f386 8811 	msr	BASEPRI, r6
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();
  chSemResetI(sp, n);
 8001ab4:	4816      	ldr	r0, [pc, #88]	; (8001b10 <bmk7_execute.11396+0x110>)
 8001ab6:	4629      	mov	r1, r5
 8001ab8:	f002 fbda 	bl	8004270 <chSemResetI>
  chSchRescheduleS();
 8001abc:	f002 f878 	bl	8003bb0 <chSchRescheduleS>
 8001ac0:	f385 8811 	msr	BASEPRI, r5
  chSemReset(&sem1, 0);
  test_wait_threads();
 8001ac4:	f000 f9a4 	bl	8001e10 <test_wait_threads>

  test_print("--- Score : ");
 8001ac8:	4812      	ldr	r0, [pc, #72]	; (8001b14 <bmk7_execute.11396+0x114>)
 8001aca:	f001 fe69 	bl	80037a0 <test_print>
  test_printn(n);
 8001ace:	4620      	mov	r0, r4
 8001ad0:	f001 fe76 	bl	80037c0 <test_printn>
  test_print(" reschedules/S, ");
 8001ad4:	4810      	ldr	r0, [pc, #64]	; (8001b18 <bmk7_execute.11396+0x118>)
 8001ad6:	f001 fe63 	bl	80037a0 <test_print>
  test_printn(n * 6);
 8001ada:	eb04 0044 	add.w	r0, r4, r4, lsl #1
 8001ade:	0040      	lsls	r0, r0, #1
 8001ae0:	f001 fe6e 	bl	80037c0 <test_printn>
  test_println(" ctxswc/S");
 8001ae4:	480d      	ldr	r0, [pc, #52]	; (8001b1c <bmk7_execute.11396+0x11c>)
}
 8001ae6:	b003      	add	sp, #12
 8001ae8:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}

  test_print("--- Score : ");
  test_printn(n);
  test_print(" reschedules/S, ");
  test_printn(n * 6);
  test_println(" ctxswc/S");
 8001aec:	f001 be40 	b.w	8003770 <test_println>
 8001af0:	20001208 	.word	0x20001208
 8001af4:	080003b1 	.word	0x080003b1
 8001af8:	20000928 	.word	0x20000928
 8001afc:	20001358 	.word	0x20001358
 8001b00:	20000a70 	.word	0x20000a70
 8001b04:	20000bb8 	.word	0x20000bb8
 8001b08:	20000d00 	.word	0x20000d00
 8001b0c:	20000e48 	.word	0x20000e48
 8001b10:	200008b8 	.word	0x200008b8
 8001b14:	08006820 	.word	0x08006820
 8001b18:	08006830 	.word	0x08006830
 8001b1c:	08006844 	.word	0x08006844
 8001b20:	200008c4 	.word	0x200008c4
 8001b24:	f3af 8000 	nop.w
 8001b28:	f3af 8000 	nop.w
 8001b2c:	f3af 8000 	nop.w

08001b30 <evt1_execute.10420>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
 8001b30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8001b34:	4c32      	ldr	r4, [pc, #200]	; (8001c00 <evt1_execute.10420+0xd0>)
 8001b36:	b08a      	sub	sp, #40	; 0x28
 8001b38:	2020      	movs	r0, #32
 8001b3a:	6024      	str	r4, [r4, #0]
 8001b3c:	f380 8811 	msr	BASEPRI, r0
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 8001b40:	4930      	ldr	r1, [pc, #192]	; (8001c04 <evt1_execute.10420+0xd4>)
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8001b42:	6823      	ldr	r3, [r4, #0]
 8001b44:	ad0a      	add	r5, sp, #40	; 0x28
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
 8001b46:	2701      	movs	r7, #1
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8001b48:	f845 3d28 	str.w	r3, [r5, #-40]!
  esp->es_next     = elp;
  elp->el_listener = currp;
 8001b4c:	698b      	ldr	r3, [r1, #24]
 8001b4e:	9301      	str	r3, [sp, #4]
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 8001b50:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 8001b54:	2300      	movs	r3, #0

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
 8001b56:	6025      	str	r5, [r4, #0]
  elp->el_listener = currp;
  elp->el_events   = events;
 8001b58:	9702      	str	r7, [sp, #8]
  elp->el_flags    = (eventflags_t)0;
 8001b5a:	9303      	str	r3, [sp, #12]
  elp->el_wflags   = wflags;
 8001b5c:	9204      	str	r2, [sp, #16]
 8001b5e:	f383 8811 	msr	BASEPRI, r3
 8001b62:	f380 8811 	msr	BASEPRI, r0
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8001b66:	ae0a      	add	r6, sp, #40	; 0x28
 8001b68:	6820      	ldr	r0, [r4, #0]
 8001b6a:	f846 0d14 	str.w	r0, [r6, #-20]!
  esp->es_next     = elp;
  elp->el_listener = currp;
 8001b6e:	6989      	ldr	r1, [r1, #24]
 8001b70:	9106      	str	r1, [sp, #24]
  elp->el_events   = events;
 8001b72:	f04f 0802 	mov.w	r8, #2
  elp->el_flags    = (eventflags_t)0;
 8001b76:	9308      	str	r3, [sp, #32]
  elp->el_wflags   = wflags;
 8001b78:	9209      	str	r2, [sp, #36]	; 0x24

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
 8001b7a:	6026      	str	r6, [r4, #0]
  elp->el_listener = currp;
  elp->el_events   = events;
 8001b7c:	f8cd 801c 	str.w	r8, [sp, #28]
 8001b80:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {

  return (bool)(esp != (event_source_t *)esp->es_next);
 8001b84:	6821      	ldr	r1, [r4, #0]
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
 8001b86:	1b09      	subs	r1, r1, r4
 8001b88:	bf18      	it	ne
 8001b8a:	2101      	movne	r1, #1
 8001b8c:	4638      	mov	r0, r7
 8001b8e:	f7ff f81f 	bl	8000bd0 <_test_assert>
 8001b92:	b110      	cbz	r0, 8001b9a <evt1_execute.10420+0x6a>
  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
  test_assert_sequence(4, "ABC");
}
 8001b94:	b00a      	add	sp, #40	; 0x28
 8001b96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
  chEvtUnregister(&es1, &el1);
 8001b9a:	4669      	mov	r1, sp
 8001b9c:	4620      	mov	r0, r4
 8001b9e:	f001 ff77 	bl	8003a90 <chEvtUnregister>
 8001ba2:	6821      	ldr	r1, [r4, #0]
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
 8001ba4:	1b09      	subs	r1, r1, r4
 8001ba6:	bf18      	it	ne
 8001ba8:	2101      	movne	r1, #1
 8001baa:	4640      	mov	r0, r8
 8001bac:	f7ff f810 	bl	8000bd0 <_test_assert>
 8001bb0:	2800      	cmp	r0, #0
 8001bb2:	d1ef      	bne.n	8001b94 <evt1_execute.10420+0x64>
  chEvtUnregister(&es1, &el2);
 8001bb4:	4631      	mov	r1, r6
 8001bb6:	4620      	mov	r0, r4
 8001bb8:	f001 ff6a 	bl	8003a90 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
 8001bbc:	6821      	ldr	r1, [r4, #0]
 8001bbe:	1b0a      	subs	r2, r1, r4
 8001bc0:	4251      	negs	r1, r2
 8001bc2:	4151      	adcs	r1, r2
 8001bc4:	2003      	movs	r0, #3
 8001bc6:	f7ff f803 	bl	8000bd0 <_test_assert>
 8001bca:	2800      	cmp	r0, #0
 8001bcc:	d1e2      	bne.n	8001b94 <evt1_execute.10420+0x64>
  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
 8001bce:	4e0e      	ldr	r6, [pc, #56]	; (8001c08 <evt1_execute.10420+0xd8>)
 8001bd0:	4604      	mov	r4, r0
 8001bd2:	2507      	movs	r5, #7
 8001bd4:	e001      	b.n	8001bda <evt1_execute.10420+0xaa>
    }
    eid++;
 8001bd6:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8001bd8:	b165      	cbz	r5, 8001bf4 <evt1_execute.10420+0xc4>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8001bda:	fa25 f304 	lsr.w	r3, r5, r4
 8001bde:	07db      	lsls	r3, r3, #31
 8001be0:	d5f9      	bpl.n	8001bd6 <evt1_execute.10420+0xa6>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8001be2:	fa07 f204 	lsl.w	r2, r7, r4
      handlers[eid](eid);
 8001be6:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
 8001bea:	4620      	mov	r0, r4

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8001bec:	ea25 0502 	bic.w	r5, r5, r2
      handlers[eid](eid);
 8001bf0:	4798      	blx	r3
 8001bf2:	e7f0      	b.n	8001bd6 <evt1_execute.10420+0xa6>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
  test_assert_sequence(4, "ABC");
 8001bf4:	4905      	ldr	r1, [pc, #20]	; (8001c0c <evt1_execute.10420+0xdc>)
 8001bf6:	2004      	movs	r0, #4
 8001bf8:	f7fe ffc2 	bl	8000b80 <_test_assert_sequence>
 8001bfc:	e7ca      	b.n	8001b94 <evt1_execute.10420+0x64>
 8001bfe:	bf00      	nop
 8001c00:	200008b4 	.word	0x200008b4
 8001c04:	20001208 	.word	0x20001208
 8001c08:	080067f0 	.word	0x080067f0
 8001c0c:	08006850 	.word	0x08006850

08001c10 <thread2.11364>:

  chThdExit((msg_t)p);
}

#if CH_CFG_USE_MESSAGES || defined(__DOXYGEN__)
static THD_FUNCTION(thread2, p) {
 8001c10:	b570      	push	{r4, r5, r6, lr}
 8001c12:	2620      	movs	r6, #32
 8001c14:	2500      	movs	r5, #0
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 8001c16:	f002 f8ab 	bl	8003d70 <chMsgWait>
  chThdExit((msg_t)p);
}

#if CH_CFG_USE_MESSAGES || defined(__DOXYGEN__)
static THD_FUNCTION(thread2, p) {
  thread_t *tp;
 8001c1a:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8001c1c:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8001c20:	4621      	mov	r1, r4
 8001c22:	f001 fffd 	bl	8003c20 <chSchWakeupS>
 8001c26:	f385 8811 	msr	BASEPRI, r5
  (void)p;
  do {
    tp = chMsgWait();
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
  } while (msg);
 8001c2a:	2c00      	cmp	r4, #0
 8001c2c:	d1f3      	bne.n	8001c16 <thread2.11364+0x6>
}
 8001c2e:	bd70      	pop	{r4, r5, r6, pc}

08001c30 <vtcb.11161>:
 *
 * <h2>Description</h2>
 * The critical zones API is invoked for coverage.
 */

static void vtcb(void *p) {
 8001c30:	b508      	push	{r3, lr}
 8001c32:	2320      	movs	r3, #32
 8001c34:	f383 8811 	msr	BASEPRI, r3
 8001c38:	2200      	movs	r2, #0
 8001c3a:	f382 8811 	msr	BASEPRI, r2
 8001c3e:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
 8001c42:	f3ef 8312 	mrs	r3, BASEPRI_MAX
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 8001c46:	b91b      	cbnz	r3, 8001c50 <vtcb.11161+0x20>
 8001c48:	f002 fb82 	bl	8004350 <chSysGetStatusAndLockX.part.2.4284>
 8001c4c:	f001 ffd8 	bl	8003c00 <chSysRestoreStatusX.part.3.4287>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001c50:	2300      	movs	r3, #0
 8001c52:	f383 8811 	msr	BASEPRI, r3
 8001c56:	bd08      	pop	{r3, pc}
 8001c58:	f3af 8000 	nop.w
 8001c5c:	f3af 8000 	nop.w

08001c60 <pools1_execute.10709>:
static void pools1_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void pools1_execute(void) {
 8001c60:	b570      	push	{r4, r5, r6, lr}
 8001c62:	4b31      	ldr	r3, [pc, #196]	; (8001d28 <pools1_execute.10709+0xc8>)
 8001c64:	4c31      	ldr	r4, [pc, #196]	; (8001d2c <pools1_execute.10709+0xcc>)
 8001c66:	2205      	movs	r2, #5
 8001c68:	2520      	movs	r5, #32
 8001c6a:	2000      	movs	r0, #0
 8001c6c:	f385 8811 	msr	BASEPRI, r5
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8001c70:	6821      	ldr	r1, [r4, #0]
 8001c72:	6019      	str	r1, [r3, #0]
  mp->mp_next = php;
 8001c74:	6023      	str	r3, [r4, #0]
 8001c76:	f380 8811 	msr	BASEPRI, r0
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 8001c7a:	6861      	ldr	r1, [r4, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8001c7c:	3a01      	subs	r2, #1
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 8001c7e:	440b      	add	r3, r1
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8001c80:	d1f4      	bne.n	8001c6c <pools1_execute.10709+0xc>
 8001c82:	2505      	movs	r5, #5
  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");
 8001c84:	4829      	ldr	r0, [pc, #164]	; (8001d2c <pools1_execute.10709+0xcc>)
 8001c86:	f001 feeb 	bl	8003a60 <chPoolAlloc>
 8001c8a:	1c01      	adds	r1, r0, #0
 8001c8c:	bf18      	it	ne
 8001c8e:	2101      	movne	r1, #1
 8001c90:	2001      	movs	r0, #1
 8001c92:	f7fe ff9d 	bl	8000bd0 <_test_assert>
 8001c96:	2800      	cmp	r0, #0
 8001c98:	d134      	bne.n	8001d04 <pools1_execute.10709+0xa4>

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 8001c9a:	3d01      	subs	r5, #1
 8001c9c:	d1f2      	bne.n	8001c84 <pools1_execute.10709+0x24>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 8001c9e:	4823      	ldr	r0, [pc, #140]	; (8001d2c <pools1_execute.10709+0xcc>)
 8001ca0:	f001 fede 	bl	8003a60 <chPoolAlloc>
 8001ca4:	f1d0 0101 	rsbs	r1, r0, #1
 8001ca8:	bf38      	it	cc
 8001caa:	2100      	movcc	r1, #0
 8001cac:	2002      	movs	r0, #2
 8001cae:	f7fe ff8f 	bl	8000bd0 <_test_assert>
 8001cb2:	bb38      	cbnz	r0, 8001d04 <pools1_execute.10709+0xa4>
 8001cb4:	4b1e      	ldr	r3, [pc, #120]	; (8001d30 <pools1_execute.10709+0xd0>)
 8001cb6:	2020      	movs	r0, #32
 8001cb8:	f103 0614 	add.w	r6, r3, #20

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);
 8001cbc:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8001cc0:	f380 8811 	msr	BASEPRI, r0
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8001cc4:	6821      	ldr	r1, [r4, #0]
 8001cc6:	6011      	str	r1, [r2, #0]
  mp->mp_next = php;
 8001cc8:	6022      	str	r2, [r4, #0]
 8001cca:	f385 8811 	msr	BASEPRI, r5

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 8001cce:	42b3      	cmp	r3, r6
 8001cd0:	d1f4      	bne.n	8001cbc <pools1_execute.10709+0x5c>
 8001cd2:	2405      	movs	r4, #5
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");
 8001cd4:	4d15      	ldr	r5, [pc, #84]	; (8001d2c <pools1_execute.10709+0xcc>)
 8001cd6:	4628      	mov	r0, r5
 8001cd8:	f001 fec2 	bl	8003a60 <chPoolAlloc>
 8001cdc:	1c01      	adds	r1, r0, #0
 8001cde:	bf18      	it	ne
 8001ce0:	2101      	movne	r1, #1
 8001ce2:	2003      	movs	r0, #3
 8001ce4:	f7fe ff74 	bl	8000bd0 <_test_assert>
 8001ce8:	b960      	cbnz	r0, 8001d04 <pools1_execute.10709+0xa4>
  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 8001cea:	3c01      	subs	r4, #1
 8001cec:	d1f2      	bne.n	8001cd4 <pools1_execute.10709+0x74>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");
 8001cee:	4628      	mov	r0, r5
 8001cf0:	f001 feb6 	bl	8003a60 <chPoolAlloc>
 8001cf4:	f1d0 0101 	rsbs	r1, r0, #1
 8001cf8:	bf38      	it	cc
 8001cfa:	2100      	movcc	r1, #0
 8001cfc:	2004      	movs	r0, #4
 8001cfe:	f7fe ff67 	bl	8000bd0 <_test_assert>
 8001d02:	b100      	cbz	r0, 8001d06 <pools1_execute.10709+0xa6>
 8001d04:	bd70      	pop	{r4, r5, r6, pc}
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
  mp->mp_object_size = size;
 8001d06:	2210      	movs	r2, #16
  mp->mp_provider = provider;
 8001d08:	4b0a      	ldr	r3, [pc, #40]	; (8001d34 <pools1_execute.10709+0xd4>)
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8001d0a:	602c      	str	r4, [r5, #0]

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8001d0c:	4628      	mov	r0, r5
  mp->mp_object_size = size;
 8001d0e:	606a      	str	r2, [r5, #4]
  mp->mp_provider = provider;
 8001d10:	60ab      	str	r3, [r5, #8]
 8001d12:	f001 fea5 	bl	8003a60 <chPoolAlloc>
 8001d16:	f1d0 0101 	rsbs	r1, r0, #1
 8001d1a:	bf38      	it	cc
 8001d1c:	2100      	movcc	r1, #0
 8001d1e:	2005      	movs	r0, #5
}
 8001d20:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8001d24:	f7fe bf54 	b.w	8000bd0 <_test_assert>
 8001d28:	20000928 	.word	0x20000928
 8001d2c:	2000080c 	.word	0x2000080c
 8001d30:	080068cc 	.word	0x080068cc
 8001d34:	08000341 	.word	0x08000341
 8001d38:	f3af 8000 	nop.w
 8001d3c:	f3af 8000 	nop.w

08001d40 <bmk5_execute.11394>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 8001d40:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001d42:	4b13      	ldr	r3, [pc, #76]	; (8001d90 <bmk5_execute.11394+0x50>)
 8001d44:	4f13      	ldr	r7, [pc, #76]	; (8001d94 <bmk5_execute.11394+0x54>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001d46:	699b      	ldr	r3, [r3, #24]
 8001d48:	b083      	sub	sp, #12

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
 8001d4a:	689e      	ldr	r6, [r3, #8]
  test_wait_tick();
 8001d4c:	f002 ff60 	bl	8004c10 <test_wait_tick>
  test_start_timer(1000);
 8001d50:	f002 fb16 	bl	8004380 <test_start_timer.constprop.2>
 * a second of continuous operations.
 */

static void bmk5_execute(void) {

  uint32_t n = 0;
 8001d54:	2400      	movs	r4, #0
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
 8001d56:	3e01      	subs	r6, #1
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 8001d58:	4625      	mov	r5, r4
 8001d5a:	4b0f      	ldr	r3, [pc, #60]	; (8001d98 <bmk5_execute.11394+0x58>)
 8001d5c:	9500      	str	r5, [sp, #0]
 8001d5e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001d62:	4632      	mov	r2, r6
 8001d64:	480d      	ldr	r0, [pc, #52]	; (8001d9c <bmk5_execute.11394+0x5c>)
 8001d66:	f001 ffab 	bl	8003cc0 <chThdCreateStatic>
 8001d6a:	f004 fca9 	bl	80066c0 <chThdWait>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001d6e:	783b      	ldrb	r3, [r7, #0]
  tprio_t prio = chThdGetPriorityX() - 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
    n++;
 8001d70:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001d72:	2b00      	cmp	r3, #0
 8001d74:	d0f1      	beq.n	8001d5a <bmk5_execute.11394+0x1a>
  test_print("--- Score : ");
 8001d76:	480a      	ldr	r0, [pc, #40]	; (8001da0 <bmk5_execute.11394+0x60>)
 8001d78:	f001 fd12 	bl	80037a0 <test_print>
  test_printn(n);
 8001d7c:	4620      	mov	r0, r4
 8001d7e:	f001 fd1f 	bl	80037c0 <test_printn>
  test_println(" threads/S");
 8001d82:	4808      	ldr	r0, [pc, #32]	; (8001da4 <bmk5_execute.11394+0x64>)
}
 8001d84:	b003      	add	sp, #12
 8001d86:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n);
  test_println(" threads/S");
 8001d8a:	f001 bcf1 	b.w	8003770 <test_println>
 8001d8e:	bf00      	nop
 8001d90:	20001208 	.word	0x20001208
 8001d94:	200008c4 	.word	0x200008c4
 8001d98:	08005821 	.word	0x08005821
 8001d9c:	20000928 	.word	0x20000928
 8001da0:	08006820 	.word	0x08006820
 8001da4:	08006870 	.word	0x08006870
 8001da8:	f3af 8000 	nop.w
 8001dac:	f3af 8000 	nop.w

08001db0 <regfind.10847>:
 * <h2>Description</h2>
 * Registry and Thread References APIs are tested for functionality and
 * coverage.
 */

static bool regfind(thread_t *tp) {
 8001db0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001db4:	4681      	mov	r9, r0
 8001db6:	f04f 0820 	mov.w	r8, #32
 8001dba:	f388 8811 	msr	BASEPRI, r8
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.r_newer;
 8001dbe:	4e10      	ldr	r6, [pc, #64]	; (8001e00 <regfind.10847+0x50>)
 8001dc0:	6930      	ldr	r0, [r6, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
 8001dc2:	7f83      	ldrb	r3, [r0, #30]
 8001dc4:	3301      	adds	r3, #1
 8001dc6:	7783      	strb	r3, [r0, #30]
 8001dc8:	2500      	movs	r5, #0
 8001dca:	f385 8811 	msr	BASEPRI, r5
  chSysLock();
  ntp = tp->p_newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 8001dce:	462f      	mov	r7, r5
 8001dd0:	e000      	b.n	8001dd4 <regfind.10847+0x24>
  bool found = false;

  ftp = chRegFirstThread();
  do {
    found |= ftp == tp;
    ftp = chRegNextThread(ftp);
 8001dd2:	4620      	mov	r0, r4
  thread_t *ftp;
  bool found = false;

  ftp = chRegFirstThread();
  do {
    found |= ftp == tp;
 8001dd4:	4548      	cmp	r0, r9
 8001dd6:	bf08      	it	eq
 8001dd8:	f045 0501 	orreq.w	r5, r5, #1
 8001ddc:	f388 8811 	msr	BASEPRI, r8
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->p_newer;
 8001de0:	6904      	ldr	r4, [r0, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8001de2:	42b4      	cmp	r4, r6
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
    ntp->p_refs++;
 8001de4:	bf1d      	ittte	ne
 8001de6:	7fa3      	ldrbne	r3, [r4, #30]
 8001de8:	3301      	addne	r3, #1
 8001dea:	77a3      	strbne	r3, [r4, #30]
  chSysLock();
  ntp = tp->p_newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 8001dec:	2400      	moveq	r4, #0
 8001dee:	f387 8811 	msr	BASEPRI, r7
    ntp->p_refs++;
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8001df2:	f004 fc35 	bl	8006660 <chThdRelease>
    ftp = chRegNextThread(ftp);
  } while (ftp != NULL);
 8001df6:	2c00      	cmp	r4, #0
 8001df8:	d1eb      	bne.n	8001dd2 <regfind.10847+0x22>
  return found;
}
 8001dfa:	4628      	mov	r0, r5
 8001dfc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8001e00:	20001208 	.word	0x20001208
 8001e04:	f3af 8000 	nop.w
 8001e08:	f3af 8000 	nop.w
 8001e0c:	f3af 8000 	nop.w

08001e10 <test_wait_threads>:
}

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8001e10:	b570      	push	{r4, r5, r6, lr}
 8001e12:	4c07      	ldr	r4, [pc, #28]	; (8001e30 <test_wait_threads+0x20>)
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
 8001e14:	2600      	movs	r6, #0
 8001e16:	f104 0514 	add.w	r5, r4, #20
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 8001e1a:	f854 3b04 	ldr.w	r3, [r4], #4
      chThdWait(threads[i]);
 8001e1e:	4618      	mov	r0, r3
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 8001e20:	b11b      	cbz	r3, 8001e2a <test_wait_threads+0x1a>
      chThdWait(threads[i]);
 8001e22:	f004 fc4d 	bl	80066c0 <chThdWait>
      threads[i] = NULL;
 8001e26:	f844 6c04 	str.w	r6, [r4, #-4]
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 8001e2a:	42ac      	cmp	r4, r5
 8001e2c:	d1f5      	bne.n	8001e1a <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 8001e2e:	bd70      	pop	{r4, r5, r6, pc}
 8001e30:	20001358 	.word	0x20001358
 8001e34:	f3af 8000 	nop.w
 8001e38:	f3af 8000 	nop.w
 8001e3c:	f3af 8000 	nop.w

08001e40 <bmk1_execute.11386>:
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 8001e40:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001e42:	4b13      	ldr	r3, [pc, #76]	; (8001e90 <bmk1_execute.11386+0x50>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8001e44:	4813      	ldr	r0, [pc, #76]	; (8001e94 <bmk1_execute.11386+0x54>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001e46:	699a      	ldr	r2, [r3, #24]
 8001e48:	4b13      	ldr	r3, [pc, #76]	; (8001e98 <bmk1_execute.11386+0x58>)
 8001e4a:	6892      	ldr	r2, [r2, #8]
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 8001e4c:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8001e4e:	2100      	movs	r1, #0
 8001e50:	3a01      	subs	r2, #1
 8001e52:	9100      	str	r1, [sp, #0]
 8001e54:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001e58:	f001 ff32 	bl	8003cc0 <chThdCreateStatic>
 8001e5c:	4b0f      	ldr	r3, [pc, #60]	; (8001e9c <bmk1_execute.11386+0x5c>)
 8001e5e:	6018      	str	r0, [r3, #0]
  n = msg_loop_test(threads[0]);
 8001e60:	f004 fc4e 	bl	8006700 <msg_loop_test.11383>
 8001e64:	4604      	mov	r4, r0
  test_wait_threads();
 8001e66:	f7ff ffd3 	bl	8001e10 <test_wait_threads>
  test_print("--- Score : ");
 8001e6a:	480d      	ldr	r0, [pc, #52]	; (8001ea0 <bmk1_execute.11386+0x60>)
 8001e6c:	f001 fc98 	bl	80037a0 <test_print>
  test_printn(n);
 8001e70:	4620      	mov	r0, r4
 8001e72:	f001 fca5 	bl	80037c0 <test_printn>
  test_print(" msgs/S, ");
 8001e76:	480b      	ldr	r0, [pc, #44]	; (8001ea4 <bmk1_execute.11386+0x64>)
 8001e78:	f001 fc92 	bl	80037a0 <test_print>
  test_printn(n << 1);
 8001e7c:	0060      	lsls	r0, r4, #1
 8001e7e:	f001 fc9f 	bl	80037c0 <test_printn>
  test_println(" ctxswc/S");
 8001e82:	4809      	ldr	r0, [pc, #36]	; (8001ea8 <bmk1_execute.11386+0x68>)
}
 8001e84:	b002      	add	sp, #8
 8001e86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
 8001e8a:	f001 bc71 	b.w	8003770 <test_println>
 8001e8e:	bf00      	nop
 8001e90:	20001208 	.word	0x20001208
 8001e94:	20000928 	.word	0x20000928
 8001e98:	08001c11 	.word	0x08001c11
 8001e9c:	20001358 	.word	0x20001358
 8001ea0:	08006820 	.word	0x08006820
 8001ea4:	0800687c 	.word	0x0800687c
 8001ea8:	08006844 	.word	0x08006844
 8001eac:	f3af 8000 	nop.w

08001eb0 <bmk2_execute.11388>:
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 8001eb0:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001eb2:	4b13      	ldr	r3, [pc, #76]	; (8001f00 <bmk2_execute.11388+0x50>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8001eb4:	4813      	ldr	r0, [pc, #76]	; (8001f04 <bmk2_execute.11388+0x54>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001eb6:	699a      	ldr	r2, [r3, #24]
 8001eb8:	4b13      	ldr	r3, [pc, #76]	; (8001f08 <bmk2_execute.11388+0x58>)
 8001eba:	6892      	ldr	r2, [r2, #8]
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 8001ebc:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8001ebe:	2100      	movs	r1, #0
 8001ec0:	3201      	adds	r2, #1
 8001ec2:	9100      	str	r1, [sp, #0]
 8001ec4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001ec8:	f001 fefa 	bl	8003cc0 <chThdCreateStatic>
 8001ecc:	4b0f      	ldr	r3, [pc, #60]	; (8001f0c <bmk2_execute.11388+0x5c>)
 8001ece:	6018      	str	r0, [r3, #0]
  n = msg_loop_test(threads[0]);
 8001ed0:	f004 fc16 	bl	8006700 <msg_loop_test.11383>
 8001ed4:	4604      	mov	r4, r0
  test_wait_threads();
 8001ed6:	f7ff ff9b 	bl	8001e10 <test_wait_threads>
  test_print("--- Score : ");
 8001eda:	480d      	ldr	r0, [pc, #52]	; (8001f10 <bmk2_execute.11388+0x60>)
 8001edc:	f001 fc60 	bl	80037a0 <test_print>
  test_printn(n);
 8001ee0:	4620      	mov	r0, r4
 8001ee2:	f001 fc6d 	bl	80037c0 <test_printn>
  test_print(" msgs/S, ");
 8001ee6:	480b      	ldr	r0, [pc, #44]	; (8001f14 <bmk2_execute.11388+0x64>)
 8001ee8:	f001 fc5a 	bl	80037a0 <test_print>
  test_printn(n << 1);
 8001eec:	0060      	lsls	r0, r4, #1
 8001eee:	f001 fc67 	bl	80037c0 <test_printn>
  test_println(" ctxswc/S");
 8001ef2:	4809      	ldr	r0, [pc, #36]	; (8001f18 <bmk2_execute.11388+0x68>)
}
 8001ef4:	b002      	add	sp, #8
 8001ef6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
 8001efa:	f001 bc39 	b.w	8003770 <test_println>
 8001efe:	bf00      	nop
 8001f00:	20001208 	.word	0x20001208
 8001f04:	20000928 	.word	0x20000928
 8001f08:	08001c11 	.word	0x08001c11
 8001f0c:	20001358 	.word	0x20001358
 8001f10:	08006820 	.word	0x08006820
 8001f14:	0800687c 	.word	0x0800687c
 8001f18:	08006844 	.word	0x08006844
 8001f1c:	f3af 8000 	nop.w

08001f20 <bmk3_execute.11390>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 8001f20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001f24:	4f2c      	ldr	r7, [pc, #176]	; (8001fd8 <bmk3_execute.11390+0xb8>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8001f26:	4d2d      	ldr	r5, [pc, #180]	; (8001fdc <bmk3_execute.11390+0xbc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001f28:	69ba      	ldr	r2, [r7, #24]
 8001f2a:	4b2d      	ldr	r3, [pc, #180]	; (8001fe0 <bmk3_execute.11390+0xc0>)
 8001f2c:	6892      	ldr	r2, [r2, #8]
 8001f2e:	4c2d      	ldr	r4, [pc, #180]	; (8001fe4 <bmk3_execute.11390+0xc4>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8001f30:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8001ff4 <bmk3_execute.11390+0xd4>
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 8001f34:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8001f36:	2600      	movs	r6, #0
 8001f38:	3201      	adds	r2, #1
 8001f3a:	4628      	mov	r0, r5
 8001f3c:	9600      	str	r6, [sp, #0]
 8001f3e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001f42:	f001 febd 	bl	8003cc0 <chThdCreateStatic>
 8001f46:	69bb      	ldr	r3, [r7, #24]
 8001f48:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8001f4a:	689a      	ldr	r2, [r3, #8]
 8001f4c:	9600      	str	r6, [sp, #0]
 8001f4e:	4643      	mov	r3, r8
 8001f50:	3a02      	subs	r2, #2
 8001f52:	f505 70a4 	add.w	r0, r5, #328	; 0x148
 8001f56:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001f5a:	f001 feb1 	bl	8003cc0 <chThdCreateStatic>
 8001f5e:	69bb      	ldr	r3, [r7, #24]
 8001f60:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8001f62:	689a      	ldr	r2, [r3, #8]
 8001f64:	9600      	str	r6, [sp, #0]
 8001f66:	4643      	mov	r3, r8
 8001f68:	3a03      	subs	r2, #3
 8001f6a:	f505 7024 	add.w	r0, r5, #656	; 0x290
 8001f6e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001f72:	f001 fea5 	bl	8003cc0 <chThdCreateStatic>
 8001f76:	69bb      	ldr	r3, [r7, #24]
 8001f78:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8001f7a:	689a      	ldr	r2, [r3, #8]
 8001f7c:	9600      	str	r6, [sp, #0]
 8001f7e:	4643      	mov	r3, r8
 8001f80:	3a04      	subs	r2, #4
 8001f82:	f505 7076 	add.w	r0, r5, #984	; 0x3d8
 8001f86:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001f8a:	f001 fe99 	bl	8003cc0 <chThdCreateStatic>
 8001f8e:	69bb      	ldr	r3, [r7, #24]
 8001f90:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 8001f92:	689a      	ldr	r2, [r3, #8]
 8001f94:	9600      	str	r6, [sp, #0]
 8001f96:	3a05      	subs	r2, #5
 8001f98:	4643      	mov	r3, r8
 8001f9a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001f9e:	f505 60a4 	add.w	r0, r5, #1312	; 0x520
 8001fa2:	f001 fe8d 	bl	8003cc0 <chThdCreateStatic>
 8001fa6:	6120      	str	r0, [r4, #16]
  n = msg_loop_test(threads[0]);
 8001fa8:	6820      	ldr	r0, [r4, #0]
 8001faa:	f004 fba9 	bl	8006700 <msg_loop_test.11383>
 8001fae:	4604      	mov	r4, r0
  test_wait_threads();
 8001fb0:	f7ff ff2e 	bl	8001e10 <test_wait_threads>
  test_print("--- Score : ");
 8001fb4:	480c      	ldr	r0, [pc, #48]	; (8001fe8 <bmk3_execute.11390+0xc8>)
 8001fb6:	f001 fbf3 	bl	80037a0 <test_print>
  test_printn(n);
 8001fba:	4620      	mov	r0, r4
 8001fbc:	f001 fc00 	bl	80037c0 <test_printn>
  test_print(" msgs/S, ");
 8001fc0:	480a      	ldr	r0, [pc, #40]	; (8001fec <bmk3_execute.11390+0xcc>)
 8001fc2:	f001 fbed 	bl	80037a0 <test_print>
  test_printn(n << 1);
 8001fc6:	0060      	lsls	r0, r4, #1
 8001fc8:	f001 fbfa 	bl	80037c0 <test_printn>
  test_println(" ctxswc/S");
 8001fcc:	4808      	ldr	r0, [pc, #32]	; (8001ff0 <bmk3_execute.11390+0xd0>)
}
 8001fce:	b002      	add	sp, #8
 8001fd0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
 8001fd4:	f001 bbcc 	b.w	8003770 <test_println>
 8001fd8:	20001208 	.word	0x20001208
 8001fdc:	20000928 	.word	0x20000928
 8001fe0:	08001c11 	.word	0x08001c11
 8001fe4:	20001358 	.word	0x20001358
 8001fe8:	08006820 	.word	0x08006820
 8001fec:	0800687c 	.word	0x0800687c
 8001ff0:	08006844 	.word	0x08006844
 8001ff4:	08005821 	.word	0x08005821
 8001ff8:	f3af 8000 	nop.w
 8001ffc:	f3af 8000 	nop.w

08002000 <bmk4_execute.11392>:
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
  chSysUnlock();
}

static void bmk4_execute(void) {
 8002000:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002004:	4b25      	ldr	r3, [pc, #148]	; (800209c <bmk4_execute.11392+0x9c>)
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8002006:	4826      	ldr	r0, [pc, #152]	; (80020a0 <bmk4_execute.11392+0xa0>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002008:	699a      	ldr	r2, [r3, #24]
 800200a:	4b26      	ldr	r3, [pc, #152]	; (80020a4 <bmk4_execute.11392+0xa4>)
 800200c:	6892      	ldr	r2, [r2, #8]
 800200e:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 80020b4 <bmk4_execute.11392+0xb4>
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
  chSysUnlock();
}

static void bmk4_execute(void) {
 8002012:	b082      	sub	sp, #8
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8002014:	2500      	movs	r5, #0
 8002016:	3201      	adds	r2, #1
 8002018:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800201c:	9500      	str	r5, [sp, #0]
 800201e:	f001 fe4f 	bl	8003cc0 <chThdCreateStatic>
 8002022:	4b21      	ldr	r3, [pc, #132]	; (80020a8 <bmk4_execute.11392+0xa8>)
 8002024:	4604      	mov	r4, r0
 8002026:	6018      	str	r0, [r3, #0]
                                      thread4, NULL);
  n = 0;
  test_wait_tick();
 8002028:	f002 fdf2 	bl	8004c10 <test_wait_tick>
  test_start_timer(1000);
 800202c:	f002 f9a8 	bl	8004380 <test_start_timer.constprop.2>
  do {
    chSysLock();
    chSchWakeupS(tp, MSG_OK);
 8002030:	46a8      	mov	r8, r5
 8002032:	2720      	movs	r7, #32
 8002034:	2620      	movs	r6, #32
 8002036:	f387 8811 	msr	BASEPRI, r7
 800203a:	2100      	movs	r1, #0
 800203c:	4620      	mov	r0, r4
 800203e:	f001 fdef 	bl	8003c20 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8002042:	4620      	mov	r0, r4
 8002044:	2100      	movs	r1, #0
 8002046:	f001 fdeb 	bl	8003c20 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 800204a:	4620      	mov	r0, r4
 800204c:	2100      	movs	r1, #0
 800204e:	f001 fde7 	bl	8003c20 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8002052:	4620      	mov	r0, r4
 8002054:	2100      	movs	r1, #0
 8002056:	f001 fde3 	bl	8003c20 <chSchWakeupS>
 800205a:	f04f 0a00 	mov.w	sl, #0
 800205e:	f388 8811 	msr	BASEPRI, r8
    chSysUnlock();
    n += 4;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8002062:	f899 3000 	ldrb.w	r3, [r9]
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSysUnlock();
    n += 4;
 8002066:	3504      	adds	r5, #4
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8002068:	2b00      	cmp	r3, #0
 800206a:	d0e3      	beq.n	8002034 <bmk4_execute.11392+0x34>
 800206c:	f386 8811 	msr	BASEPRI, r6
  chSysLock();
  chSchWakeupS(tp, MSG_TIMEOUT);
 8002070:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8002074:	4620      	mov	r0, r4
 8002076:	f001 fdd3 	bl	8003c20 <chSchWakeupS>
 800207a:	f38a 8811 	msr	BASEPRI, sl
  chSysUnlock();

  test_wait_threads();
 800207e:	f7ff fec7 	bl	8001e10 <test_wait_threads>
  test_print("--- Score : ");
 8002082:	480a      	ldr	r0, [pc, #40]	; (80020ac <bmk4_execute.11392+0xac>)
 8002084:	f001 fb8c 	bl	80037a0 <test_print>
  test_printn(n * 2);
 8002088:	0068      	lsls	r0, r5, #1
 800208a:	f001 fb99 	bl	80037c0 <test_printn>
  test_println(" ctxswc/S");
 800208e:	4808      	ldr	r0, [pc, #32]	; (80020b0 <bmk4_execute.11392+0xb0>)
}
 8002090:	b002      	add	sp, #8
 8002092:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  chSysUnlock();

  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n * 2);
  test_println(" ctxswc/S");
 8002096:	f001 bb6b 	b.w	8003770 <test_println>
 800209a:	bf00      	nop
 800209c:	20001208 	.word	0x20001208
 80020a0:	20000928 	.word	0x20000928
 80020a4:	08000361 	.word	0x08000361
 80020a8:	20001358 	.word	0x20001358
 80020ac:	08006820 	.word	0x08006820
 80020b0:	08006844 	.word	0x08006844
 80020b4:	200008c4 	.word	0x200008c4
 80020b8:	f3af 8000 	nop.w
 80020bc:	f3af 8000 	nop.w

080020c0 <bmk8_execute.11402>:
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
}

static void bmk8_execute(void) {
 80020c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80020c4:	b084      	sub	sp, #16
  uint32_t n;

  n = 0;
 80020c6:	ac04      	add	r4, sp, #16
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80020c8:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 8002198 <bmk8_execute.11402+0xd8>
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80020cc:	4f2d      	ldr	r7, [pc, #180]	; (8002184 <bmk8_execute.11402+0xc4>)
 80020ce:	4e2e      	ldr	r6, [pc, #184]	; (8002188 <bmk8_execute.11402+0xc8>)
 80020d0:	4d2e      	ldr	r5, [pc, #184]	; (800218c <bmk8_execute.11402+0xcc>)
}

static void bmk8_execute(void) {
  uint32_t n;

  n = 0;
 80020d2:	2300      	movs	r3, #0
 80020d4:	f844 3d04 	str.w	r3, [r4, #-4]!
  test_wait_tick();
 80020d8:	f002 fd9a 	bl	8004c10 <test_wait_tick>
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80020dc:	f8d8 3018 	ldr.w	r3, [r8, #24]

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80020e0:	689a      	ldr	r2, [r3, #8]
 80020e2:	9400      	str	r4, [sp, #0]
 80020e4:	4633      	mov	r3, r6
 80020e6:	3a01      	subs	r2, #1
 80020e8:	4638      	mov	r0, r7
 80020ea:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80020ee:	f001 fde7 	bl	8003cc0 <chThdCreateStatic>
 80020f2:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80020f6:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80020f8:	689a      	ldr	r2, [r3, #8]
 80020fa:	9400      	str	r4, [sp, #0]
 80020fc:	4633      	mov	r3, r6
 80020fe:	3a01      	subs	r2, #1
 8002100:	f507 70a4 	add.w	r0, r7, #328	; 0x148
 8002104:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002108:	f001 fdda 	bl	8003cc0 <chThdCreateStatic>
 800210c:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8002110:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8002112:	689a      	ldr	r2, [r3, #8]
 8002114:	9400      	str	r4, [sp, #0]
 8002116:	4633      	mov	r3, r6
 8002118:	3a01      	subs	r2, #1
 800211a:	f507 7024 	add.w	r0, r7, #656	; 0x290
 800211e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002122:	f001 fdcd 	bl	8003cc0 <chThdCreateStatic>
 8002126:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800212a:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 800212c:	689a      	ldr	r2, [r3, #8]
 800212e:	9400      	str	r4, [sp, #0]
 8002130:	4633      	mov	r3, r6
 8002132:	3a01      	subs	r2, #1
 8002134:	f507 7076 	add.w	r0, r7, #984	; 0x3d8
 8002138:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800213c:	f001 fdc0 	bl	8003cc0 <chThdCreateStatic>
 8002140:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8002144:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8002146:	689a      	ldr	r2, [r3, #8]
 8002148:	9400      	str	r4, [sp, #0]
 800214a:	3a01      	subs	r2, #1
 800214c:	4633      	mov	r3, r6
 800214e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002152:	f507 60a4 	add.w	r0, r7, #1312	; 0x520
 8002156:	f001 fdb3 	bl	8003cc0 <chThdCreateStatic>
 800215a:	6128      	str	r0, [r5, #16]

  chThdSleepSeconds(1);
 800215c:	f242 7010 	movw	r0, #10000	; 0x2710
 8002160:	f002 fcd6 	bl	8004b10 <chThdSleep>
  test_terminate_threads();
 8002164:	f7fe fcd4 	bl	8000b10 <test_terminate_threads>
  test_wait_threads();
 8002168:	f7ff fe52 	bl	8001e10 <test_wait_threads>

  test_print("--- Score : ");
 800216c:	4808      	ldr	r0, [pc, #32]	; (8002190 <bmk8_execute.11402+0xd0>)
 800216e:	f001 fb17 	bl	80037a0 <test_print>
  test_printn(n);
 8002172:	9803      	ldr	r0, [sp, #12]
 8002174:	f001 fb24 	bl	80037c0 <test_printn>
  test_println(" ctxswc/S");
 8002178:	4806      	ldr	r0, [pc, #24]	; (8002194 <bmk8_execute.11402+0xd4>)
 800217a:	f001 faf9 	bl	8003770 <test_println>
}
 800217e:	b004      	add	sp, #16
 8002180:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002184:	20000928 	.word	0x20000928
 8002188:	08000571 	.word	0x08000571
 800218c:	20001358 	.word	0x20001358
 8002190:	08006820 	.word	0x08006820
 8002194:	08006844 	.word	0x08006844
 8002198:	20001208 	.word	0x20001208
 800219c:	f3af 8000 	nop.w

080021a0 <mtx1_execute.9919>:
  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx1_execute(void) {
 80021a0:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80021a2:	4e28      	ldr	r6, [pc, #160]	; (8002244 <mtx1_execute.9919+0xa4>)

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
 80021a4:	4828      	ldr	r0, [pc, #160]	; (8002248 <mtx1_execute.9919+0xa8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80021a6:	69b3      	ldr	r3, [r6, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80021a8:	4d28      	ldr	r5, [pc, #160]	; (800224c <mtx1_execute.9919+0xac>)
 80021aa:	689c      	ldr	r4, [r3, #8]
  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx1_execute(void) {
 80021ac:	b082      	sub	sp, #8

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
 80021ae:	f001 ff87 	bl	80040c0 <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80021b2:	4b27      	ldr	r3, [pc, #156]	; (8002250 <mtx1_execute.9919+0xb0>)
 80021b4:	9300      	str	r3, [sp, #0]
 80021b6:	1c62      	adds	r2, r4, #1
 80021b8:	4b26      	ldr	r3, [pc, #152]	; (8002254 <mtx1_execute.9919+0xb4>)
 80021ba:	4827      	ldr	r0, [pc, #156]	; (8002258 <mtx1_execute.9919+0xb8>)
 80021bc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80021c0:	f001 fd7e 	bl	8003cc0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80021c4:	4b25      	ldr	r3, [pc, #148]	; (800225c <mtx1_execute.9919+0xbc>)

static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80021c6:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80021c8:	1ca2      	adds	r2, r4, #2
 80021ca:	9300      	str	r3, [sp, #0]
 80021cc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80021d0:	4b20      	ldr	r3, [pc, #128]	; (8002254 <mtx1_execute.9919+0xb4>)
 80021d2:	4823      	ldr	r0, [pc, #140]	; (8002260 <mtx1_execute.9919+0xc0>)
 80021d4:	f001 fd74 	bl	8003cc0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80021d8:	4b22      	ldr	r3, [pc, #136]	; (8002264 <mtx1_execute.9919+0xc4>)
static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80021da:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80021dc:	1ce2      	adds	r2, r4, #3
 80021de:	9300      	str	r3, [sp, #0]
 80021e0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80021e4:	4b1b      	ldr	r3, [pc, #108]	; (8002254 <mtx1_execute.9919+0xb4>)
 80021e6:	4820      	ldr	r0, [pc, #128]	; (8002268 <mtx1_execute.9919+0xc8>)
 80021e8:	f001 fd6a 	bl	8003cc0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 80021ec:	4b1f      	ldr	r3, [pc, #124]	; (800226c <mtx1_execute.9919+0xcc>)

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80021ee:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 80021f0:	1d22      	adds	r2, r4, #4
 80021f2:	9300      	str	r3, [sp, #0]
 80021f4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80021f8:	4b16      	ldr	r3, [pc, #88]	; (8002254 <mtx1_execute.9919+0xb4>)
 80021fa:	481d      	ldr	r0, [pc, #116]	; (8002270 <mtx1_execute.9919+0xd0>)
 80021fc:	f001 fd60 	bl	8003cc0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8002200:	4b1c      	ldr	r3, [pc, #112]	; (8002274 <mtx1_execute.9919+0xd4>)
  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8002202:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8002204:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002208:	1d62      	adds	r2, r4, #5
 800220a:	9300      	str	r3, [sp, #0]
 800220c:	481a      	ldr	r0, [pc, #104]	; (8002278 <mtx1_execute.9919+0xd8>)
 800220e:	4b11      	ldr	r3, [pc, #68]	; (8002254 <mtx1_execute.9919+0xb4>)
 8002210:	f001 fd56 	bl	8003cc0 <chThdCreateStatic>
 8002214:	6128      	str	r0, [r5, #16]
  chMtxUnlock(&m1);
 8002216:	480c      	ldr	r0, [pc, #48]	; (8002248 <mtx1_execute.9919+0xa8>)
 8002218:	f001 feb2 	bl	8003f80 <chMtxUnlock>
  test_wait_threads();
 800221c:	f7ff fdf8 	bl	8001e10 <test_wait_threads>
 8002220:	69b3      	ldr	r3, [r6, #24]
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
 8002222:	6899      	ldr	r1, [r3, #8]
 8002224:	1a63      	subs	r3, r4, r1
 8002226:	4259      	negs	r1, r3
 8002228:	4159      	adcs	r1, r3
 800222a:	2001      	movs	r0, #1
 800222c:	f7fe fcd0 	bl	8000bd0 <_test_assert>
 8002230:	b108      	cbz	r0, 8002236 <mtx1_execute.9919+0x96>
  test_assert_sequence(2, "ABCDE");
}
 8002232:	b002      	add	sp, #8
 8002234:	bd70      	pop	{r4, r5, r6, pc}
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  chMtxUnlock(&m1);
  test_wait_threads();
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
  test_assert_sequence(2, "ABCDE");
 8002236:	4911      	ldr	r1, [pc, #68]	; (800227c <mtx1_execute.9919+0xdc>)
 8002238:	2002      	movs	r0, #2
}
 800223a:	b002      	add	sp, #8
 800223c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  chMtxUnlock(&m1);
  test_wait_threads();
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
  test_assert_sequence(2, "ABCDE");
 8002240:	f7fe bc9e 	b.w	8000b80 <_test_assert_sequence>
 8002244:	20001208 	.word	0x20001208
 8002248:	20000830 	.word	0x20000830
 800224c:	20001358 	.word	0x20001358
 8002250:	0800681c 	.word	0x0800681c
 8002254:	080004e1 	.word	0x080004e1
 8002258:	20000928 	.word	0x20000928
 800225c:	08006888 	.word	0x08006888
 8002260:	20000a70 	.word	0x20000a70
 8002264:	0800688c 	.word	0x0800688c
 8002268:	20000bb8 	.word	0x20000bb8
 800226c:	08006890 	.word	0x08006890
 8002270:	20000d00 	.word	0x20000d00
 8002274:	08006894 	.word	0x08006894
 8002278:	20000e48 	.word	0x20000e48
 800227c:	08006818 	.word	0x08006818

08002280 <mtx4_execute.9927>:
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static void mtx4_execute(void) {
 8002280:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002284:	4d8a      	ldr	r5, [pc, #552]	; (80024b0 <mtx4_execute.9927+0x230>)
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8002286:	4a8b      	ldr	r2, [pc, #556]	; (80024b4 <mtx4_execute.9927+0x234>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002288:	69ab      	ldr	r3, [r5, #24]
 800228a:	488b      	ldr	r0, [pc, #556]	; (80024b8 <mtx4_execute.9927+0x238>)
 800228c:	689c      	ldr	r4, [r3, #8]
 800228e:	4b8b      	ldr	r3, [pc, #556]	; (80024bc <mtx4_execute.9927+0x23c>)
 8002290:	4e8b      	ldr	r6, [pc, #556]	; (80024c0 <mtx4_execute.9927+0x240>)
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static void mtx4_execute(void) {
 8002292:	b082      	sub	sp, #8
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
 8002294:	1c67      	adds	r7, r4, #1
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8002296:	9200      	str	r2, [sp, #0]
 8002298:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800229c:	463a      	mov	r2, r7
 800229e:	f001 fd0f 	bl	8003cc0 <chThdCreateStatic>
static void mtx4_execute(void) {
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
 80022a2:	f104 0802 	add.w	r8, r4, #2
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 80022a6:	4b87      	ldr	r3, [pc, #540]	; (80024c4 <mtx4_execute.9927+0x244>)
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 80022a8:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 80022aa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80022ae:	4642      	mov	r2, r8
 80022b0:	9300      	str	r3, [sp, #0]
 80022b2:	4885      	ldr	r0, [pc, #532]	; (80024c8 <mtx4_execute.9927+0x248>)
 80022b4:	4b85      	ldr	r3, [pc, #532]	; (80024cc <mtx4_execute.9927+0x24c>)
 80022b6:	f001 fd03 	bl	8003cc0 <chThdCreateStatic>
 80022ba:	6070      	str	r0, [r6, #4]
  chMtxLock(&m2);
 80022bc:	4884      	ldr	r0, [pc, #528]	; (80024d0 <mtx4_execute.9927+0x250>)
 80022be:	f001 feff 	bl	80040c0 <chMtxLock>
 80022c2:	69ab      	ldr	r3, [r5, #24]
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
 80022c4:	6899      	ldr	r1, [r3, #8]
 80022c6:	1a63      	subs	r3, r4, r1
 80022c8:	4259      	negs	r1, r3
 80022ca:	4159      	adcs	r1, r3
 80022cc:	2001      	movs	r0, #1
 80022ce:	f7fe fc7f 	bl	8000bd0 <_test_assert>
 80022d2:	b110      	cbz	r0, 80022da <mtx4_execute.9927+0x5a>
  chThdSleepMilliseconds(100);
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
  chMtxUnlockAll();
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();
}
 80022d4:	b002      	add	sp, #8
 80022d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
  chMtxLock(&m2);
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
  chThdSleepMilliseconds(100);
 80022da:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80022de:	f002 fc17 	bl	8004b10 <chThdSleep>
 80022e2:	69ab      	ldr	r3, [r5, #24]
  test_assert(2, chThdGetPriorityX() == p1, "wrong priority level");
 80022e4:	6899      	ldr	r1, [r3, #8]
 80022e6:	ebb7 0c01 	subs.w	ip, r7, r1
 80022ea:	f1dc 0100 	rsbs	r1, ip, #0
 80022ee:	eb51 010c 	adcs.w	r1, r1, ip
 80022f2:	2002      	movs	r0, #2
 80022f4:	f7fe fc6c 	bl	8000bd0 <_test_assert>
 80022f8:	2800      	cmp	r0, #0
 80022fa:	d1eb      	bne.n	80022d4 <mtx4_execute.9927+0x54>
  chMtxLock(&m1);
 80022fc:	4875      	ldr	r0, [pc, #468]	; (80024d4 <mtx4_execute.9927+0x254>)
 80022fe:	f001 fedf 	bl	80040c0 <chMtxLock>
 8002302:	69ab      	ldr	r3, [r5, #24]
  test_assert(3, chThdGetPriorityX() == p1, "wrong priority level");
 8002304:	6899      	ldr	r1, [r3, #8]
 8002306:	ebb7 0e01 	subs.w	lr, r7, r1
 800230a:	f1de 0100 	rsbs	r1, lr, #0
 800230e:	eb51 010e 	adcs.w	r1, r1, lr
 8002312:	2003      	movs	r0, #3
 8002314:	f7fe fc5c 	bl	8000bd0 <_test_assert>
 8002318:	2800      	cmp	r0, #0
 800231a:	d1db      	bne.n	80022d4 <mtx4_execute.9927+0x54>
  chThdSleepMilliseconds(100);
 800231c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002320:	f002 fbf6 	bl	8004b10 <chThdSleep>
 8002324:	69ab      	ldr	r3, [r5, #24]
  test_assert(4, chThdGetPriorityX() == p2, "wrong priority level");
 8002326:	6899      	ldr	r1, [r3, #8]
 8002328:	ebb8 0201 	subs.w	r2, r8, r1
 800232c:	4251      	negs	r1, r2
 800232e:	4151      	adcs	r1, r2
 8002330:	2004      	movs	r0, #4
 8002332:	f7fe fc4d 	bl	8000bd0 <_test_assert>
 8002336:	2800      	cmp	r0, #0
 8002338:	d1cc      	bne.n	80022d4 <mtx4_execute.9927+0x54>
  chMtxUnlock(&m1);
 800233a:	4866      	ldr	r0, [pc, #408]	; (80024d4 <mtx4_execute.9927+0x254>)
 800233c:	f001 fe20 	bl	8003f80 <chMtxUnlock>
 8002340:	69ab      	ldr	r3, [r5, #24]
  test_assert(5, chThdGetPriorityX() == p1, "wrong priority level");
 8002342:	6899      	ldr	r1, [r3, #8]
 8002344:	1a7b      	subs	r3, r7, r1
 8002346:	4259      	negs	r1, r3
 8002348:	4159      	adcs	r1, r3
 800234a:	2005      	movs	r0, #5
 800234c:	f7fe fc40 	bl	8000bd0 <_test_assert>
 8002350:	2800      	cmp	r0, #0
 8002352:	d1bf      	bne.n	80022d4 <mtx4_execute.9927+0x54>
  chThdSleepMilliseconds(100);
 8002354:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002358:	f002 fbda 	bl	8004b10 <chThdSleep>
 800235c:	69ab      	ldr	r3, [r5, #24]
  test_assert(6, chThdGetPriorityX() == p1, "wrong priority level");
 800235e:	6899      	ldr	r1, [r3, #8]
 8002360:	ebb7 0c01 	subs.w	ip, r7, r1
 8002364:	f1dc 0100 	rsbs	r1, ip, #0
 8002368:	eb51 010c 	adcs.w	r1, r1, ip
 800236c:	2006      	movs	r0, #6
 800236e:	f7fe fc2f 	bl	8000bd0 <_test_assert>
 8002372:	2800      	cmp	r0, #0
 8002374:	d1ae      	bne.n	80022d4 <mtx4_execute.9927+0x54>
  chMtxUnlockAll();
 8002376:	f001 fdab 	bl	8003ed0 <chMtxUnlockAll>
 800237a:	69ab      	ldr	r3, [r5, #24]
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
 800237c:	6899      	ldr	r1, [r3, #8]
 800237e:	ebb4 0e01 	subs.w	lr, r4, r1
 8002382:	f1de 0100 	rsbs	r1, lr, #0
 8002386:	eb51 010e 	adcs.w	r1, r1, lr
 800238a:	2007      	movs	r0, #7
 800238c:	f7fe fc20 	bl	8000bd0 <_test_assert>
 8002390:	2800      	cmp	r0, #0
 8002392:	d19f      	bne.n	80022d4 <mtx4_execute.9927+0x54>
  test_wait_threads();
 8002394:	f7ff fd3c 	bl	8001e10 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 8002398:	4b4f      	ldr	r3, [pc, #316]	; (80024d8 <mtx4_execute.9927+0x258>)
 800239a:	9300      	str	r3, [sp, #0]
 800239c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80023a0:	4b46      	ldr	r3, [pc, #280]	; (80024bc <mtx4_execute.9927+0x23c>)
 80023a2:	4845      	ldr	r0, [pc, #276]	; (80024b8 <mtx4_execute.9927+0x238>)
 80023a4:	463a      	mov	r2, r7
 80023a6:	f001 fc8b 	bl	8003cc0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 80023aa:	4b4c      	ldr	r3, [pc, #304]	; (80024dc <mtx4_execute.9927+0x25c>)
  chMtxUnlockAll();
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 80023ac:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 80023ae:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80023b2:	4642      	mov	r2, r8
 80023b4:	9300      	str	r3, [sp, #0]
 80023b6:	4844      	ldr	r0, [pc, #272]	; (80024c8 <mtx4_execute.9927+0x248>)
 80023b8:	4b44      	ldr	r3, [pc, #272]	; (80024cc <mtx4_execute.9927+0x24c>)
 80023ba:	f001 fc81 	bl	8003cc0 <chThdCreateStatic>
 80023be:	6070      	str	r0, [r6, #4]
  chMtxLock(&m2);
 80023c0:	4843      	ldr	r0, [pc, #268]	; (80024d0 <mtx4_execute.9927+0x250>)
 80023c2:	f001 fe7d 	bl	80040c0 <chMtxLock>
 80023c6:	69ab      	ldr	r3, [r5, #24]
  test_assert(8, chThdGetPriorityX() == p, "wrong priority level");
 80023c8:	6899      	ldr	r1, [r3, #8]
 80023ca:	1a62      	subs	r2, r4, r1
 80023cc:	4251      	negs	r1, r2
 80023ce:	4151      	adcs	r1, r2
 80023d0:	2008      	movs	r0, #8
 80023d2:	f7fe fbfd 	bl	8000bd0 <_test_assert>
 80023d6:	2800      	cmp	r0, #0
 80023d8:	f47f af7c 	bne.w	80022d4 <mtx4_execute.9927+0x54>
  chThdSleepMilliseconds(100);
 80023dc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80023e0:	f002 fb96 	bl	8004b10 <chThdSleep>
 80023e4:	69ab      	ldr	r3, [r5, #24]
  test_assert(9, chThdGetPriorityX() == p1, "wrong priority level");
 80023e6:	6899      	ldr	r1, [r3, #8]
 80023e8:	1a7b      	subs	r3, r7, r1
 80023ea:	4259      	negs	r1, r3
 80023ec:	4159      	adcs	r1, r3
 80023ee:	2009      	movs	r0, #9
 80023f0:	f7fe fbee 	bl	8000bd0 <_test_assert>
 80023f4:	2800      	cmp	r0, #0
 80023f6:	f47f af6d 	bne.w	80022d4 <mtx4_execute.9927+0x54>
  chMtxLock(&m1);
 80023fa:	4836      	ldr	r0, [pc, #216]	; (80024d4 <mtx4_execute.9927+0x254>)
 80023fc:	f001 fe60 	bl	80040c0 <chMtxLock>
 8002400:	69ab      	ldr	r3, [r5, #24]
  test_assert(10, chThdGetPriorityX() == p1, "wrong priority level");
 8002402:	6899      	ldr	r1, [r3, #8]
 8002404:	ebb7 0c01 	subs.w	ip, r7, r1
 8002408:	f1dc 0100 	rsbs	r1, ip, #0
 800240c:	eb51 010c 	adcs.w	r1, r1, ip
 8002410:	200a      	movs	r0, #10
 8002412:	f7fe fbdd 	bl	8000bd0 <_test_assert>
 8002416:	2800      	cmp	r0, #0
 8002418:	f47f af5c 	bne.w	80022d4 <mtx4_execute.9927+0x54>
  chThdSleepMilliseconds(100);
 800241c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002420:	f002 fb76 	bl	8004b10 <chThdSleep>
 8002424:	69ab      	ldr	r3, [r5, #24]
  test_assert(11, chThdGetPriorityX() == p2, "wrong priority level");
 8002426:	6899      	ldr	r1, [r3, #8]
 8002428:	ebb8 0e01 	subs.w	lr, r8, r1
 800242c:	f1de 0100 	rsbs	r1, lr, #0
 8002430:	f04f 000b 	mov.w	r0, #11
 8002434:	eb51 010e 	adcs.w	r1, r1, lr
 8002438:	f7fe fbca 	bl	8000bd0 <_test_assert>
 800243c:	4606      	mov	r6, r0
 800243e:	2800      	cmp	r0, #0
 8002440:	f47f af48 	bne.w	80022d4 <mtx4_execute.9927+0x54>
 8002444:	2320      	movs	r3, #32
 8002446:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chMtxUnlockS(&m1);
 800244a:	4822      	ldr	r0, [pc, #136]	; (80024d4 <mtx4_execute.9927+0x254>)
 800244c:	f001 fd70 	bl	8003f30 <chMtxUnlockS>
  chSchRescheduleS();
 8002450:	f001 fbae 	bl	8003bb0 <chSchRescheduleS>
 8002454:	f386 8811 	msr	BASEPRI, r6
 8002458:	69ab      	ldr	r3, [r5, #24]
  chSysUnlock();
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
 800245a:	6899      	ldr	r1, [r3, #8]
 800245c:	1a7e      	subs	r6, r7, r1
 800245e:	4271      	negs	r1, r6
 8002460:	4171      	adcs	r1, r6
 8002462:	200c      	movs	r0, #12
 8002464:	f7fe fbb4 	bl	8000bd0 <_test_assert>
 8002468:	2800      	cmp	r0, #0
 800246a:	f47f af33 	bne.w	80022d4 <mtx4_execute.9927+0x54>
  chThdSleepMilliseconds(100);
 800246e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002472:	f002 fb4d 	bl	8004b10 <chThdSleep>
 8002476:	69ab      	ldr	r3, [r5, #24]
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
 8002478:	6899      	ldr	r1, [r3, #8]
 800247a:	1a7a      	subs	r2, r7, r1
 800247c:	4251      	negs	r1, r2
 800247e:	4151      	adcs	r1, r2
 8002480:	200d      	movs	r0, #13
 8002482:	f7fe fba5 	bl	8000bd0 <_test_assert>
 8002486:	2800      	cmp	r0, #0
 8002488:	f47f af24 	bne.w	80022d4 <mtx4_execute.9927+0x54>
  chMtxUnlockAll();
 800248c:	f001 fd20 	bl	8003ed0 <chMtxUnlockAll>
 8002490:	69ab      	ldr	r3, [r5, #24]
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
 8002492:	6899      	ldr	r1, [r3, #8]
 8002494:	1a63      	subs	r3, r4, r1
 8002496:	4259      	negs	r1, r3
 8002498:	4159      	adcs	r1, r3
 800249a:	200e      	movs	r0, #14
 800249c:	f7fe fb98 	bl	8000bd0 <_test_assert>
 80024a0:	2800      	cmp	r0, #0
 80024a2:	f47f af17 	bne.w	80022d4 <mtx4_execute.9927+0x54>
  test_wait_threads();
}
 80024a6:	b002      	add	sp, #8
 80024a8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
  chThdSleepMilliseconds(100);
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
  chMtxUnlockAll();
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();
 80024ac:	f7ff bcb0 	b.w	8001e10 <test_wait_threads>
 80024b0:	20001208 	.word	0x20001208
 80024b4:	08006890 	.word	0x08006890
 80024b8:	20000928 	.word	0x20000928
 80024bc:	08004bc1 	.word	0x08004bc1
 80024c0:	20001358 	.word	0x20001358
 80024c4:	08006894 	.word	0x08006894
 80024c8:	20000a70 	.word	0x20000a70
 80024cc:	08004ba1 	.word	0x08004ba1
 80024d0:	20000820 	.word	0x20000820
 80024d4:	20000830 	.word	0x20000830
 80024d8:	08006888 	.word	0x08006888
 80024dc:	0800688c 	.word	0x0800688c

080024e0 <mtx6_execute.9931>:
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx6_execute(void) {
 80024e0:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80024e2:	4b2c      	ldr	r3, [pc, #176]	; (8002594 <mtx6_execute.9931+0xb4>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 80024e4:	4e2c      	ldr	r6, [pc, #176]	; (8002598 <mtx6_execute.9931+0xb8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80024e6:	699b      	ldr	r3, [r3, #24]
 80024e8:	4d2c      	ldr	r5, [pc, #176]	; (800259c <mtx6_execute.9931+0xbc>)
 80024ea:	689f      	ldr	r7, [r3, #8]
 80024ec:	4b2c      	ldr	r3, [pc, #176]	; (80025a0 <mtx6_execute.9931+0xc0>)
 80024ee:	4c2d      	ldr	r4, [pc, #180]	; (80025a4 <mtx6_execute.9931+0xc4>)
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx6_execute(void) {
 80024f0:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 80024f2:	1c7a      	adds	r2, r7, #1
 80024f4:	9300      	str	r3, [sp, #0]
 80024f6:	4630      	mov	r0, r6
 80024f8:	462b      	mov	r3, r5
 80024fa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80024fe:	f001 fbdf 	bl	8003cc0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8002502:	4929      	ldr	r1, [pc, #164]	; (80025a8 <mtx6_execute.9931+0xc8>)
}

static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8002504:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8002506:	1cba      	adds	r2, r7, #2
 8002508:	462b      	mov	r3, r5
 800250a:	9100      	str	r1, [sp, #0]
 800250c:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 8002510:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002514:	f001 fbd4 	bl	8003cc0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8002518:	4924      	ldr	r1, [pc, #144]	; (80025ac <mtx6_execute.9931+0xcc>)

static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 800251a:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 800251c:	1cfa      	adds	r2, r7, #3
 800251e:	462b      	mov	r3, r5
 8002520:	9100      	str	r1, [sp, #0]
 8002522:	f506 7024 	add.w	r0, r6, #656	; 0x290
 8002526:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800252a:	f001 fbc9 	bl	8003cc0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800252e:	4920      	ldr	r1, [pc, #128]	; (80025b0 <mtx6_execute.9931+0xd0>)
static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8002530:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8002532:	1d3a      	adds	r2, r7, #4
 8002534:	462b      	mov	r3, r5
 8002536:	9100      	str	r1, [sp, #0]
 8002538:	f506 7076 	add.w	r0, r6, #984	; 0x3d8
 800253c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002540:	f001 fbbe 	bl	8003cc0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8002544:	491b      	ldr	r1, [pc, #108]	; (80025b4 <mtx6_execute.9931+0xd4>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8002546:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8002548:	462b      	mov	r3, r5
 800254a:	9100      	str	r1, [sp, #0]
 800254c:	1d7a      	adds	r2, r7, #5
 800254e:	f506 60a4 	add.w	r0, r6, #1312	; 0x520
 8002552:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002556:	f001 fbb3 	bl	8003cc0 <chThdCreateStatic>
 800255a:	2320      	movs	r3, #32
 800255c:	6120      	str	r0, [r4, #16]
 800255e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chCondSignalI(&c1);
 8002562:	f7fe f975 	bl	8000850 <chCondSignalI.constprop.44>
  chCondSignalI(&c1);
 8002566:	f7fe f973 	bl	8000850 <chCondSignalI.constprop.44>
  chCondSignalI(&c1);
 800256a:	f7fe f971 	bl	8000850 <chCondSignalI.constprop.44>
  chCondSignalI(&c1);
 800256e:	f7fe f96f 	bl	8000850 <chCondSignalI.constprop.44>
  chCondSignalI(&c1);
 8002572:	f7fe f96d 	bl	8000850 <chCondSignalI.constprop.44>
  chSchRescheduleS();
 8002576:	f001 fb1b 	bl	8003bb0 <chSchRescheduleS>
 800257a:	2300      	movs	r3, #0
 800257c:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  test_wait_threads();
 8002580:	f7ff fc46 	bl	8001e10 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8002584:	490c      	ldr	r1, [pc, #48]	; (80025b8 <mtx6_execute.9931+0xd8>)
 8002586:	2001      	movs	r0, #1
}
 8002588:	b003      	add	sp, #12
 800258a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  chCondSignalI(&c1);
  chCondSignalI(&c1);
  chSchRescheduleS();
  chSysUnlock();
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 800258e:	f7fe baf7 	b.w	8000b80 <_test_assert_sequence>
 8002592:	bf00      	nop
 8002594:	20001208 	.word	0x20001208
 8002598:	20000928 	.word	0x20000928
 800259c:	08000501 	.word	0x08000501
 80025a0:	0800681c 	.word	0x0800681c
 80025a4:	20001358 	.word	0x20001358
 80025a8:	08006888 	.word	0x08006888
 80025ac:	0800688c 	.word	0x0800688c
 80025b0:	08006890 	.word	0x08006890
 80025b4:	08006894 	.word	0x08006894
 80025b8:	08006818 	.word	0x08006818
 80025bc:	f3af 8000 	nop.w

080025c0 <mtx7_execute.9939>:

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void mtx7_execute(void) {
 80025c0:	b530      	push	{r4, r5, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80025c2:	4b2c      	ldr	r3, [pc, #176]	; (8002674 <mtx7_execute.9939+0xb4>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 80025c4:	4a2c      	ldr	r2, [pc, #176]	; (8002678 <mtx7_execute.9939+0xb8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80025c6:	699b      	ldr	r3, [r3, #24]
 80025c8:	482c      	ldr	r0, [pc, #176]	; (800267c <mtx7_execute.9939+0xbc>)
 80025ca:	689d      	ldr	r5, [r3, #8]
 80025cc:	4b2c      	ldr	r3, [pc, #176]	; (8002680 <mtx7_execute.9939+0xc0>)
 80025ce:	4c2d      	ldr	r4, [pc, #180]	; (8002684 <mtx7_execute.9939+0xc4>)

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void mtx7_execute(void) {
 80025d0:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 80025d2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80025d6:	9200      	str	r2, [sp, #0]
 80025d8:	1c6a      	adds	r2, r5, #1
 80025da:	f001 fb71 	bl	8003cc0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 80025de:	4b2a      	ldr	r3, [pc, #168]	; (8002688 <mtx7_execute.9939+0xc8>)
}

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 80025e0:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 80025e2:	1caa      	adds	r2, r5, #2
 80025e4:	9300      	str	r3, [sp, #0]
 80025e6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80025ea:	4b25      	ldr	r3, [pc, #148]	; (8002680 <mtx7_execute.9939+0xc0>)
 80025ec:	4827      	ldr	r0, [pc, #156]	; (800268c <mtx7_execute.9939+0xcc>)
 80025ee:	f001 fb67 	bl	8003cc0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 80025f2:	4b27      	ldr	r3, [pc, #156]	; (8002690 <mtx7_execute.9939+0xd0>)

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 80025f4:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 80025f6:	1cea      	adds	r2, r5, #3
 80025f8:	9300      	str	r3, [sp, #0]
 80025fa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80025fe:	4b20      	ldr	r3, [pc, #128]	; (8002680 <mtx7_execute.9939+0xc0>)
 8002600:	4824      	ldr	r0, [pc, #144]	; (8002694 <mtx7_execute.9939+0xd4>)
 8002602:	f001 fb5d 	bl	8003cc0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8002606:	4b24      	ldr	r3, [pc, #144]	; (8002698 <mtx7_execute.9939+0xd8>)
static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8002608:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800260a:	1d2a      	adds	r2, r5, #4
 800260c:	9300      	str	r3, [sp, #0]
 800260e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002612:	4b1b      	ldr	r3, [pc, #108]	; (8002680 <mtx7_execute.9939+0xc0>)
 8002614:	4821      	ldr	r0, [pc, #132]	; (800269c <mtx7_execute.9939+0xdc>)
 8002616:	f001 fb53 	bl	8003cc0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 800261a:	4b21      	ldr	r3, [pc, #132]	; (80026a0 <mtx7_execute.9939+0xe0>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800261c:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 800261e:	1d6a      	adds	r2, r5, #5
 8002620:	9300      	str	r3, [sp, #0]
 8002622:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002626:	4b16      	ldr	r3, [pc, #88]	; (8002680 <mtx7_execute.9939+0xc0>)
 8002628:	481e      	ldr	r0, [pc, #120]	; (80026a4 <mtx7_execute.9939+0xe4>)
 800262a:	f001 fb49 	bl	8003cc0 <chThdCreateStatic>
 800262e:	2320      	movs	r3, #32
 8002630:	6120      	str	r0, [r4, #16]
 8002632:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002636:	4c1c      	ldr	r4, [pc, #112]	; (80026a8 <mtx7_execute.9939+0xe8>)
 8002638:	6823      	ldr	r3, [r4, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 800263a:	42a3      	cmp	r3, r4
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 800263c:	bf18      	it	ne
 800263e:	f06f 0501 	mvnne.w	r5, #1
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8002642:	d009      	beq.n	8002658 <mtx7_execute.9939+0x98>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8002644:	681a      	ldr	r2, [r3, #0]
 8002646:	6022      	str	r2, [r4, #0]
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 8002648:	4618      	mov	r0, r3
  tqp->p_next->p_prev = (thread_t *)tqp;
 800264a:	6054      	str	r4, [r2, #4]
 800264c:	f001 fbd8 	bl	8003e00 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002650:	6823      	ldr	r3, [r4, #0]
 8002652:	6205      	str	r5, [r0, #32]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8002654:	42a3      	cmp	r3, r4
 8002656:	d1f5      	bne.n	8002644 <mtx7_execute.9939+0x84>
 */
void chCondBroadcast(condition_variable_t *cp) {

  chSysLock();
  chCondBroadcastI(cp);
  chSchRescheduleS();
 8002658:	f001 faaa 	bl	8003bb0 <chSchRescheduleS>
 800265c:	2300      	movs	r3, #0
 800265e:	f383 8811 	msr	BASEPRI, r3
  chCondBroadcast(&c1);
  test_wait_threads();
 8002662:	f7ff fbd5 	bl	8001e10 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8002666:	4911      	ldr	r1, [pc, #68]	; (80026ac <mtx7_execute.9939+0xec>)
 8002668:	2001      	movs	r0, #1
}
 800266a:	b003      	add	sp, #12
 800266c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
  chCondBroadcast(&c1);
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 8002670:	f7fe ba86 	b.w	8000b80 <_test_assert_sequence>
 8002674:	20001208 	.word	0x20001208
 8002678:	0800681c 	.word	0x0800681c
 800267c:	20000928 	.word	0x20000928
 8002680:	08000501 	.word	0x08000501
 8002684:	20001358 	.word	0x20001358
 8002688:	08006888 	.word	0x08006888
 800268c:	20000a70 	.word	0x20000a70
 8002690:	0800688c 	.word	0x0800688c
 8002694:	20000bb8 	.word	0x20000bb8
 8002698:	08006890 	.word	0x08006890
 800269c:	20000d00 	.word	0x20000d00
 80026a0:	08006894 	.word	0x08006894
 80026a4:	20000e48 	.word	0x20000e48
 80026a8:	20000818 	.word	0x20000818
 80026ac:	08006818 	.word	0x08006818

080026b0 <mtx8_execute.9941>:
  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
}

static void mtx8_execute(void) {
 80026b0:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80026b2:	4b19      	ldr	r3, [pc, #100]	; (8002718 <mtx8_execute.9941+0x68>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 80026b4:	4d19      	ldr	r5, [pc, #100]	; (800271c <mtx8_execute.9941+0x6c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80026b6:	699b      	ldr	r3, [r3, #24]
 80026b8:	4a19      	ldr	r2, [pc, #100]	; (8002720 <mtx8_execute.9941+0x70>)
 80026ba:	689e      	ldr	r6, [r3, #8]
 80026bc:	4b19      	ldr	r3, [pc, #100]	; (8002724 <mtx8_execute.9941+0x74>)
 80026be:	4c1a      	ldr	r4, [pc, #104]	; (8002728 <mtx8_execute.9941+0x78>)
  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
}

static void mtx8_execute(void) {
 80026c0:	b082      	sub	sp, #8

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 80026c2:	4628      	mov	r0, r5
 80026c4:	9200      	str	r2, [sp, #0]
 80026c6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80026ca:	1c72      	adds	r2, r6, #1
 80026cc:	f001 faf8 	bl	8003cc0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 80026d0:	4b16      	ldr	r3, [pc, #88]	; (800272c <mtx8_execute.9941+0x7c>)
}

static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 80026d2:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 80026d4:	1cb2      	adds	r2, r6, #2
 80026d6:	9300      	str	r3, [sp, #0]
 80026d8:	f505 70a4 	add.w	r0, r5, #328	; 0x148
 80026dc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80026e0:	4b13      	ldr	r3, [pc, #76]	; (8002730 <mtx8_execute.9941+0x80>)
 80026e2:	f001 faed 	bl	8003cc0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 80026e6:	4b13      	ldr	r3, [pc, #76]	; (8002734 <mtx8_execute.9941+0x84>)

static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 80026e8:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 80026ea:	1cf2      	adds	r2, r6, #3
 80026ec:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80026f0:	9300      	str	r3, [sp, #0]
 80026f2:	f505 7024 	add.w	r0, r5, #656	; 0x290
 80026f6:	4b10      	ldr	r3, [pc, #64]	; (8002738 <mtx8_execute.9941+0x88>)
 80026f8:	f001 fae2 	bl	8003cc0 <chThdCreateStatic>
 80026fc:	60a0      	str	r0, [r4, #8]
  chCondSignal(&c1);
 80026fe:	f7fe f88f 	bl	8000820 <chCondSignal.constprop.45>
  chCondSignal(&c1);
 8002702:	f7fe f88d 	bl	8000820 <chCondSignal.constprop.45>
  test_wait_threads();
 8002706:	f7ff fb83 	bl	8001e10 <test_wait_threads>
  test_assert_sequence(1, "ABC");
 800270a:	490c      	ldr	r1, [pc, #48]	; (800273c <mtx8_execute.9941+0x8c>)
 800270c:	2001      	movs	r0, #1
}
 800270e:	b002      	add	sp, #8
 8002710:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
  chCondSignal(&c1);
  chCondSignal(&c1);
  test_wait_threads();
  test_assert_sequence(1, "ABC");
 8002714:	f7fe ba34 	b.w	8000b80 <_test_assert_sequence>
 8002718:	20001208 	.word	0x20001208
 800271c:	20000928 	.word	0x20000928
 8002720:	08006894 	.word	0x08006894
 8002724:	08006351 	.word	0x08006351
 8002728:	20001358 	.word	0x20001358
 800272c:	0800688c 	.word	0x0800688c
 8002730:	08000501 	.word	0x08000501
 8002734:	08006890 	.word	0x08006890
 8002738:	080004c1 	.word	0x080004c1
 800273c:	08006850 	.word	0x08006850

08002740 <sem1_execute.9662>:

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 8002740:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002742:	4d47      	ldr	r5, [pc, #284]	; (8002860 <sem1_execute.9662+0x120>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8002744:	4e47      	ldr	r6, [pc, #284]	; (8002864 <sem1_execute.9662+0x124>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002746:	69ab      	ldr	r3, [r5, #24]
 8002748:	4847      	ldr	r0, [pc, #284]	; (8002868 <sem1_execute.9662+0x128>)
 800274a:	689a      	ldr	r2, [r3, #8]
 800274c:	4b47      	ldr	r3, [pc, #284]	; (800286c <sem1_execute.9662+0x12c>)
 800274e:	4c48      	ldr	r4, [pc, #288]	; (8002870 <sem1_execute.9662+0x130>)

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 8002750:	b083      	sub	sp, #12

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8002752:	3205      	adds	r2, #5
 8002754:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002758:	9600      	str	r6, [sp, #0]
 800275a:	f001 fab1 	bl	8003cc0 <chThdCreateStatic>
 800275e:	69ab      	ldr	r3, [r5, #24]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8002760:	689a      	ldr	r2, [r3, #8]
 8002762:	4b44      	ldr	r3, [pc, #272]	; (8002874 <sem1_execute.9662+0x134>)
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8002764:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8002766:	3201      	adds	r2, #1
 8002768:	9300      	str	r3, [sp, #0]
 800276a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800276e:	4b3f      	ldr	r3, [pc, #252]	; (800286c <sem1_execute.9662+0x12c>)
 8002770:	4841      	ldr	r0, [pc, #260]	; (8002878 <sem1_execute.9662+0x138>)
 8002772:	f001 faa5 	bl	8003cc0 <chThdCreateStatic>
 8002776:	69ab      	ldr	r3, [r5, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8002778:	4940      	ldr	r1, [pc, #256]	; (800287c <sem1_execute.9662+0x13c>)
 800277a:	689a      	ldr	r2, [r3, #8]
}

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800277c:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 800277e:	3203      	adds	r2, #3
 8002780:	9100      	str	r1, [sp, #0]
 8002782:	4b3a      	ldr	r3, [pc, #232]	; (800286c <sem1_execute.9662+0x12c>)
 8002784:	483e      	ldr	r0, [pc, #248]	; (8002880 <sem1_execute.9662+0x140>)
 8002786:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800278a:	f001 fa99 	bl	8003cc0 <chThdCreateStatic>
 800278e:	69ab      	ldr	r3, [r5, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8002790:	493c      	ldr	r1, [pc, #240]	; (8002884 <sem1_execute.9662+0x144>)
 8002792:	689a      	ldr	r2, [r3, #8]

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8002794:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8002796:	3204      	adds	r2, #4
 8002798:	9100      	str	r1, [sp, #0]
 800279a:	4b34      	ldr	r3, [pc, #208]	; (800286c <sem1_execute.9662+0x12c>)
 800279c:	483a      	ldr	r0, [pc, #232]	; (8002888 <sem1_execute.9662+0x148>)
 800279e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80027a2:	f001 fa8d 	bl	8003cc0 <chThdCreateStatic>
 80027a6:	69ab      	ldr	r3, [r5, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80027a8:	4938      	ldr	r1, [pc, #224]	; (800288c <sem1_execute.9662+0x14c>)
 80027aa:	689a      	ldr	r2, [r3, #8]
 80027ac:	4b2f      	ldr	r3, [pc, #188]	; (800286c <sem1_execute.9662+0x12c>)
static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 80027ae:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80027b0:	3202      	adds	r2, #2
 80027b2:	9100      	str	r1, [sp, #0]
 80027b4:	4836      	ldr	r0, [pc, #216]	; (8002890 <sem1_execute.9662+0x150>)
 80027b6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80027ba:	f001 fa81 	bl	8003cc0 <chThdCreateStatic>
 80027be:	6120      	str	r0, [r4, #16]
  chSemSignal(&sem1);
 80027c0:	4834      	ldr	r0, [pc, #208]	; (8002894 <sem1_execute.9662+0x154>)
 80027c2:	f001 fa5d 	bl	8003c80 <chSemSignal>
  chSemSignal(&sem1);
 80027c6:	4833      	ldr	r0, [pc, #204]	; (8002894 <sem1_execute.9662+0x154>)
 80027c8:	f001 fa5a 	bl	8003c80 <chSemSignal>
  chSemSignal(&sem1);
 80027cc:	4831      	ldr	r0, [pc, #196]	; (8002894 <sem1_execute.9662+0x154>)
 80027ce:	f001 fa57 	bl	8003c80 <chSemSignal>
  chSemSignal(&sem1);
 80027d2:	4830      	ldr	r0, [pc, #192]	; (8002894 <sem1_execute.9662+0x154>)
 80027d4:	f001 fa54 	bl	8003c80 <chSemSignal>
  chSemSignal(&sem1);
 80027d8:	482e      	ldr	r0, [pc, #184]	; (8002894 <sem1_execute.9662+0x154>)
 80027da:	f001 fa51 	bl	8003c80 <chSemSignal>
  test_wait_threads();
 80027de:	f7ff fb17 	bl	8001e10 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
 80027e2:	2001      	movs	r0, #1
 80027e4:	492c      	ldr	r1, [pc, #176]	; (8002898 <sem1_execute.9662+0x158>)
 80027e6:	f7fe f9cb 	bl	8000b80 <_test_assert_sequence>
 80027ea:	4607      	mov	r7, r0
 80027ec:	b108      	cbz	r0, 80027f2 <sem1_execute.9662+0xb2>
  chSemAddCounterI(&sem1, 2);
  chSchRescheduleS();
  chSysUnlock();
  test_wait_threads();
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
}
 80027ee:	b003      	add	sp, #12
 80027f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80027f2:	69ab      	ldr	r3, [r5, #24]
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80027f4:	481c      	ldr	r0, [pc, #112]	; (8002868 <sem1_execute.9662+0x128>)
 80027f6:	689a      	ldr	r2, [r3, #8]
 80027f8:	4b1c      	ldr	r3, [pc, #112]	; (800286c <sem1_execute.9662+0x12c>)
 80027fa:	9600      	str	r6, [sp, #0]
 80027fc:	3205      	adds	r2, #5
 80027fe:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002802:	f001 fa5d 	bl	8003cc0 <chThdCreateStatic>
 8002806:	2320      	movs	r3, #32
 8002808:	6020      	str	r0, [r4, #0]
 800280a:	f383 8811 	msr	BASEPRI, r3
 800280e:	4d21      	ldr	r5, [pc, #132]	; (8002894 <sem1_execute.9662+0x154>)
 8002810:	2402      	movs	r4, #2
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->s_cnt <= (cnt_t)0) {
 8002812:	462e      	mov	r6, r5
 8002814:	e001      	b.n	800281a <sem1_execute.9662+0xda>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8002816:	3c01      	subs	r4, #1
 8002818:	d00d      	beq.n	8002836 <sem1_execute.9662+0xf6>
    if (++sp->s_cnt <= (cnt_t)0) {
 800281a:	68ab      	ldr	r3, [r5, #8]
 800281c:	3301      	adds	r3, #1
 800281e:	2b00      	cmp	r3, #0
 8002820:	60ab      	str	r3, [r5, #8]
 8002822:	dcf8      	bgt.n	8002816 <sem1_execute.9662+0xd6>
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8002824:	6830      	ldr	r0, [r6, #0]

  tqp->p_next = tp->p_next;
 8002826:	6803      	ldr	r3, [r0, #0]
 8002828:	6033      	str	r3, [r6, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800282a:	605e      	str	r6, [r3, #4]
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 800282c:	f001 fae8 	bl	8003e00 <chSchReadyI>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8002830:	3c01      	subs	r4, #1
    if (++sp->s_cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8002832:	6207      	str	r7, [r0, #32]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8002834:	d1f1      	bne.n	800281a <sem1_execute.9662+0xda>
  chSysLock();
  chSemAddCounterI(&sem1, 2);
  chSchRescheduleS();
 8002836:	f001 f9bb 	bl	8003bb0 <chSchRescheduleS>
 800283a:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();
  test_wait_threads();
 800283e:	f7ff fae7 	bl	8001e10 <test_wait_threads>
 8002842:	2320      	movs	r3, #32
 8002844:	f383 8811 	msr	BASEPRI, r3
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
 8002848:	68a9      	ldr	r1, [r5, #8]
 800284a:	1e4b      	subs	r3, r1, #1
 800284c:	4259      	negs	r1, r3
 800284e:	4159      	adcs	r1, r3
 8002850:	2002      	movs	r0, #2
 8002852:	f7fe f9bd 	bl	8000bd0 <_test_assert>
 8002856:	f384 8811 	msr	BASEPRI, r4
}
 800285a:	b003      	add	sp, #12
 800285c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800285e:	bf00      	nop
 8002860:	20001208 	.word	0x20001208
 8002864:	08006894 	.word	0x08006894
 8002868:	20000928 	.word	0x20000928
 800286c:	08000491 	.word	0x08000491
 8002870:	20001358 	.word	0x20001358
 8002874:	08006890 	.word	0x08006890
 8002878:	20000a70 	.word	0x20000a70
 800287c:	0800688c 	.word	0x0800688c
 8002880:	20000bb8 	.word	0x20000bb8
 8002884:	08006888 	.word	0x08006888
 8002888:	20000d00 	.word	0x20000d00
 800288c:	0800681c 	.word	0x0800681c
 8002890:	20000e48 	.word	0x20000e48
 8002894:	20000800 	.word	0x20000800
 8002898:	08006818 	.word	0x08006818
 800289c:	f3af 8000 	nop.w

080028a0 <thd1_execute.9383>:
static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {
 80028a0:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80028a2:	4f27      	ldr	r7, [pc, #156]	; (8002940 <thd1_execute.9383+0xa0>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80028a4:	4e27      	ldr	r6, [pc, #156]	; (8002944 <thd1_execute.9383+0xa4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80028a6:	69bb      	ldr	r3, [r7, #24]
 80028a8:	4d27      	ldr	r5, [pc, #156]	; (8002948 <thd1_execute.9383+0xa8>)
 80028aa:	689a      	ldr	r2, [r3, #8]
 80028ac:	4b27      	ldr	r3, [pc, #156]	; (800294c <thd1_execute.9383+0xac>)
 80028ae:	4c28      	ldr	r4, [pc, #160]	; (8002950 <thd1_execute.9383+0xb0>)
static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {
 80028b0:	b083      	sub	sp, #12

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80028b2:	3a05      	subs	r2, #5
 80028b4:	9300      	str	r3, [sp, #0]
 80028b6:	4630      	mov	r0, r6
 80028b8:	462b      	mov	r3, r5
 80028ba:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80028be:	f001 f9ff 	bl	8003cc0 <chThdCreateStatic>
 80028c2:	69bb      	ldr	r3, [r7, #24]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80028c4:	4923      	ldr	r1, [pc, #140]	; (8002954 <thd1_execute.9383+0xb4>)
 80028c6:	689a      	ldr	r2, [r3, #8]
  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80028c8:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80028ca:	462b      	mov	r3, r5
 80028cc:	9100      	str	r1, [sp, #0]
 80028ce:	3a04      	subs	r2, #4
 80028d0:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 80028d4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80028d8:	f001 f9f2 	bl	8003cc0 <chThdCreateStatic>
 80028dc:	69bb      	ldr	r3, [r7, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80028de:	491e      	ldr	r1, [pc, #120]	; (8002958 <thd1_execute.9383+0xb8>)
 80028e0:	689a      	ldr	r2, [r3, #8]
}

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80028e2:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80028e4:	462b      	mov	r3, r5
 80028e6:	9100      	str	r1, [sp, #0]
 80028e8:	3a03      	subs	r2, #3
 80028ea:	f506 7024 	add.w	r0, r6, #656	; 0x290
 80028ee:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80028f2:	f001 f9e5 	bl	8003cc0 <chThdCreateStatic>
 80028f6:	69bb      	ldr	r3, [r7, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80028f8:	4918      	ldr	r1, [pc, #96]	; (800295c <thd1_execute.9383+0xbc>)
 80028fa:	689a      	ldr	r2, [r3, #8]

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80028fc:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80028fe:	462b      	mov	r3, r5
 8002900:	9100      	str	r1, [sp, #0]
 8002902:	3a02      	subs	r2, #2
 8002904:	f506 7076 	add.w	r0, r6, #984	; 0x3d8
 8002908:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800290c:	f001 f9d8 	bl	8003cc0 <chThdCreateStatic>
 8002910:	69bb      	ldr	r3, [r7, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8002912:	4913      	ldr	r1, [pc, #76]	; (8002960 <thd1_execute.9383+0xc0>)
 8002914:	689a      	ldr	r2, [r3, #8]
static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8002916:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8002918:	3a01      	subs	r2, #1
 800291a:	462b      	mov	r3, r5
 800291c:	9100      	str	r1, [sp, #0]
 800291e:	f506 60a4 	add.w	r0, r6, #1312	; 0x520
 8002922:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002926:	f001 f9cb 	bl	8003cc0 <chThdCreateStatic>
 800292a:	6120      	str	r0, [r4, #16]
  test_wait_threads();
 800292c:	f7ff fa70 	bl	8001e10 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8002930:	490c      	ldr	r1, [pc, #48]	; (8002964 <thd1_execute.9383+0xc4>)
 8002932:	2001      	movs	r0, #1
}
 8002934:	b003      	add	sp, #12
 8002936:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 800293a:	f7fe b921 	b.w	8000b80 <_test_assert_sequence>
 800293e:	bf00      	nop
 8002940:	20001208 	.word	0x20001208
 8002944:	20000928 	.word	0x20000928
 8002948:	080004b1 	.word	0x080004b1
 800294c:	0800681c 	.word	0x0800681c
 8002950:	20001358 	.word	0x20001358
 8002954:	08006888 	.word	0x08006888
 8002958:	0800688c 	.word	0x0800688c
 800295c:	08006890 	.word	0x08006890
 8002960:	08006894 	.word	0x08006894
 8002964:	08006818 	.word	0x08006818
 8002968:	f3af 8000 	nop.w
 800296c:	f3af 8000 	nop.w

08002970 <thd2_execute.9385>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 8002970:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002974:	4d44      	ldr	r5, [pc, #272]	; (8002a88 <thd2_execute.9385+0x118>)

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8002976:	4e45      	ldr	r6, [pc, #276]	; (8002a8c <thd2_execute.9385+0x11c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002978:	69ab      	ldr	r3, [r5, #24]
 800297a:	f8df 812c 	ldr.w	r8, [pc, #300]	; 8002aa8 <thd2_execute.9385+0x138>
 800297e:	689a      	ldr	r2, [r3, #8]
 8002980:	4b43      	ldr	r3, [pc, #268]	; (8002a90 <thd2_execute.9385+0x120>)
 8002982:	4f44      	ldr	r7, [pc, #272]	; (8002a94 <thd2_execute.9385+0x124>)
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 8002984:	b083      	sub	sp, #12

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8002986:	3a04      	subs	r2, #4
 8002988:	9300      	str	r3, [sp, #0]
 800298a:	4630      	mov	r0, r6
 800298c:	4643      	mov	r3, r8
 800298e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002992:	f001 f995 	bl	8003cc0 <chThdCreateStatic>
 8002996:	69ab      	ldr	r3, [r5, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8002998:	493f      	ldr	r1, [pc, #252]	; (8002a98 <thd2_execute.9385+0x128>)
 800299a:	689a      	ldr	r2, [r3, #8]
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800299c:	6078      	str	r0, [r7, #4]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800299e:	f5a6 74a4 	sub.w	r4, r6, #328	; 0x148
 80029a2:	4643      	mov	r3, r8
 80029a4:	9100      	str	r1, [sp, #0]
 80029a6:	3a05      	subs	r2, #5
 80029a8:	4620      	mov	r0, r4
 80029aa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80029ae:	f001 f987 	bl	8003cc0 <chThdCreateStatic>
 80029b2:	69ab      	ldr	r3, [r5, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80029b4:	4939      	ldr	r1, [pc, #228]	; (8002a9c <thd2_execute.9385+0x12c>)
 80029b6:	689a      	ldr	r2, [r3, #8]
 */

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80029b8:	6038      	str	r0, [r7, #0]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80029ba:	4643      	mov	r3, r8
 80029bc:	9100      	str	r1, [sp, #0]
 80029be:	3a01      	subs	r2, #1
 80029c0:	f506 7076 	add.w	r0, r6, #984	; 0x3d8
 80029c4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80029c8:	f001 f97a 	bl	8003cc0 <chThdCreateStatic>
 80029cc:	69ab      	ldr	r3, [r5, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80029ce:	4934      	ldr	r1, [pc, #208]	; (8002aa0 <thd2_execute.9385+0x130>)
 80029d0:	689a      	ldr	r2, [r3, #8]

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80029d2:	6138      	str	r0, [r7, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80029d4:	3a02      	subs	r2, #2
 80029d6:	9100      	str	r1, [sp, #0]
 80029d8:	f506 7024 	add.w	r0, r6, #656	; 0x290
 80029dc:	4643      	mov	r3, r8
 80029de:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80029e2:	f001 f96d 	bl	8003cc0 <chThdCreateStatic>
 80029e6:	2220      	movs	r2, #32
 80029e8:	60f8      	str	r0, [r7, #12]
 80029ea:	f382 8811 	msr	BASEPRI, r2
 80029ee:	69ab      	ldr	r3, [r5, #24]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80029f0:	6969      	ldr	r1, [r5, #20]
  /* Done this way for coverage of chThdCreateI() and chThdStart().*/
  chSysLock();
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80029f2:	6898      	ldr	r0, [r3, #8]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80029f4:	f8df a0b4 	ldr.w	sl, [pc, #180]	; 8002aac <thd2_execute.9385+0x13c>
 80029f8:	f8c4 83b4 	str.w	r8, [r4, #948]	; 0x3b4
 80029fc:	3803      	subs	r0, #3
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80029fe:	f506 73a4 	add.w	r3, r6, #328	; 0x148
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8002a02:	f04f 0800 	mov.w	r8, #0

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002a06:	f506 7b1b 	add.w	fp, r6, #620	; 0x26c
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002a0a:	f8c4 0298 	str.w	r0, [r4, #664]	; 0x298
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002a0e:	f8c4 02cc 	str.w	r0, [r4, #716]	; 0x2cc

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002a12:	f8df c09c 	ldr.w	ip, [pc, #156]	; 8002ab0 <thd2_execute.9385+0x140>
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002a16:	f8c4 52a0 	str.w	r5, [r4, #672]	; 0x2a0
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8002a1a:	f506 70b6 	add.w	r0, r6, #364	; 0x16c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8002a1e:	f04f 0e02 	mov.w	lr, #2
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002a22:	f506 76b8 	add.w	r6, r6, #368	; 0x170
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002a26:	f04f 0901 	mov.w	r9, #1

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002a2a:	f8c4 b29c 	str.w	fp, [r4, #668]	; 0x29c
 8002a2e:	f8c4 a3b8 	str.w	sl, [r4, #952]	; 0x3b8
 8002a32:	f8c4 c3d4 	str.w	ip, [r4, #980]	; 0x3d4
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8002a36:	f884 e2ac 	strb.w	lr, [r4, #684]	; 0x2ac
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002a3a:	f8c4 12a4 	str.w	r1, [r4, #676]	; 0x2a4
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8002a3e:	f884 82ad 	strb.w	r8, [r4, #685]	; 0x2ad
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8002a42:	f8c4 82c8 	str.w	r8, [r4, #712]	; 0x2c8
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8002a46:	f8c4 82c4 	str.w	r8, [r4, #708]	; 0x2c4
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002a4a:	f8c4 82a8 	str.w	r8, [r4, #680]	; 0x2a8
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002a4e:	f884 92ae 	strb.w	r9, [r4, #686]	; 0x2ae
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002a52:	610b      	str	r3, [r1, #16]
 8002a54:	616b      	str	r3, [r5, #20]
 8002a56:	60bb      	str	r3, [r7, #8]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8002a58:	f8c4 02b4 	str.w	r0, [r4, #692]	; 0x2b4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002a5c:	f8c4 62b8 	str.w	r6, [r4, #696]	; 0x2b8
  tqp->p_prev = (thread_t *)tqp;
 8002a60:	f8c4 62bc 	str.w	r6, [r4, #700]	; 0x2bc
 8002a64:	f388 8811 	msr	BASEPRI, r8
  chSysUnlock();
  chThdStart(threads[2]);
 8002a68:	68b8      	ldr	r0, [r7, #8]
 8002a6a:	f382 8811 	msr	BASEPRI, r2
 */
static inline thread_t *chThdStartI(thread_t *tp) {

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 8002a6e:	f001 f9c7 	bl	8003e00 <chSchReadyI>
 8002a72:	f388 8811 	msr	BASEPRI, r8
  test_wait_threads();
 8002a76:	f7ff f9cb 	bl	8001e10 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8002a7a:	490a      	ldr	r1, [pc, #40]	; (8002aa4 <thd2_execute.9385+0x134>)
 8002a7c:	4648      	mov	r0, r9
}
 8002a7e:	b003      	add	sp, #12
 8002a80:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  chSysLock();
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  chSysUnlock();
  chThdStart(threads[2]);
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 8002a84:	f7fe b87c 	b.w	8000b80 <_test_assert_sequence>
 8002a88:	20001208 	.word	0x20001208
 8002a8c:	20000a70 	.word	0x20000a70
 8002a90:	08006888 	.word	0x08006888
 8002a94:	20001358 	.word	0x20001358
 8002a98:	0800681c 	.word	0x0800681c
 8002a9c:	08006894 	.word	0x08006894
 8002aa0:	08006890 	.word	0x08006890
 8002aa4:	08006818 	.word	0x08006818
 8002aa8:	080004b1 	.word	0x080004b1
 8002aac:	0800688c 	.word	0x0800688c
 8002ab0:	080002a1 	.word	0x080002a1
 8002ab4:	f3af 8000 	nop.w
 8002ab8:	f3af 8000 	nop.w
 8002abc:	f3af 8000 	nop.w

08002ac0 <queues1_execute.11031>:

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
}

static void queues1_execute(void) {
 8002ac0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002ac4:	2420      	movs	r4, #32
 8002ac6:	b082      	sub	sp, #8
 8002ac8:	f384 8811 	msr	BASEPRI, r4
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8002acc:	4f99      	ldr	r7, [pc, #612]	; (8002d34 <queues1_execute.11031+0x274>)
 8002ace:	68b9      	ldr	r1, [r7, #8]
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
 8002ad0:	f1d1 0101 	rsbs	r1, r1, #1
 8002ad4:	f04f 0001 	mov.w	r0, #1
 8002ad8:	bf38      	it	cc
 8002ada:	2100      	movcc	r1, #0
 8002adc:	f7fe f878 	bl	8000bd0 <_test_assert>
 8002ae0:	4606      	mov	r6, r0
 8002ae2:	b9e8      	cbnz	r0, 8002b20 <queues1_execute.11031+0x60>
 8002ae4:	f380 8811 	msr	BASEPRI, r0
 8002ae8:	f384 8811 	msr	BASEPRI, r4
 8002aec:	2441      	movs	r4, #65	; 0x41

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 8002aee:	4d91      	ldr	r5, [pc, #580]	; (8002d34 <queues1_execute.11031+0x274>)
 8002af0:	4621      	mov	r1, r4
 8002af2:	3401      	adds	r4, #1
 8002af4:	4628      	mov	r0, r5
 8002af6:	b2e4      	uxtb	r4, r4
 8002af8:	f7fd fe62 	bl	80007c0 <chIQPutI>
  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8002afc:	2c45      	cmp	r4, #69	; 0x45
 8002afe:	d1f6      	bne.n	8002aee <queues1_execute.11031+0x2e>
 8002b00:	2300      	movs	r3, #0
 8002b02:	f383 8811 	msr	BASEPRI, r3
 8002b06:	2320      	movs	r3, #32
 8002b08:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8002b0c:	696a      	ldr	r2, [r5, #20]
 8002b0e:	69ab      	ldr	r3, [r5, #24]
 8002b10:	429a      	cmp	r2, r3
 8002b12:	d03b      	beq.n	8002b8c <queues1_execute.11031+0xcc>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
 8002b14:	4631      	mov	r1, r6
 8002b16:	2002      	movs	r0, #2
 8002b18:	f7fe f85a 	bl	8000bd0 <_test_assert>
 8002b1c:	4604      	mov	r4, r0
 8002b1e:	b128      	cbz	r0, 8002b2c <queues1_execute.11031+0x6c>
 8002b20:	2300      	movs	r3, #0
 8002b22:	f383 8811 	msr	BASEPRI, r3
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
}
 8002b26:	b002      	add	sp, #8
 8002b28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002b2c:	f380 8811 	msr	BASEPRI, r0
 8002b30:	2320      	movs	r3, #32
 8002b32:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
 8002b36:	487f      	ldr	r0, [pc, #508]	; (8002d34 <queues1_execute.11031+0x274>)
 8002b38:	4621      	mov	r1, r4
 8002b3a:	f7fd fe41 	bl	80007c0 <chIQPutI>
 8002b3e:	3004      	adds	r0, #4
 8002b40:	bf14      	ite	ne
 8002b42:	2100      	movne	r1, #0
 8002b44:	2101      	moveq	r1, #1
 8002b46:	2003      	movs	r0, #3
 8002b48:	f7fe f842 	bl	8000bd0 <_test_assert>
 8002b4c:	b9c8      	cbnz	r0, 8002b82 <queues1_execute.11031+0xc2>
 8002b4e:	f380 8811 	msr	BASEPRI, r0
 8002b52:	2404      	movs	r4, #4
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8002b54:	4d77      	ldr	r5, [pc, #476]	; (8002d34 <queues1_execute.11031+0x274>)
 8002b56:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8002b5a:	4628      	mov	r0, r5
 8002b5c:	f002 f8c8 	bl	8004cf0 <chIQGetTimeout>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    test_emit_token(chIQGet(&iq));
 8002b60:	b2c0      	uxtb	r0, r0
 8002b62:	f000 fdf5 	bl	8003750 <test_emit_token>
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8002b66:	3c01      	subs	r4, #1
 8002b68:	d1f4      	bne.n	8002b54 <queues1_execute.11031+0x94>
 8002b6a:	2620      	movs	r6, #32
 8002b6c:	f386 8811 	msr	BASEPRI, r6
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8002b70:	68a9      	ldr	r1, [r5, #8]
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
 8002b72:	f1d1 0101 	rsbs	r1, r1, #1
 8002b76:	bf38      	it	cc
 8002b78:	2100      	movcc	r1, #0
 8002b7a:	2004      	movs	r0, #4
 8002b7c:	f7fe f828 	bl	8000bd0 <_test_assert>
 8002b80:	b148      	cbz	r0, 8002b96 <queues1_execute.11031+0xd6>
 8002b82:	f384 8811 	msr	BASEPRI, r4
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
}
 8002b86:	b002      	add	sp, #8
 8002b88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8002b8c:	68ae      	ldr	r6, [r5, #8]
 8002b8e:	3600      	adds	r6, #0
 8002b90:	bf18      	it	ne
 8002b92:	2601      	movne	r6, #1
 8002b94:	e7be      	b.n	8002b14 <queues1_execute.11031+0x54>
 8002b96:	f384 8811 	msr	BASEPRI, r4

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");
 8002b9a:	2005      	movs	r0, #5
 8002b9c:	4966      	ldr	r1, [pc, #408]	; (8002d38 <queues1_execute.11031+0x278>)
 8002b9e:	f7fd ffef 	bl	8000b80 <_test_assert_sequence>
 8002ba2:	2800      	cmp	r0, #0
 8002ba4:	d1bf      	bne.n	8002b26 <queues1_execute.11031+0x66>
 8002ba6:	f386 8811 	msr	BASEPRI, r6
 8002baa:	2441      	movs	r4, #65	; 0x41

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 8002bac:	4d61      	ldr	r5, [pc, #388]	; (8002d34 <queues1_execute.11031+0x274>)
 8002bae:	4621      	mov	r1, r4
 8002bb0:	3401      	adds	r4, #1
 8002bb2:	4628      	mov	r0, r5
 8002bb4:	b2e4      	uxtb	r4, r4
 8002bb6:	f7fd fe03 	bl	80007c0 <chIQPutI>
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8002bba:	2c45      	cmp	r4, #69	; 0x45
 8002bbc:	d1f6      	bne.n	8002bac <queues1_execute.11031+0xec>
 8002bbe:	2300      	movs	r3, #0
 8002bc0:	f383 8811 	msr	BASEPRI, r3
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 8002bc4:	495d      	ldr	r1, [pc, #372]	; (8002d3c <queues1_execute.11031+0x27c>)
 8002bc6:	2208      	movs	r2, #8
 8002bc8:	4628      	mov	r0, r5
 8002bca:	f002 f8d1 	bl	8004d70 <chIQReadTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 8002bce:	1f06      	subs	r6, r0, #4
 8002bd0:	4271      	negs	r1, r6
 8002bd2:	4171      	adcs	r1, r6
 8002bd4:	2006      	movs	r0, #6
 8002bd6:	f7fd fffb 	bl	8000bd0 <_test_assert>
 8002bda:	4604      	mov	r4, r0
 8002bdc:	2800      	cmp	r0, #0
 8002bde:	d1a2      	bne.n	8002b26 <queues1_execute.11031+0x66>
 8002be0:	2620      	movs	r6, #32
 8002be2:	f386 8811 	msr	BASEPRI, r6
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8002be6:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
 8002be8:	f1d1 0101 	rsbs	r1, r1, #1
 8002bec:	bf38      	it	cc
 8002bee:	2100      	movcc	r1, #0
 8002bf0:	2007      	movs	r0, #7
 8002bf2:	f7fd ffed 	bl	8000bd0 <_test_assert>
 8002bf6:	2800      	cmp	r0, #0
 8002bf8:	d1c3      	bne.n	8002b82 <queues1_execute.11031+0xc2>
 8002bfa:	f380 8811 	msr	BASEPRI, r0
 8002bfe:	f386 8811 	msr	BASEPRI, r6
 8002c02:	2441      	movs	r4, #65	; 0x41

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 8002c04:	4d4b      	ldr	r5, [pc, #300]	; (8002d34 <queues1_execute.11031+0x274>)
 8002c06:	4621      	mov	r1, r4
 8002c08:	3401      	adds	r4, #1
 8002c0a:	4628      	mov	r0, r5
 8002c0c:	b2e4      	uxtb	r4, r4
 8002c0e:	f7fd fdd7 	bl	80007c0 <chIQPutI>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8002c12:	2c45      	cmp	r4, #69	; 0x45
 8002c14:	d1f6      	bne.n	8002c04 <queues1_execute.11031+0x144>
 8002c16:	2300      	movs	r3, #0
 8002c18:	f383 8811 	msr	BASEPRI, r3
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8002c1c:	4947      	ldr	r1, [pc, #284]	; (8002d3c <queues1_execute.11031+0x27c>)
 8002c1e:	4628      	mov	r0, r5
 8002c20:	2202      	movs	r2, #2
 8002c22:	f002 f8a5 	bl	8004d70 <chIQReadTimeout>
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 8002c26:	1e84      	subs	r4, r0, #2
 8002c28:	4261      	negs	r1, r4
 8002c2a:	4161      	adcs	r1, r4
 8002c2c:	2008      	movs	r0, #8
 8002c2e:	f7fd ffcf 	bl	8000bd0 <_test_assert>
 8002c32:	2800      	cmp	r0, #0
 8002c34:	f47f af77 	bne.w	8002b26 <queues1_execute.11031+0x66>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8002c38:	4603      	mov	r3, r0
 8002c3a:	4940      	ldr	r1, [pc, #256]	; (8002d3c <queues1_execute.11031+0x27c>)
 8002c3c:	2202      	movs	r2, #2
 8002c3e:	4628      	mov	r0, r5
 8002c40:	f002 f896 	bl	8004d70 <chIQReadTimeout>
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 8002c44:	3802      	subs	r0, #2
 8002c46:	4241      	negs	r1, r0
 8002c48:	4141      	adcs	r1, r0
 8002c4a:	2009      	movs	r0, #9
 8002c4c:	f7fd ffc0 	bl	8000bd0 <_test_assert>
 8002c50:	4680      	mov	r8, r0
 8002c52:	2800      	cmp	r0, #0
 8002c54:	f47f af67 	bne.w	8002b26 <queues1_execute.11031+0x66>
 8002c58:	2620      	movs	r6, #32
 8002c5a:	f386 8811 	msr	BASEPRI, r6
 8002c5e:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
 8002c60:	f1d1 0101 	rsbs	r1, r1, #1
 8002c64:	f04f 000a 	mov.w	r0, #10
 8002c68:	bf38      	it	cc
 8002c6a:	2100      	movcc	r1, #0
 8002c6c:	f7fd ffb0 	bl	8000bd0 <_test_assert>
 8002c70:	4604      	mov	r4, r0
 8002c72:	b110      	cbz	r0, 8002c7a <queues1_execute.11031+0x1ba>
 8002c74:	f388 8811 	msr	BASEPRI, r8
 8002c78:	e755      	b.n	8002b26 <queues1_execute.11031+0x66>
 8002c7a:	f380 8811 	msr	BASEPRI, r0
 8002c7e:	f386 8811 	msr	BASEPRI, r6

  /* Testing reset */
  chSysLock();
  chIQPutI(&iq, 0);
 8002c82:	4621      	mov	r1, r4
 8002c84:	4628      	mov	r0, r5
 8002c86:	f7fd fd9b 	bl	80007c0 <chIQPutI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002c8a:	682b      	ldr	r3, [r5, #0]
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 8002c8c:	68ea      	ldr	r2, [r5, #12]
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
 8002c8e:	60ac      	str	r4, [r5, #8]
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 8002c90:	42ab      	cmp	r3, r5
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 8002c92:	61aa      	str	r2, [r5, #24]
  iqp->q_wrptr = iqp->q_buffer;
 8002c94:	616a      	str	r2, [r5, #20]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8002c96:	bf18      	it	ne
 8002c98:	f06f 0401 	mvnne.w	r4, #1
 8002c9c:	d009      	beq.n	8002cb2 <queues1_execute.11031+0x1f2>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8002c9e:	681a      	ldr	r2, [r3, #0]
 8002ca0:	603a      	str	r2, [r7, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002ca2:	6057      	str	r7, [r2, #4]
  (void) chSchReadyI(tp);
 8002ca4:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8002ca6:	621c      	str	r4, [r3, #32]
  (void) chSchReadyI(tp);
 8002ca8:	f001 f8aa 	bl	8003e00 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002cac:	683b      	ldr	r3, [r7, #0]
 8002cae:	42bb      	cmp	r3, r7
 8002cb0:	d1f5      	bne.n	8002c9e <queues1_execute.11031+0x1de>
 8002cb2:	f04f 0800 	mov.w	r8, #0
 8002cb6:	f388 8811 	msr	BASEPRI, r8
 8002cba:	2620      	movs	r6, #32
 8002cbc:	f386 8811 	msr	BASEPRI, r6
 */
static inline size_t chIQGetFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (size_t)chQSpaceI(iqp);
 8002cc0:	68b9      	ldr	r1, [r7, #8]
 8002cc2:	4d1c      	ldr	r5, [pc, #112]	; (8002d34 <queues1_execute.11031+0x274>)
  chIQResetI(&iq);
  chSysUnlock();
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
 8002cc4:	ebb1 0208 	subs.w	r2, r1, r8
 8002cc8:	4251      	negs	r1, r2
 8002cca:	4151      	adcs	r1, r2
 8002ccc:	200b      	movs	r0, #11
 8002cce:	f7fd ff7f 	bl	8000bd0 <_test_assert>
 8002cd2:	4604      	mov	r4, r0
 8002cd4:	2800      	cmp	r0, #0
 8002cd6:	d1cd      	bne.n	8002c74 <queues1_execute.11031+0x1b4>
 8002cd8:	f380 8811 	msr	BASEPRI, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002cdc:	4b18      	ldr	r3, [pc, #96]	; (8002d40 <queues1_execute.11031+0x280>)
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
 8002cde:	4819      	ldr	r0, [pc, #100]	; (8002d44 <queues1_execute.11031+0x284>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002ce0:	699a      	ldr	r2, [r3, #24]
 8002ce2:	4b19      	ldr	r3, [pc, #100]	; (8002d48 <queues1_execute.11031+0x288>)
 8002ce4:	6892      	ldr	r2, [r2, #8]
 8002ce6:	9400      	str	r4, [sp, #0]
 8002ce8:	3201      	adds	r2, #1
 8002cea:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8002cee:	f000 ffe7 	bl	8003cc0 <chThdCreateStatic>
 8002cf2:	4b16      	ldr	r3, [pc, #88]	; (8002d4c <queues1_execute.11031+0x28c>)
 8002cf4:	6018      	str	r0, [r3, #0]
 8002cf6:	f386 8811 	msr	BASEPRI, r6
 8002cfa:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
 8002cfc:	f1d1 0101 	rsbs	r1, r1, #1
 8002d00:	bf38      	it	cc
 8002d02:	2100      	movcc	r1, #0
 8002d04:	200c      	movs	r0, #12
 8002d06:	f7fd ff63 	bl	8000bd0 <_test_assert>
 8002d0a:	2800      	cmp	r0, #0
 8002d0c:	f47f af39 	bne.w	8002b82 <queues1_execute.11031+0xc2>
 8002d10:	f380 8811 	msr	BASEPRI, r0
  test_wait_threads();
 8002d14:	f7ff f87c 	bl	8001e10 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 8002d18:	4628      	mov	r0, r5
 8002d1a:	210a      	movs	r1, #10
 8002d1c:	f001 ffe8 	bl	8004cf0 <chIQGetTimeout>
 8002d20:	f1b0 33ff 	subs.w	r3, r0, #4294967295	; 0xffffffff
 8002d24:	4259      	negs	r1, r3
 8002d26:	4159      	adcs	r1, r3
 8002d28:	200d      	movs	r0, #13
}
 8002d2a:	b002      	add	sp, #8
 8002d2c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 8002d30:	f7fd bf4e 	b.w	8000bd0 <_test_assert>
 8002d34:	2000086c 	.word	0x2000086c
 8002d38:	08006810 	.word	0x08006810
 8002d3c:	20000a70 	.word	0x20000a70
 8002d40:	20001208 	.word	0x20001208
 8002d44:	20000928 	.word	0x20000928
 8002d48:	08004d41 	.word	0x08004d41
 8002d4c:	20001358 	.word	0x20001358

08002d50 <chThdCreateFromMemoryPool.constprop.52.4171>:
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
 8002d50:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8002d54:	4e21      	ldr	r6, [pc, #132]	; (8002ddc <chThdCreateFromMemoryPool.constprop.52.4171+0x8c>)
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
 8002d56:	4607      	mov	r7, r0
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8002d58:	4630      	mov	r0, r6
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
 8002d5a:	4688      	mov	r8, r1
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8002d5c:	f000 fe80 	bl	8003a60 <chPoolAlloc>
  if (wsp == NULL) {
 8002d60:	4604      	mov	r4, r0
 8002d62:	2800      	cmp	r0, #0
 8002d64:	d037      	beq.n	8002dd6 <chThdCreateFromMemoryPool.constprop.52.4171+0x86>
 8002d66:	2320      	movs	r3, #32
 8002d68:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002d6c:	6872      	ldr	r2, [r6, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002d6e:	4b1c      	ldr	r3, [pc, #112]	; (8002de0 <chThdCreateFromMemoryPool.constprop.52.4171+0x90>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002d70:	4d1c      	ldr	r5, [pc, #112]	; (8002de4 <chThdCreateFromMemoryPool.constprop.52.4171+0x94>)
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002d72:	f8d3 e014 	ldr.w	lr, [r3, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002d76:	491c      	ldr	r1, [pc, #112]	; (8002de8 <chThdCreateFromMemoryPool.constprop.52.4171+0x98>)
 8002d78:	f1a2 0c24 	sub.w	ip, r2, #36	; 0x24
 8002d7c:	eb00 0b0c 	add.w	fp, r0, ip
 8002d80:	f8c0 b00c 	str.w	fp, [r0, #12]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8002d84:	2202      	movs	r2, #2

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002d86:	f840 500c 	str.w	r5, [r0, ip]
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8002d8a:	f100 0924 	add.w	r9, r0, #36	; 0x24
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8002d8e:	2500      	movs	r5, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8002d90:	f100 0c28 	add.w	ip, r0, #40	; 0x28
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002d94:	f04f 0a01 	mov.w	sl, #1

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002d98:	f8cb 8004 	str.w	r8, [fp, #4]
 8002d9c:	f8cb 1020 	str.w	r1, [fp, #32]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002da0:	6087      	str	r7, [r0, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002da2:	6103      	str	r3, [r0, #16]
 8002da4:	f8c0 e014 	str.w	lr, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002da8:	63c7      	str	r7, [r0, #60]	; 0x3c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002daa:	f880 a01e 	strb.w	sl, [r0, #30]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8002dae:	7702      	strb	r2, [r0, #28]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8002db0:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8002db2:	6345      	str	r5, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002db4:	6185      	str	r5, [r0, #24]

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
  tp->p_flags = CH_FLAG_MODE_MPOOL;
  tp->p_mpool = mp;
  chSchWakeupS(tp, MSG_OK);
 8002db6:	4629      	mov	r1, r5
  REG_INSERT(tp);
 8002db8:	f8ce 0010 	str.w	r0, [lr, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8002dbc:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
  tp->p_flags = CH_FLAG_MODE_MPOOL;
 8002dc0:	7742      	strb	r2, [r0, #29]
  tp->p_mpool = mp;
 8002dc2:	6406      	str	r6, [r0, #64]	; 0x40
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002dc4:	f8c4 c028 	str.w	ip, [r4, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8002dc8:	f8c4 c02c 	str.w	ip, [r4, #44]	; 0x2c
 8002dcc:	6158      	str	r0, [r3, #20]
  chSchWakeupS(tp, MSG_OK);
 8002dce:	f000 ff27 	bl	8003c20 <chSchWakeupS>
 8002dd2:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 8002dd6:	4620      	mov	r0, r4
 8002dd8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002ddc:	200008c8 	.word	0x200008c8
 8002de0:	20001208 	.word	0x20001208
 8002de4:	08000451 	.word	0x08000451
 8002de8:	080002a1 	.word	0x080002a1
 8002dec:	f3af 8000 	nop.w

08002df0 <dyn2_execute.10843>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002df0:	4a30      	ldr	r2, [pc, #192]	; (8002eb4 <dyn2_execute.10843+0xc4>)
 8002df2:	4931      	ldr	r1, [pc, #196]	; (8002eb8 <dyn2_execute.10843+0xc8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002df4:	6992      	ldr	r2, [r2, #24]
static void dyn2_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void dyn2_execute(void) {
 8002df6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002df8:	4b30      	ldr	r3, [pc, #192]	; (8002ebc <dyn2_execute.10843+0xcc>)
 8002dfa:	6895      	ldr	r5, [r2, #8]
 8002dfc:	f103 0710 	add.w	r7, r3, #16
 8002e00:	2620      	movs	r6, #32
 8002e02:	2000      	movs	r0, #0
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);
 8002e04:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8002e08:	f386 8811 	msr	BASEPRI, r6
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8002e0c:	680c      	ldr	r4, [r1, #0]
 8002e0e:	6014      	str	r4, [r2, #0]
  mp->mp_next = php;
 8002e10:	600a      	str	r2, [r1, #0]
 8002e12:	f380 8811 	msr	BASEPRI, r0
static void dyn2_execute(void) {
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 8002e16:	42bb      	cmp	r3, r7
 8002e18:	d1f4      	bne.n	8002e04 <dyn2_execute.10843+0x14>
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 8002e1a:	4929      	ldr	r1, [pc, #164]	; (8002ec0 <dyn2_execute.10843+0xd0>)
 8002e1c:	4c29      	ldr	r4, [pc, #164]	; (8002ec4 <dyn2_execute.10843+0xd4>)
 8002e1e:	1e68      	subs	r0, r5, #1
 8002e20:	f7ff ff96 	bl	8002d50 <chThdCreateFromMemoryPool.constprop.52.4171>
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8002e24:	4928      	ldr	r1, [pc, #160]	; (8002ec8 <dyn2_execute.10843+0xd8>)
  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 8002e26:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8002e28:	1ea8      	subs	r0, r5, #2
 8002e2a:	f7ff ff91 	bl	8002d50 <chThdCreateFromMemoryPool.constprop.52.4171>
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8002e2e:	4927      	ldr	r1, [pc, #156]	; (8002ecc <dyn2_execute.10843+0xdc>)
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8002e30:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8002e32:	1ee8      	subs	r0, r5, #3
 8002e34:	f7ff ff8c 	bl	8002d50 <chThdCreateFromMemoryPool.constprop.52.4171>
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8002e38:	4925      	ldr	r1, [pc, #148]	; (8002ed0 <dyn2_execute.10843+0xe0>)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8002e3a:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8002e3c:	1f28      	subs	r0, r5, #4
 8002e3e:	f7ff ff87 	bl	8002d50 <chThdCreateFromMemoryPool.constprop.52.4171>
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8002e42:	4924      	ldr	r1, [pc, #144]	; (8002ed4 <dyn2_execute.10843+0xe4>)

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8002e44:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8002e46:	1f68      	subs	r0, r5, #5
 8002e48:	f7ff ff82 	bl	8002d50 <chThdCreateFromMemoryPool.constprop.52.4171>

  test_assert(1, (threads[0] != NULL) &&
 8002e4c:	6821      	ldr	r1, [r4, #0]
  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8002e4e:	6120      	str	r0, [r4, #16]

  test_assert(1, (threads[0] != NULL) &&
 8002e50:	b149      	cbz	r1, 8002e66 <dyn2_execute.10843+0x76>
 8002e52:	6861      	ldr	r1, [r4, #4]
 8002e54:	b139      	cbz	r1, 8002e66 <dyn2_execute.10843+0x76>
 8002e56:	68a1      	ldr	r1, [r4, #8]
 8002e58:	b129      	cbz	r1, 8002e66 <dyn2_execute.10843+0x76>
 8002e5a:	68e1      	ldr	r1, [r4, #12]
 8002e5c:	b119      	cbz	r1, 8002e66 <dyn2_execute.10843+0x76>
 8002e5e:	f1d0 0101 	rsbs	r1, r0, #1
 8002e62:	bf38      	it	cc
 8002e64:	2100      	movcc	r1, #0
 8002e66:	2001      	movs	r0, #1
 8002e68:	f7fd feb2 	bl	8000bd0 <_test_assert>
 8002e6c:	b100      	cbz	r0, 8002e70 <dyn2_execute.10843+0x80>
 8002e6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                 (threads[3] != NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 8002e70:	f7fe ffce 	bl	8001e10 <test_wait_threads>
  test_assert_sequence(2, "ABCD");
 8002e74:	2002      	movs	r0, #2
 8002e76:	4918      	ldr	r1, [pc, #96]	; (8002ed8 <dyn2_execute.10843+0xe8>)
 8002e78:	f7fd fe82 	bl	8000b80 <_test_assert_sequence>
 8002e7c:	2800      	cmp	r0, #0
 8002e7e:	d1f6      	bne.n	8002e6e <dyn2_execute.10843+0x7e>
 8002e80:	2404      	movs	r4, #4

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
 8002e82:	480d      	ldr	r0, [pc, #52]	; (8002eb8 <dyn2_execute.10843+0xc8>)
 8002e84:	f000 fdec 	bl	8003a60 <chPoolAlloc>
 8002e88:	1c01      	adds	r1, r0, #0
 8002e8a:	bf18      	it	ne
 8002e8c:	2101      	movne	r1, #1
 8002e8e:	2003      	movs	r0, #3
 8002e90:	f7fd fe9e 	bl	8000bd0 <_test_assert>
 8002e94:	2800      	cmp	r0, #0
 8002e96:	d1ea      	bne.n	8002e6e <dyn2_execute.10843+0x7e>
  /* Claiming the memory from terminated threads. */
  test_wait_threads();
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 8002e98:	3c01      	subs	r4, #1
 8002e9a:	d1f2      	bne.n	8002e82 <dyn2_execute.10843+0x92>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8002e9c:	4806      	ldr	r0, [pc, #24]	; (8002eb8 <dyn2_execute.10843+0xc8>)
 8002e9e:	f000 fddf 	bl	8003a60 <chPoolAlloc>
 8002ea2:	f1d0 0101 	rsbs	r1, r0, #1
 8002ea6:	bf38      	it	cc
 8002ea8:	2100      	movcc	r1, #0
 8002eaa:	2004      	movs	r0, #4
}
 8002eac:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8002eb0:	f7fd be8e 	b.w	8000bd0 <_test_assert>
 8002eb4:	20001208 	.word	0x20001208
 8002eb8:	200008c8 	.word	0x200008c8
 8002ebc:	080068cc 	.word	0x080068cc
 8002ec0:	08006894 	.word	0x08006894
 8002ec4:	20001358 	.word	0x20001358
 8002ec8:	08006890 	.word	0x08006890
 8002ecc:	0800688c 	.word	0x0800688c
 8002ed0:	08006888 	.word	0x08006888
 8002ed4:	0800681c 	.word	0x0800681c
 8002ed8:	08006810 	.word	0x08006810
 8002edc:	f3af 8000 	nop.w

08002ee0 <thread4.9653>:
 * <h2>Description</h2>
 * This test case tests the binary semaphores functionality. The test both
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static THD_FUNCTION(thread4, p) {
 8002ee0:	b508      	push	{r3, lr}
 8002ee2:	2220      	movs	r2, #32
 8002ee4:	f382 8811 	msr	BASEPRI, r2
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 8002ee8:	6883      	ldr	r3, [r0, #8]
 8002eea:	2b00      	cmp	r3, #0
 8002eec:	dd05      	ble.n	8002efa <thread4.9653+0x1a>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8002eee:	f000 fe5f 	bl	8003bb0 <chSchRescheduleS>
 8002ef2:	2300      	movs	r3, #0
 8002ef4:	f383 8811 	msr	BASEPRI, r3
 8002ef8:	bd08      	pop	{r3, pc}
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 8002efa:	f001 f9a9 	bl	8004250 <chSemSignalI>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8002efe:	f000 fe57 	bl	8003bb0 <chSchRescheduleS>
 8002f02:	2300      	movs	r3, #0
 8002f04:	f383 8811 	msr	BASEPRI, r3
 8002f08:	bd08      	pop	{r3, pc}
 8002f0a:	bf00      	nop
 8002f0c:	f3af 8000 	nop.w

08002f10 <mtx5_execute.9929>:
static void mtx5_setup(void) {

  chMtxObjectInit(&m1);
}

static void mtx5_execute(void) {
 8002f10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002f14:	4d3b      	ldr	r5, [pc, #236]	; (8003004 <mtx5_execute.9929+0xf4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002f16:	69ab      	ldr	r3, [r5, #24]
 8002f18:	2220      	movs	r2, #32
 8002f1a:	689e      	ldr	r6, [r3, #8]
 8002f1c:	f382 8811 	msr	BASEPRI, r2
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 8002f20:	4c39      	ldr	r4, [pc, #228]	; (8003008 <mtx5_execute.9929+0xf8>)
 8002f22:	68a3      	ldr	r3, [r4, #8]
    if (mp->m_owner == currp) {
      mp->m_cnt++;
      return true;
    }
#endif
    return false;
 8002f24:	2100      	movs	r1, #0
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 8002f26:	2b00      	cmp	r3, #0
 8002f28:	d05e      	beq.n	8002fe8 <mtx5_execute.9929+0xd8>
 8002f2a:	2300      	movs	r3, #0
 8002f2c:	f383 8811 	msr	BASEPRI, r3
#if !CH_CFG_USE_MUTEXES_RECURSIVE
  bool b;
  tprio_t prio = chThdGetPriorityX();

  b = chMtxTryLock(&m1);
  test_assert(1, b, "already locked");
 8002f30:	2001      	movs	r0, #1
 8002f32:	f7fd fe4d 	bl	8000bd0 <_test_assert>
 8002f36:	4601      	mov	r1, r0
 8002f38:	b108      	cbz	r0, 8002f3e <mtx5_execute.9929+0x2e>
 8002f3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002f3e:	2320      	movs	r3, #32
 8002f40:	f383 8811 	msr	BASEPRI, r3
 8002f44:	68a3      	ldr	r3, [r4, #8]
 8002f46:	4a30      	ldr	r2, [pc, #192]	; (8003008 <mtx5_execute.9929+0xf8>)
 8002f48:	2b00      	cmp	r3, #0
 8002f4a:	d054      	beq.n	8002ff6 <mtx5_execute.9929+0xe6>
 8002f4c:	2101      	movs	r1, #1
 8002f4e:	2300      	movs	r3, #0
 8002f50:	f383 8811 	msr	BASEPRI, r3

  b = chMtxTryLock(&m1);
  test_assert(2, !b, "not locked");
 8002f54:	2002      	movs	r0, #2
 8002f56:	f7fd fe3b 	bl	8000bd0 <_test_assert>
 8002f5a:	4607      	mov	r7, r0
 8002f5c:	2800      	cmp	r0, #0
 8002f5e:	d1ec      	bne.n	8002f3a <mtx5_execute.9929+0x2a>
 8002f60:	2320      	movs	r3, #32
 8002f62:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMtxUnlockS(&m1);
 8002f66:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 8003008 <mtx5_execute.9929+0xf8>
 8002f6a:	4640      	mov	r0, r8
 8002f6c:	f000 ffe0 	bl	8003f30 <chMtxUnlockS>
 8002f70:	f387 8811 	msr	BASEPRI, r7
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 8002f74:	6821      	ldr	r1, [r4, #0]
  chSysUnlock();

  test_assert(3, queue_isempty(&m1.m_queue), "queue not empty");
 8002f76:	1b0c      	subs	r4, r1, r4
 8002f78:	4261      	negs	r1, r4
 8002f7a:	4161      	adcs	r1, r4
 8002f7c:	2003      	movs	r0, #3
 8002f7e:	f7fd fe27 	bl	8000bd0 <_test_assert>
 8002f82:	2800      	cmp	r0, #0
 8002f84:	d1d9      	bne.n	8002f3a <mtx5_execute.9929+0x2a>
  test_assert(4, m1.m_owner == NULL, "still owned");
 8002f86:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8002f8a:	f1d1 0101 	rsbs	r1, r1, #1
 8002f8e:	bf38      	it	cc
 8002f90:	2100      	movcc	r1, #0
 8002f92:	2004      	movs	r0, #4
 8002f94:	f7fd fe1c 	bl	8000bd0 <_test_assert>
 8002f98:	2800      	cmp	r0, #0
 8002f9a:	d1ce      	bne.n	8002f3a <mtx5_execute.9929+0x2a>
 8002f9c:	69ab      	ldr	r3, [r5, #24]
  test_assert(5, chThdGetPriorityX() == prio, "wrong priority level");
 8002f9e:	6899      	ldr	r1, [r3, #8]
 8002fa0:	1a72      	subs	r2, r6, r1
 8002fa2:	4251      	negs	r1, r2
 8002fa4:	4151      	adcs	r1, r2
 8002fa6:	2005      	movs	r0, #5
 8002fa8:	f7fd fe12 	bl	8000bd0 <_test_assert>
 8002fac:	2800      	cmp	r0, #0
 8002fae:	d1c4      	bne.n	8002f3a <mtx5_execute.9929+0x2a>
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
 8002fb0:	4640      	mov	r0, r8
 8002fb2:	f001 f885 	bl	80040c0 <chMtxLock>
  chMtxUnlockAll();
 8002fb6:	f000 ff8b 	bl	8003ed0 <chMtxUnlockAll>
 8002fba:	f8d8 1000 	ldr.w	r1, [r8]
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
 8002fbe:	ebb1 0308 	subs.w	r3, r1, r8
 8002fc2:	4259      	negs	r1, r3
 8002fc4:	4159      	adcs	r1, r3
 8002fc6:	2006      	movs	r0, #6
 8002fc8:	f7fd fe02 	bl	8000bd0 <_test_assert>
 8002fcc:	2800      	cmp	r0, #0
 8002fce:	d1b4      	bne.n	8002f3a <mtx5_execute.9929+0x2a>
  test_assert(7, m1.m_owner == NULL, "still owned");
 8002fd0:	f8d8 1008 	ldr.w	r1, [r8, #8]
 8002fd4:	f1d1 0101 	rsbs	r1, r1, #1
 8002fd8:	f04f 0007 	mov.w	r0, #7
 8002fdc:	bf38      	it	cc
 8002fde:	2100      	movcc	r1, #0
}
 8002fe0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
  chMtxUnlockAll();
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
  test_assert(7, m1.m_owner == NULL, "still owned");
 8002fe4:	f7fd bdf4 	b.w	8000bd0 <_test_assert>

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 8002fe8:	69ab      	ldr	r3, [r5, #24]
 8002fea:	60a3      	str	r3, [r4, #8]
  mp->m_next = currp->p_mtxlist;
 8002fec:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002fee:	60e2      	str	r2, [r4, #12]
  currp->p_mtxlist = mp;
 8002ff0:	639c      	str	r4, [r3, #56]	; 0x38
 8002ff2:	2101      	movs	r1, #1
 8002ff4:	e799      	b.n	8002f2a <mtx5_execute.9929+0x1a>

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 8002ff6:	69ab      	ldr	r3, [r5, #24]
 8002ff8:	6093      	str	r3, [r2, #8]
  mp->m_next = currp->p_mtxlist;
 8002ffa:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8002ffc:	60d0      	str	r0, [r2, #12]
  currp->p_mtxlist = mp;
 8002ffe:	639a      	str	r2, [r3, #56]	; 0x38
 8003000:	e7a5      	b.n	8002f4e <mtx5_execute.9929+0x3e>
 8003002:	bf00      	nop
 8003004:	20001208 	.word	0x20001208
 8003008:	20000830 	.word	0x20000830
 800300c:	f3af 8000 	nop.w

08003010 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8003010:	b538      	push	{r3, r4, r5, lr}

  (void)ep;
  switch (usbp->ep0state) {
 8003012:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 8003016:	2b06      	cmp	r3, #6
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8003018:	4604      	mov	r4, r0
 800301a:	d80a      	bhi.n	8003032 <_usb_ep0out+0x22>
 800301c:	2201      	movs	r2, #1
 800301e:	fa02 f303 	lsl.w	r3, r2, r3
 8003022:	f013 0f67 	tst.w	r3, #103	; 0x67
 8003026:	d111      	bne.n	800304c <_usb_ep0out+0x3c>
 8003028:	f013 0508 	ands.w	r5, r3, #8
 800302c:	d102      	bne.n	8003034 <_usb_ep0out+0x24>
 800302e:	06db      	lsls	r3, r3, #27
 8003030:	d422      	bmi.n	8003078 <_usb_ep0out+0x68>
 8003032:	bd38      	pop	{r3, r4, r5, pc}
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeI(usbp, 0) != 0U) {
 8003034:	68c3      	ldr	r3, [r0, #12]
 8003036:	699b      	ldr	r3, [r3, #24]
 8003038:	689b      	ldr	r3, [r3, #8]
 800303a:	2b00      	cmp	r3, #0
 800303c:	d1f9      	bne.n	8003032 <_usb_ep0out+0x22>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 800303e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8003040:	b103      	cbz	r3, 8003044 <_usb_ep0out+0x34>
      usbp->ep0endcb(usbp);
 8003042:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8003044:	2300      	movs	r3, #0
 8003046:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800304a:	bd38      	pop	{r3, r4, r5, pc}
 800304c:	6d03      	ldr	r3, [r0, #80]	; 0x50
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800304e:	6842      	ldr	r2, [r0, #4]
 8003050:	f8d3 1900 	ldr.w	r1, [r3, #2304]	; 0x900
 8003054:	6812      	ldr	r2, [r2, #0]
 8003056:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 800305a:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800305e:	f8d3 1b00 	ldr.w	r1, [r3, #2816]	; 0xb00
 8003062:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 8003066:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
 800306a:	b10a      	cbz	r2, 8003070 <_usb_ep0out+0x60>
 800306c:	2105      	movs	r1, #5
 800306e:	4790      	blx	r2
    usbp->ep0state = USB_EP0_ERROR;
 8003070:	2306      	movs	r3, #6
 8003072:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8003076:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003078:	68c3      	ldr	r3, [r0, #12]
 800307a:	695b      	ldr	r3, [r3, #20]

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 800307c:	2205      	movs	r2, #5
 800307e:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 8003082:	4629      	mov	r1, r5
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8003084:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 8003086:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 8003088:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 800308a:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 800308c:	f000 fbe8 	bl	8003860 <usb_lld_prepare_transmit>
 8003090:	2320      	movs	r3, #32
 8003092:	f383 8811 	msr	BASEPRI, r3
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    usbPrepareTransmit(usbp, 0, NULL, 0);
    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, 0);
 8003096:	4620      	mov	r0, r4
 8003098:	f7fd fcd2 	bl	8000a40 <usbStartTransmitI.constprop.9>
 800309c:	f385 8811 	msr	BASEPRI, r5
 80030a0:	bd38      	pop	{r3, r4, r5, pc}
 80030a2:	bf00      	nop
 80030a4:	f3af 8000 	nop.w
 80030a8:	f3af 8000 	nop.w
 80030ac:	f3af 8000 	nop.w

080030b0 <chThdCreateFromHeap.constprop.53.4425>:
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 80030b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80030b4:	4606      	mov	r6, r0
 80030b6:	460d      	mov	r5, r1
                              tprio_t prio, tfunc_t pf, void *arg) {
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 80030b8:	481d      	ldr	r0, [pc, #116]	; (8003130 <chThdCreateFromHeap.constprop.53.4425+0x80>)
 80030ba:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80030be:	f001 f87f 	bl	80041c0 <chHeapAlloc>
  if (wsp == NULL) {
 80030c2:	4604      	mov	r4, r0
 80030c4:	b380      	cbz	r0, 8003128 <chThdCreateFromHeap.constprop.53.4425+0x78>
 80030c6:	2320      	movs	r3, #32
 80030c8:	f383 8811 	msr	BASEPRI, r3
 80030cc:	4b19      	ldr	r3, [pc, #100]	; (8003134 <chThdCreateFromHeap.constprop.53.4425+0x84>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80030ce:	f8c0 5128 	str.w	r5, [r0, #296]	; 0x128
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80030d2:	695a      	ldr	r2, [r3, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80030d4:	f8df 9060 	ldr.w	r9, [pc, #96]	; 8003138 <chThdCreateFromHeap.constprop.53.4425+0x88>
 80030d8:	f8df 8060 	ldr.w	r8, [pc, #96]	; 800313c <chThdCreateFromHeap.constprop.53.4425+0x8c>
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80030dc:	6086      	str	r6, [r0, #8]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80030de:	2500      	movs	r5, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 80030e0:	f100 0e28 	add.w	lr, r0, #40	; 0x28

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80030e4:	f500 7a92 	add.w	sl, r0, #292	; 0x124
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 80030e8:	f100 0c24 	add.w	ip, r0, #36	; 0x24
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80030ec:	2701      	movs	r7, #1
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80030ee:	2102      	movs	r1, #2

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80030f0:	f8c0 a00c 	str.w	sl, [r0, #12]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80030f4:	7701      	strb	r1, [r0, #28]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80030f6:	6103      	str	r3, [r0, #16]
 80030f8:	6142      	str	r2, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 80030fa:	63c6      	str	r6, [r0, #60]	; 0x3c

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80030fc:	f8c0 9124 	str.w	r9, [r0, #292]	; 0x124
 8003100:	f8c0 8144 	str.w	r8, [r0, #324]	; 0x144
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8003104:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8003106:	6345      	str	r5, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8003108:	6185      	str	r5, [r0, #24]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800310a:	7787      	strb	r7, [r0, #30]
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  tp->p_flags = CH_FLAG_MODE_HEAP;
  chSchWakeupS(tp, MSG_OK);
 800310c:	4629      	mov	r1, r5
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800310e:	6110      	str	r0, [r2, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8003110:	f8c4 c024 	str.w	ip, [r4, #36]	; 0x24
                  CH_DBG_STACK_FILL_VALUE);
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  tp->p_flags = CH_FLAG_MODE_HEAP;
 8003114:	7747      	strb	r7, [r0, #29]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003116:	f8c4 e028 	str.w	lr, [r4, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 800311a:	f8c4 e02c 	str.w	lr, [r4, #44]	; 0x2c
 800311e:	6158      	str	r0, [r3, #20]
  chSchWakeupS(tp, MSG_OK);
 8003120:	f000 fd7e 	bl	8003c20 <chSchWakeupS>
 8003124:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 8003128:	4620      	mov	r0, r4
 800312a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800312e:	bf00      	nop
 8003130:	200008d8 	.word	0x200008d8
 8003134:	20001208 	.word	0x20001208
 8003138:	08000451 	.word	0x08000451
 800313c:	080002a1 	.word	0x080002a1

08003140 <dyn3_execute.10851>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003140:	4b48      	ldr	r3, [pc, #288]	; (8003264 <dyn3_execute.10851+0x124>)
static void dyn3_execute(void) {
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 8003142:	4949      	ldr	r1, [pc, #292]	; (8003268 <dyn3_execute.10851+0x128>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003144:	699b      	ldr	r3, [r3, #24]
 8003146:	6898      	ldr	r0, [r3, #8]
static void dyn3_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn3_execute(void) {
 8003148:	b510      	push	{r4, lr}
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 800314a:	3801      	subs	r0, #1
 800314c:	f7ff ffb0 	bl	80030b0 <chThdCreateFromHeap.constprop.53.4425>
 8003150:	4604      	mov	r4, r0
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 8003152:	2001      	movs	r0, #1
 8003154:	7fa1      	ldrb	r1, [r4, #30]
 8003156:	ebb1 0c00 	subs.w	ip, r1, r0
 800315a:	f1dc 0100 	rsbs	r1, ip, #0
 800315e:	eb51 010c 	adcs.w	r1, r1, ip
 8003162:	f7fd fd35 	bl	8000bd0 <_test_assert>
 8003166:	b100      	cbz	r0, 800316a <dyn3_execute.10851+0x2a>
 8003168:	bd10      	pop	{r4, pc}
 800316a:	2320      	movs	r3, #32
 800316c:	f383 8811 	msr	BASEPRI, r3
 */
thread_t *chThdAddRef(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->p_refs < (trefs_t)255, "too many references");
  tp->p_refs++;
 8003170:	7fa3      	ldrb	r3, [r4, #30]
 8003172:	3301      	adds	r3, #1
 8003174:	77a3      	strb	r3, [r4, #30]
 8003176:	f380 8811 	msr	BASEPRI, r0
  chThdAddRef(tp);
  test_assert(2, tp->p_refs == 2, "references increase failure");
 800317a:	7fa1      	ldrb	r1, [r4, #30]
 800317c:	2002      	movs	r0, #2
 800317e:	ebb1 0e00 	subs.w	lr, r1, r0
 8003182:	f1de 0100 	rsbs	r1, lr, #0
 8003186:	eb51 010e 	adcs.w	r1, r1, lr
 800318a:	f7fd fd21 	bl	8000bd0 <_test_assert>
 800318e:	2800      	cmp	r0, #0
 8003190:	d1ea      	bne.n	8003168 <dyn3_execute.10851+0x28>
  chThdRelease(tp);
 8003192:	4620      	mov	r0, r4
 8003194:	f003 fa64 	bl	8006660 <chThdRelease>
  test_assert(3, tp->p_refs == 1, "references decrease failure");
 8003198:	7fa1      	ldrb	r1, [r4, #30]
 800319a:	1e4a      	subs	r2, r1, #1
 800319c:	4251      	negs	r1, r2
 800319e:	4151      	adcs	r1, r2
 80031a0:	2003      	movs	r0, #3
 80031a2:	f7fd fd15 	bl	8000bd0 <_test_assert>
 80031a6:	2800      	cmp	r0, #0
 80031a8:	d1de      	bne.n	8003168 <dyn3_execute.10851+0x28>

  /* Verify the new threads count.*/
  test_assert(4, regfind(tp), "thread missing from registry");
 80031aa:	4620      	mov	r0, r4
 80031ac:	f7fe fe00 	bl	8001db0 <regfind.10847>
 80031b0:	4601      	mov	r1, r0
 80031b2:	2004      	movs	r0, #4
 80031b4:	f7fd fd0c 	bl	8000bd0 <_test_assert>
 80031b8:	2800      	cmp	r0, #0
 80031ba:	d1d5      	bne.n	8003168 <dyn3_execute.10851+0x28>
  test_assert(5, regfind(tp), "thread disappeared");
 80031bc:	4620      	mov	r0, r4
 80031be:	f7fe fdf7 	bl	8001db0 <regfind.10847>
 80031c2:	4601      	mov	r1, r0
 80031c4:	2005      	movs	r0, #5
 80031c6:	f7fd fd03 	bl	8000bd0 <_test_assert>
 80031ca:	2800      	cmp	r0, #0
 80031cc:	d1cc      	bne.n	8003168 <dyn3_execute.10851+0x28>

  /* Detach and let the thread execute and terminate.*/
  chThdRelease(tp);
 80031ce:	4620      	mov	r0, r4
 80031d0:	f003 fa46 	bl	8006660 <chThdRelease>
  test_assert(6, tp->p_refs == 0, "detach failure");
 80031d4:	7fa1      	ldrb	r1, [r4, #30]
 80031d6:	f1d1 0101 	rsbs	r1, r1, #1
 80031da:	bf38      	it	cc
 80031dc:	2100      	movcc	r1, #0
 80031de:	2006      	movs	r0, #6
 80031e0:	f7fd fcf6 	bl	8000bd0 <_test_assert>
 80031e4:	2800      	cmp	r0, #0
 80031e6:	d1bf      	bne.n	8003168 <dyn3_execute.10851+0x28>
  test_assert(7, tp->p_state == CH_STATE_READY, "invalid state");
 80031e8:	7f21      	ldrb	r1, [r4, #28]
 80031ea:	f1d1 0101 	rsbs	r1, r1, #1
 80031ee:	bf38      	it	cc
 80031f0:	2100      	movcc	r1, #0
 80031f2:	2007      	movs	r0, #7
 80031f4:	f7fd fcec 	bl	8000bd0 <_test_assert>
 80031f8:	2800      	cmp	r0, #0
 80031fa:	d1b5      	bne.n	8003168 <dyn3_execute.10851+0x28>
  test_assert(8, regfind(tp), "thread disappeared");
 80031fc:	4620      	mov	r0, r4
 80031fe:	f7fe fdd7 	bl	8001db0 <regfind.10847>
 8003202:	4601      	mov	r1, r0
 8003204:	2008      	movs	r0, #8
 8003206:	f7fd fce3 	bl	8000bd0 <_test_assert>
 800320a:	2800      	cmp	r0, #0
 800320c:	d1ac      	bne.n	8003168 <dyn3_execute.10851+0x28>
  test_assert(9, regfind(tp), "thread disappeared");
 800320e:	4620      	mov	r0, r4
 8003210:	f7fe fdce 	bl	8001db0 <regfind.10847>
 8003214:	4601      	mov	r1, r0
 8003216:	2009      	movs	r0, #9
 8003218:	f7fd fcda 	bl	8000bd0 <_test_assert>
 800321c:	2800      	cmp	r0, #0
 800321e:	d1a3      	bne.n	8003168 <dyn3_execute.10851+0x28>
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
 8003220:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8003224:	f001 fc74 	bl	8004b10 <chThdSleep>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");
 8003228:	7f21      	ldrb	r1, [r4, #28]
 800322a:	f1b1 030f 	subs.w	r3, r1, #15
 800322e:	4259      	negs	r1, r3
 8003230:	4159      	adcs	r1, r3
 8003232:	200a      	movs	r0, #10
 8003234:	f7fd fccc 	bl	8000bd0 <_test_assert>
 8003238:	2800      	cmp	r0, #0
 800323a:	d195      	bne.n	8003168 <dyn3_execute.10851+0x28>

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
 800323c:	4620      	mov	r0, r4
 800323e:	f7fe fdb7 	bl	8001db0 <regfind.10847>
 8003242:	4601      	mov	r1, r0
 8003244:	200b      	movs	r0, #11
 8003246:	f7fd fcc3 	bl	8000bd0 <_test_assert>
 800324a:	2800      	cmp	r0, #0
 800324c:	d18c      	bne.n	8003168 <dyn3_execute.10851+0x28>
  test_assert(12, !regfind(tp), "thread still in registry");
 800324e:	4620      	mov	r0, r4
 8003250:	f7fe fdae 	bl	8001db0 <regfind.10847>
 8003254:	f080 0101 	eor.w	r1, r0, #1
 8003258:	b2c9      	uxtb	r1, r1
 800325a:	200c      	movs	r0, #12
}
 800325c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
  test_assert(12, !regfind(tp), "thread still in registry");
 8003260:	f7fd bcb6 	b.w	8000bd0 <_test_assert>
 8003264:	20001208 	.word	0x20001208
 8003268:	08006894 	.word	0x08006894
 800326c:	f3af 8000 	nop.w

08003270 <dyn1_execute.10837>:
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn1_execute(void) {
 8003270:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003272:	4b2b      	ldr	r3, [pc, #172]	; (8003320 <dyn1_execute.10837+0xb0>)
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
 8003274:	482b      	ldr	r0, [pc, #172]	; (8003324 <dyn1_execute.10837+0xb4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003276:	699b      	ldr	r3, [r3, #24]
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 8003278:	4c2b      	ldr	r4, [pc, #172]	; (8003328 <dyn1_execute.10837+0xb8>)
 800327a:	689d      	ldr	r5, [r3, #8]
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn1_execute(void) {
 800327c:	b082      	sub	sp, #8
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
 800327e:	a901      	add	r1, sp, #4
 8003280:	f000 ff2e 	bl	80040e0 <chHeapStatus>
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 8003284:	4929      	ldr	r1, [pc, #164]	; (800332c <dyn1_execute.10837+0xbc>)
 8003286:	1e68      	subs	r0, r5, #1
 8003288:	f7ff ff12 	bl	80030b0 <chThdCreateFromHeap.constprop.53.4425>
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 800328c:	4928      	ldr	r1, [pc, #160]	; (8003330 <dyn1_execute.10837+0xc0>)
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 800328e:	6020      	str	r0, [r4, #0]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8003290:	1ea8      	subs	r0, r5, #2
 8003292:	f7ff ff0d 	bl	80030b0 <chThdCreateFromHeap.constprop.53.4425>
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 8003296:	4669      	mov	r1, sp
  (void)chHeapStatus(&heap1, &sz);
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8003298:	6060      	str	r0, [r4, #4]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 800329a:	4822      	ldr	r0, [pc, #136]	; (8003324 <dyn1_execute.10837+0xb4>)
 800329c:	f000 ff20 	bl	80040e0 <chHeapStatus>
  p1 = chHeapAlloc(&heap1, n);
 80032a0:	9900      	ldr	r1, [sp, #0]
 80032a2:	4820      	ldr	r0, [pc, #128]	; (8003324 <dyn1_execute.10837+0xb4>)
 80032a4:	f000 ff8c 	bl	80041c0 <chHeapAlloc>
  threads[2] = chThdCreateFromHeap(&heap1,
 80032a8:	4922      	ldr	r1, [pc, #136]	; (8003334 <dyn1_execute.10837+0xc4>)
  threads[1] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
  p1 = chHeapAlloc(&heap1, n);
 80032aa:	4606      	mov	r6, r0
  threads[2] = chThdCreateFromHeap(&heap1,
 80032ac:	1ee8      	subs	r0, r5, #3
 80032ae:	f7ff feff 	bl	80030b0 <chThdCreateFromHeap.constprop.53.4425>
 80032b2:	60a0      	str	r0, [r4, #8]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);
 80032b4:	4630      	mov	r0, r6
 80032b6:	f000 ff33 	bl	8004120 <chHeapFree>

  test_assert(1, (threads[0] != NULL) &&
 80032ba:	6821      	ldr	r1, [r4, #0]
 80032bc:	b121      	cbz	r1, 80032c8 <dyn1_execute.10837+0x58>
 80032be:	6861      	ldr	r1, [r4, #4]
 80032c0:	b111      	cbz	r1, 80032c8 <dyn1_execute.10837+0x58>
 80032c2:	68a1      	ldr	r1, [r4, #8]
 80032c4:	b319      	cbz	r1, 800330e <dyn1_execute.10837+0x9e>
 80032c6:	2100      	movs	r1, #0
 80032c8:	2001      	movs	r0, #1
 80032ca:	f7fd fc81 	bl	8000bd0 <_test_assert>
 80032ce:	b108      	cbz	r0, 80032d4 <dyn1_execute.10837+0x64>
  test_assert_sequence(2, "AB");

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
  test_assert(4, n == sz, "heap size changed");
}
 80032d0:	b002      	add	sp, #8
 80032d2:	bd70      	pop	{r4, r5, r6, pc}
                 (threads[3] == NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 80032d4:	f7fe fd9c 	bl	8001e10 <test_wait_threads>
  test_assert_sequence(2, "AB");
 80032d8:	2002      	movs	r0, #2
 80032da:	4917      	ldr	r1, [pc, #92]	; (8003338 <dyn1_execute.10837+0xc8>)
 80032dc:	f7fd fc50 	bl	8000b80 <_test_assert_sequence>
 80032e0:	2800      	cmp	r0, #0
 80032e2:	d1f5      	bne.n	80032d0 <dyn1_execute.10837+0x60>

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
 80032e4:	4669      	mov	r1, sp
 80032e6:	480f      	ldr	r0, [pc, #60]	; (8003324 <dyn1_execute.10837+0xb4>)
 80032e8:	f000 fefa 	bl	80040e0 <chHeapStatus>
 80032ec:	1e42      	subs	r2, r0, #1
 80032ee:	4251      	negs	r1, r2
 80032f0:	4151      	adcs	r1, r2
 80032f2:	2003      	movs	r0, #3
 80032f4:	f7fd fc6c 	bl	8000bd0 <_test_assert>
 80032f8:	2800      	cmp	r0, #0
 80032fa:	d1e9      	bne.n	80032d0 <dyn1_execute.10837+0x60>
  test_assert(4, n == sz, "heap size changed");
 80032fc:	e89d 000a 	ldmia.w	sp, {r1, r3}
 8003300:	1acb      	subs	r3, r1, r3
 8003302:	4259      	negs	r1, r3
 8003304:	4159      	adcs	r1, r3
 8003306:	2004      	movs	r0, #4
 8003308:	f7fd fc62 	bl	8000bd0 <_test_assert>
 800330c:	e7e0      	b.n	80032d0 <dyn1_execute.10837+0x60>
  threads[2] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);

  test_assert(1, (threads[0] != NULL) &&
 800330e:	68e3      	ldr	r3, [r4, #12]
 8003310:	2b00      	cmp	r3, #0
 8003312:	d1d9      	bne.n	80032c8 <dyn1_execute.10837+0x58>
 8003314:	6921      	ldr	r1, [r4, #16]
 8003316:	f1d1 0101 	rsbs	r1, r1, #1
 800331a:	bf38      	it	cc
 800331c:	2100      	movcc	r1, #0
 800331e:	e7d3      	b.n	80032c8 <dyn1_execute.10837+0x58>
 8003320:	20001208 	.word	0x20001208
 8003324:	200008d8 	.word	0x200008d8
 8003328:	20001358 	.word	0x20001358
 800332c:	08006894 	.word	0x08006894
 8003330:	08006890 	.word	0x08006890
 8003334:	0800688c 	.word	0x0800688c
 8003338:	080068a0 	.word	0x080068a0
 800333c:	f3af 8000 	nop.w

08003340 <msg1_execute.10050>:
}

static void msg1_execute(void) {
 8003340:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003342:	4b1f      	ldr	r3, [pc, #124]	; (80033c0 <msg1_execute.10050+0x80>)
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8003344:	481f      	ldr	r0, [pc, #124]	; (80033c4 <msg1_execute.10050+0x84>)
 8003346:	6999      	ldr	r1, [r3, #24]
 8003348:	4b1f      	ldr	r3, [pc, #124]	; (80033c8 <msg1_execute.10050+0x88>)
 800334a:	688a      	ldr	r2, [r1, #8]
  chMsgSend(p, 'A');
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
}

static void msg1_execute(void) {
 800334c:	b082      	sub	sp, #8
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800334e:	3201      	adds	r2, #1
 8003350:	9100      	str	r1, [sp, #0]
 8003352:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8003356:	f000 fcb3 	bl	8003cc0 <chThdCreateStatic>
 800335a:	4b1c      	ldr	r3, [pc, #112]	; (80033cc <msg1_execute.10050+0x8c>)
 800335c:	6018      	str	r0, [r3, #0]
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
 800335e:	f000 fd07 	bl	8003d70 <chMsgWait>
 8003362:	2520      	movs	r5, #32
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
}

static void msg1_execute(void) {
  thread_t *tp;
 8003364:	6b06      	ldr	r6, [r0, #48]	; 0x30
 8003366:	f385 8811 	msr	BASEPRI, r5
 800336a:	4631      	mov	r1, r6
 800336c:	f000 fc58 	bl	8003c20 <chSchWakeupS>
 8003370:	2400      	movs	r4, #0
 8003372:	f384 8811 	msr	BASEPRI, r4
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
 8003376:	b2f0      	uxtb	r0, r6
 8003378:	f000 f9ea 	bl	8003750 <test_emit_token>
  tp = chMsgWait();
 800337c:	f000 fcf8 	bl	8003d70 <chMsgWait>
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
}

static void msg1_execute(void) {
  thread_t *tp;
 8003380:	6b06      	ldr	r6, [r0, #48]	; 0x30
 8003382:	f385 8811 	msr	BASEPRI, r5
 8003386:	4631      	mov	r1, r6
 8003388:	f000 fc4a 	bl	8003c20 <chSchWakeupS>
 800338c:	f384 8811 	msr	BASEPRI, r4
  chMsgRelease(tp, msg);
  test_emit_token(msg);
  tp = chMsgWait();
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
 8003390:	b2f0      	uxtb	r0, r6
 8003392:	f000 f9dd 	bl	8003750 <test_emit_token>
  tp = chMsgWait();
 8003396:	f000 fceb 	bl	8003d70 <chMsgWait>
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
}

static void msg1_execute(void) {
  thread_t *tp;
 800339a:	6b06      	ldr	r6, [r0, #48]	; 0x30
 800339c:	f385 8811 	msr	BASEPRI, r5
 80033a0:	4631      	mov	r1, r6
 80033a2:	f000 fc3d 	bl	8003c20 <chSchWakeupS>
 80033a6:	f384 8811 	msr	BASEPRI, r4
  chMsgRelease(tp, msg);
  test_emit_token(msg);
  tp = chMsgWait();
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
 80033aa:	b2f0      	uxtb	r0, r6
 80033ac:	f000 f9d0 	bl	8003750 <test_emit_token>
  test_assert_sequence(1, "ABC");
 80033b0:	4907      	ldr	r1, [pc, #28]	; (80033d0 <msg1_execute.10050+0x90>)
 80033b2:	2001      	movs	r0, #1
}
 80033b4:	b002      	add	sp, #8
 80033b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  test_emit_token(msg);
  tp = chMsgWait();
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
  test_assert_sequence(1, "ABC");
 80033ba:	f7fd bbe1 	b.w	8000b80 <_test_assert_sequence>
 80033be:	bf00      	nop
 80033c0:	20001208 	.word	0x20001208
 80033c4:	20000928 	.word	0x20000928
 80033c8:	08000691 	.word	0x08000691
 80033cc:	20001358 	.word	0x20001358
 80033d0:	08006850 	.word	0x08006850
 80033d4:	f3af 8000 	nop.w
 80033d8:	f3af 8000 	nop.w
 80033dc:	f3af 8000 	nop.w

080033e0 <sys1_execute.11180>:
  sts = chSysGetStatusAndLockX();
  chSysRestoreStatusX(sts);
  chSysUnlockFromISR();
}

static void sys1_execute(void) {
 80033e0:	b510      	push	{r4, lr}
 80033e2:	b086      	sub	sp, #24
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
 80033e4:	f3ef 8312 	mrs	r3, BASEPRI_MAX
 80033e8:	b91b      	cbnz	r3, 80033f2 <sys1_execute.11180+0x12>
 80033ea:	f000 ffb1 	bl	8004350 <chSysGetStatusAndLockX.part.2.4284>
 80033ee:	f000 fc07 	bl	8003c00 <chSysRestoreStatusX.part.3.4287>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80033f2:	2320      	movs	r3, #32
 80033f4:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
 80033f8:	f3ef 8312 	mrs	r3, BASEPRI_MAX
 80033fc:	b91b      	cbnz	r3, 8003406 <sys1_execute.11180+0x26>
 80033fe:	f000 ffa7 	bl	8004350 <chSysGetStatusAndLockX.part.2.4284>
 8003402:	f000 fbfd 	bl	8003c00 <chSysRestoreStatusX.part.3.4287>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003406:	2300      	movs	r3, #0
 8003408:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
 800340c:	f3ef 8312 	mrs	r3, BASEPRI_MAX
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 8003410:	b913      	cbnz	r3, 8003418 <sys1_execute.11180+0x38>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003412:	2320      	movs	r3, #32
 8003414:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
 8003418:	f3ef 8312 	mrs	r3, BASEPRI_MAX
 800341c:	b913      	cbnz	r3, 8003424 <sys1_execute.11180+0x44>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800341e:	2320      	movs	r3, #32
 8003420:	f383 8811 	msr	BASEPRI, r3
 8003424:	2300      	movs	r3, #0
 8003426:	f383 8811 	msr	BASEPRI, r3
 800342a:	2220      	movs	r2, #32
 800342c:	f382 8811 	msr	BASEPRI, r2
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
 8003430:	f3ef 8212 	mrs	r2, BASEPRI_MAX
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 8003434:	b10a      	cbz	r2, 800343a <sys1_execute.11180+0x5a>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003436:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
 800343a:	f3ef 8312 	mrs	r3, BASEPRI_MAX
 800343e:	b113      	cbz	r3, 8003446 <sys1_execute.11180+0x66>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003440:	2300      	movs	r3, #0
 8003442:	f383 8811 	msr	BASEPRI, r3
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->vt_func = NULL;
 8003446:	2300      	movs	r3, #0
 8003448:	9304      	str	r3, [sp, #16]
 800344a:	2320      	movs	r3, #32
 800344c:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8003450:	9b04      	ldr	r3, [sp, #16]
    chVTDoResetI(vtp);
 8003452:	ac01      	add	r4, sp, #4
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8003454:	b113      	cbz	r3, 800345c <sys1_execute.11180+0x7c>
    chVTDoResetI(vtp);
 8003456:	4620      	mov	r0, r4
 8003458:	f000 fa9a 	bl	8003990 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 800345c:	4620      	mov	r0, r4
 800345e:	2101      	movs	r1, #1
 8003460:	4a0b      	ldr	r2, [pc, #44]	; (8003490 <sys1_execute.11180+0xb0>)
 8003462:	2300      	movs	r3, #0
 8003464:	f7fd f924 	bl	80006b0 <chVTDoSetI>
 8003468:	2400      	movs	r4, #0
 800346a:	f384 8811 	msr	BASEPRI, r4
  chSysUnconditionalUnlock();

  /*/Testing from ISR context using a virtual timer.*/
  chVTObjectInit(&vt);
  chVTSet(&vt, 1, vtcb, NULL);
  chThdSleep(10);
 800346e:	200a      	movs	r0, #10
 8003470:	f001 fb4e 	bl	8004b10 <chThdSleep>
 8003474:	2320      	movs	r3, #32
 8003476:	f383 8811 	msr	BASEPRI, r3
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @api
 */
static inline bool chVTIsArmed(virtual_timer_t *vtp) {
 800347a:	9904      	ldr	r1, [sp, #16]
 800347c:	f384 8811 	msr	BASEPRI, r4

  test_assert(1, chVTIsArmed(&vt) == false, "timer still armed");
 8003480:	1b0b      	subs	r3, r1, r4
 8003482:	4259      	negs	r1, r3
 8003484:	4159      	adcs	r1, r3
 8003486:	2001      	movs	r0, #1
 8003488:	f7fd fba2 	bl	8000bd0 <_test_assert>
}
 800348c:	b006      	add	sp, #24
 800348e:	bd10      	pop	{r4, pc}
 8003490:	08001c31 	.word	0x08001c31
 8003494:	f3af 8000 	nop.w
 8003498:	f3af 8000 	nop.w
 800349c:	f3af 8000 	nop.w

080034a0 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 80034a0:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 80034a2:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 80034a6:	4604      	mov	r4, r0
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 80034a8:	2b06      	cmp	r3, #6
 80034aa:	d81a      	bhi.n	80034e2 <_usb_ep0in+0x42>
 80034ac:	e8df f003 	tbb	[pc, r3]
 80034b0:	04213804 	.word	0x04213804
 80034b4:	1a04      	.short	0x1a04
 80034b6:	04          	.byte	0x04
 80034b7:	00          	.byte	0x00
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 80034b8:	6d03      	ldr	r3, [r0, #80]	; 0x50
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80034ba:	6842      	ldr	r2, [r0, #4]
 80034bc:	f8d3 1900 	ldr.w	r1, [r3, #2304]	; 0x900
 80034c0:	6812      	ldr	r2, [r2, #0]
 80034c2:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 80034c6:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 80034ca:	f8d3 1b00 	ldr.w	r1, [r3, #2816]	; 0xb00
 80034ce:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 80034d2:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
 80034d6:	b10a      	cbz	r2, 80034dc <_usb_ep0in+0x3c>
 80034d8:	2105      	movs	r1, #5
 80034da:	4790      	blx	r2
    usbp->ep0state = USB_EP0_ERROR;
 80034dc:	2306      	movs	r3, #6
 80034de:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 80034e2:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 80034e4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80034e6:	b103      	cbz	r3, 80034ea <_usb_ep0in+0x4a>
      usbp->ep0endcb(usbp);
 80034e8:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 80034ea:	2300      	movs	r3, #0
 80034ec:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 80034f0:	bd38      	pop	{r3, r4, r5, pc}
 80034f2:	68c3      	ldr	r3, [r0, #12]
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80034f4:	699b      	ldr	r3, [r3, #24]

  osp->rxqueued           = false;
 80034f6:	2500      	movs	r5, #0
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 80034f8:	2203      	movs	r2, #3
 80034fa:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 80034fe:	4629      	mov	r1, r5
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 8003500:	701d      	strb	r5, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
 8003502:	60dd      	str	r5, [r3, #12]
  osp->rxsize             = n;
 8003504:	605d      	str	r5, [r3, #4]
  osp->rxcnt              = 0;
 8003506:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 8003508:	4620      	mov	r0, r4
 800350a:	f000 f9d1 	bl	80038b0 <usb_lld_prepare_receive>
 800350e:	2320      	movs	r3, #32
 8003510:	f383 8811 	msr	BASEPRI, r3
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    usbPrepareReceive(usbp, 0, NULL, 0);
    osalSysLockFromISR();
    (void) usbStartReceiveI(usbp, 0);
 8003514:	4620      	mov	r0, r4
 8003516:	f7fd fa7b 	bl	8000a10 <usbStartReceiveI.constprop.11>
 800351a:	f385 8811 	msr	BASEPRI, r5
 800351e:	bd38      	pop	{r3, r4, r5, pc}

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 8003520:	f890 104b 	ldrb.w	r1, [r0, #75]	; 0x4b
 8003524:	f890 304a 	ldrb.w	r3, [r0, #74]	; 0x4a
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8003528:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 800352a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 800352e:	4293      	cmp	r3, r2
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8003530:	68c3      	ldr	r3, [r0, #12]
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8003532:	d9df      	bls.n	80034f4 <_usb_ep0in+0x54>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8003534:	8a19      	ldrh	r1, [r3, #16]
 8003536:	fbb2 f5f1 	udiv	r5, r2, r1
 800353a:	fb01 2515 	mls	r5, r1, r5, r2
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 800353e:	2d00      	cmp	r5, #0
 8003540:	d1d8      	bne.n	80034f4 <_usb_ep0in+0x54>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003542:	695b      	ldr	r3, [r3, #20]
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 8003544:	4629      	mov	r1, r5
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8003546:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 8003548:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 800354a:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 800354c:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 800354e:	f000 f987 	bl	8003860 <usb_lld_prepare_transmit>
 8003552:	2320      	movs	r3, #32
 8003554:	f383 8811 	msr	BASEPRI, r3
       transmitted.*/
    if ((usbp->ep0n < max) &&
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      usbPrepareTransmit(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      (void) usbStartTransmitI(usbp, 0);
 8003558:	4620      	mov	r0, r4
 800355a:	f7fd fa71 	bl	8000a40 <usbStartTransmitI.constprop.9>
 800355e:	f385 8811 	msr	BASEPRI, r5
      osalSysUnlockFromISR();
      usbp->ep0state = USB_EP0_WAITING_TX0;
 8003562:	2302      	movs	r3, #2
 8003564:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8003568:	bd38      	pop	{r3, r4, r5, pc}
 800356a:	bf00      	nop
 800356c:	f3af 8000 	nop.w

08003570 <otg_epin_handler.8642>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8003570:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8003574:	6d05      	ldr	r5, [r0, #80]	; 0x50
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8003576:	eb05 1341 	add.w	r3, r5, r1, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 800357a:	4606      	mov	r6, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->ie[ep].DIEPINT;
 800357c:	f8d3 4908 	ldr.w	r4, [r3, #2312]	; 0x908

  otgp->ie[ep].DIEPINT = epint;
 8003580:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8003584:	07e3      	lsls	r3, r4, #31
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8003586:	460f      	mov	r7, r1
  otgp->ie[ep].DIEPINT = epint;

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8003588:	d503      	bpl.n	8003592 <otg_epin_handler.8642+0x22>
 800358a:	f8d5 3810 	ldr.w	r3, [r5, #2064]	; 0x810
 800358e:	07da      	lsls	r2, r3, #31
 8003590:	d40a      	bmi.n	80035a8 <otg_epin_handler.8642+0x38>
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8003592:	0623      	lsls	r3, r4, #24
 8003594:	d506      	bpl.n	80035a4 <otg_epin_handler.8642+0x34>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 8003596:	2201      	movs	r2, #1
 8003598:	f8d5 3834 	ldr.w	r3, [r5, #2100]	; 0x834
 800359c:	fa02 f707 	lsl.w	r7, r2, r7
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 80035a0:	421f      	tst	r7, r3
 80035a2:	d12b      	bne.n	80035fc <otg_epin_handler.8642+0x8c>
 80035a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 80035a8:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 80035ac:	68da      	ldr	r2, [r3, #12]
 80035ae:	6953      	ldr	r3, [r2, #20]

    if (isp->txsize < isp->totsize) {
 80035b0:	f8d3 e004 	ldr.w	lr, [r3, #4]
 80035b4:	f8d3 c010 	ldr.w	ip, [r3, #16]
 80035b8:	45e6      	cmp	lr, ip
 80035ba:	d238      	bcs.n	800362e <otg_epin_handler.8642+0xbe>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 80035bc:	ebce 020c 	rsb	r2, lr, ip
      isp->txcnt  = 0;
 80035c0:	f04f 0800 	mov.w	r8, #0

    if (isp->txsize < isp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 80035c4:	605a      	str	r2, [r3, #4]
      isp->txcnt  = 0;
 80035c6:	f8c3 8008 	str.w	r8, [r3, #8]
      usb_lld_prepare_transmit(usbp, ep);
 80035ca:	f000 f949 	bl	8003860 <usb_lld_prepare_transmit>
 80035ce:	2320      	movs	r3, #32
 80035d0:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80035d4:	6d33      	ldr	r3, [r6, #80]	; 0x50
 80035d6:	eb03 1247 	add.w	r2, r3, r7, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80035da:	2001      	movs	r0, #1
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80035dc:	f8d2 1900 	ldr.w	r1, [r2, #2304]	; 0x900
 80035e0:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
 80035e4:	f8c2 1900 	str.w	r1, [r2, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80035e8:	f8d3 1834 	ldr.w	r1, [r3, #2100]	; 0x834
 80035ec:	fa00 f207 	lsl.w	r2, r0, r7
 80035f0:	430a      	orrs	r2, r1
 80035f2:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
 80035f6:	f388 8811 	msr	BASEPRI, r8
 80035fa:	e7ca      	b.n	8003592 <otg_epin_handler.8642+0x22>
 80035fc:	2320      	movs	r3, #32
 80035fe:	f383 8811 	msr	BASEPRI, r3
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 8003602:	6df2      	ldr	r2, [r6, #92]	; 0x5c
    otgp->DIEPEMPMSK &= ~(1 << ep);
 8003604:	f8d5 1834 	ldr.w	r1, [r5, #2100]	; 0x834
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8003608:	6e33      	ldr	r3, [r6, #96]	; 0x60
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 800360a:	433a      	orrs	r2, r7
    otgp->DIEPEMPMSK &= ~(1 << ep);
 800360c:	ea21 0707 	bic.w	r7, r1, r7
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 8003610:	65f2      	str	r2, [r6, #92]	; 0x5c
    otgp->DIEPEMPMSK &= ~(1 << ep);
 8003612:	f8c5 7834 	str.w	r7, [r5, #2100]	; 0x834
 8003616:	b12b      	cbz	r3, 8003624 <otg_epin_handler.8642+0xb4>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8003618:	2200      	movs	r2, #0
 800361a:	6632      	str	r2, [r6, #96]	; 0x60
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 800361c:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 800361e:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 8003620:	f000 fbee 	bl	8003e00 <chSchReadyI>
 8003624:	2300      	movs	r3, #0
 8003626:	f383 8811 	msr	BASEPRI, r3
 800362a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      usb_lld_start_in(usbp, ep);
      osalSysUnlockFromISR();
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 800362e:	f8b0 e008 	ldrh.w	lr, [r0, #8]
 8003632:	6893      	ldr	r3, [r2, #8]
 8003634:	f04f 0c01 	mov.w	ip, #1
 8003638:	fa0c f201 	lsl.w	r2, ip, r1
 800363c:	ea2e 0202 	bic.w	r2, lr, r2
 8003640:	8102      	strh	r2, [r0, #8]
 8003642:	4798      	blx	r3
 8003644:	e7a5      	b.n	8003592 <otg_epin_handler.8642+0x22>
 8003646:	bf00      	nop
 8003648:	f3af 8000 	nop.w
 800364c:	f3af 8000 	nop.w

08003650 <tmr.9139>:

static virtual_timer_t vt;
static void tmr(void *p) {
  (void)p;

  test_timer_done = TRUE;
 8003650:	4b01      	ldr	r3, [pc, #4]	; (8003658 <tmr.9139+0x8>)
 8003652:	2201      	movs	r2, #1
 8003654:	701a      	strb	r2, [r3, #0]
 8003656:	4770      	bx	lr
 8003658:	200008c4 	.word	0x200008c4
 800365c:	f3af 8000 	nop.w

08003660 <notify2.8995>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8003660:	4b02      	ldr	r3, [pc, #8]	; (800366c <notify2.8995+0xc>)
 8003662:	68da      	ldr	r2, [r3, #12]
 8003664:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003668:	60da      	str	r2, [r3, #12]
 800366a:	4770      	bx	lr
 800366c:	40004400 	.word	0x40004400

08003670 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003670:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8003674:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003676:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800367a:	2300      	movs	r3, #0
 800367c:	f383 8811 	msr	BASEPRI, r3
 8003680:	4770      	bx	lr
 8003682:	bf00      	nop
 8003684:	f3af 8000 	nop.w
 8003688:	f3af 8000 	nop.w
 800368c:	f3af 8000 	nop.w

08003690 <chCoreAlloc>:
 8003690:	2320      	movs	r3, #32
 8003692:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8003696:	4a09      	ldr	r2, [pc, #36]	; (80036bc <chCoreAlloc+0x2c>)
 8003698:	4909      	ldr	r1, [pc, #36]	; (80036c0 <chCoreAlloc+0x30>)
 800369a:	6813      	ldr	r3, [r2, #0]
 800369c:	6809      	ldr	r1, [r1, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 800369e:	3007      	adds	r0, #7
 80036a0:	f020 0007 	bic.w	r0, r0, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 80036a4:	1ac9      	subs	r1, r1, r3
 80036a6:	4288      	cmp	r0, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 80036a8:	bf9b      	ittet	ls
 80036aa:	18c0      	addls	r0, r0, r3
 80036ac:	6010      	strls	r0, [r2, #0]

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 80036ae:	2000      	movhi	r0, #0
  }
  p = nextmem;
  nextmem += size;

  return p;
 80036b0:	4618      	movls	r0, r3
 80036b2:	2300      	movs	r3, #0
 80036b4:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 80036b8:	4770      	bx	lr
 80036ba:	bf00      	nop
 80036bc:	20000f94 	.word	0x20000f94
 80036c0:	200011f0 	.word	0x200011f0
 80036c4:	f3af 8000 	nop.w
 80036c8:	f3af 8000 	nop.w
 80036cc:	f3af 8000 	nop.w

080036d0 <wakeup.4662>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80036d0:	b410      	push	{r4}
 80036d2:	2320      	movs	r3, #32
 80036d4:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 80036d8:	7f03      	ldrb	r3, [r0, #28]
 80036da:	2b07      	cmp	r3, #7
 80036dc:	d80e      	bhi.n	80036fc <wakeup.4662+0x2c>
 80036de:	e8df f003 	tbb	[pc, r3]
 80036e2:	0d27      	.short	0x0d27
 80036e4:	0408230d 	.word	0x0408230d
 80036e8:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 80036ea:	6a03      	ldr	r3, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 80036ec:	689a      	ldr	r2, [r3, #8]
 80036ee:	3201      	adds	r2, #1
 80036f0:	609a      	str	r2, [r3, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 80036f2:	e890 000c 	ldmia.w	r0, {r2, r3}
 80036f6:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 80036f8:	6802      	ldr	r2, [r0, #0]
 80036fa:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80036fc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8003700:	2200      	movs	r2, #0
 8003702:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8003704:	4b0d      	ldr	r3, [pc, #52]	; (800373c <wakeup.4662+0x6c>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8003706:	6204      	str	r4, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8003708:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800370a:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800370c:	689a      	ldr	r2, [r3, #8]
 800370e:	428a      	cmp	r2, r1
 8003710:	d2fb      	bcs.n	800370a <wakeup.4662+0x3a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8003712:	685a      	ldr	r2, [r3, #4]
 8003714:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8003716:	6003      	str	r3, [r0, #0]
 8003718:	2100      	movs	r1, #0
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800371a:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 800371c:	6058      	str	r0, [r3, #4]
 800371e:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8003722:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003726:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8003728:	6a03      	ldr	r3, [r0, #32]
 800372a:	2200      	movs	r2, #0
 800372c:	601a      	str	r2, [r3, #0]
 800372e:	e7e5      	b.n	80036fc <wakeup.4662+0x2c>
 8003730:	2300      	movs	r3, #0
 8003732:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8003736:	f85d 4b04 	ldr.w	r4, [sp], #4
 800373a:	4770      	bx	lr
 800373c:	20001208 	.word	0x20001208

08003740 <_idle_thread.4273>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8003740:	e7fe      	b.n	8003740 <_idle_thread.4273>
 8003742:	bf00      	nop
 8003744:	f3af 8000 	nop.w
 8003748:	f3af 8000 	nop.w
 800374c:	f3af 8000 	nop.w

08003750 <test_emit_token>:
 8003750:	2320      	movs	r3, #32
 8003752:	f383 8811 	msr	BASEPRI, r3
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {

  chSysLock();
  *tokp++ = token;
 8003756:	4a04      	ldr	r2, [pc, #16]	; (8003768 <test_emit_token+0x18>)
 8003758:	6813      	ldr	r3, [r2, #0]
 800375a:	1c59      	adds	r1, r3, #1
 800375c:	6011      	str	r1, [r2, #0]
 800375e:	2200      	movs	r2, #0
 8003760:	7018      	strb	r0, [r3, #0]
 8003762:	f382 8811 	msr	BASEPRI, r2
 8003766:	4770      	bx	lr
 8003768:	20000fc4 	.word	0x20000fc4
 800376c:	f3af 8000 	nop.w

08003770 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 8003770:	b538      	push	{r3, r4, r5, lr}
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003772:	7801      	ldrb	r1, [r0, #0]
 8003774:	4d08      	ldr	r5, [pc, #32]	; (8003798 <test_println+0x28>)
 8003776:	4604      	mov	r4, r0
 8003778:	b139      	cbz	r1, 800378a <test_println+0x1a>
    chSequentialStreamPut(chp, *msgp++);
 800377a:	6828      	ldr	r0, [r5, #0]
 800377c:	6803      	ldr	r3, [r0, #0]
 800377e:	689b      	ldr	r3, [r3, #8]
 8003780:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003782:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8003786:	2900      	cmp	r1, #0
 8003788:	d1f7      	bne.n	800377a <test_println+0xa>
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 800378a:	6828      	ldr	r0, [r5, #0]
 800378c:	4903      	ldr	r1, [pc, #12]	; (800379c <test_println+0x2c>)
 800378e:	6803      	ldr	r3, [r0, #0]
 8003790:	2202      	movs	r2, #2
 8003792:	681b      	ldr	r3, [r3, #0]
 8003794:	4798      	blx	r3
 8003796:	bd38      	pop	{r3, r4, r5, pc}
 8003798:	200014b8 	.word	0x200014b8
 800379c:	080068b0 	.word	0x080068b0

080037a0 <test_print>:
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 80037a0:	b538      	push	{r3, r4, r5, lr}

  while (*msgp)
 80037a2:	7801      	ldrb	r1, [r0, #0]
 80037a4:	b149      	cbz	r1, 80037ba <test_print+0x1a>
 80037a6:	4d05      	ldr	r5, [pc, #20]	; (80037bc <test_print+0x1c>)
 80037a8:	4604      	mov	r4, r0
    chSequentialStreamPut(chp, *msgp++);
 80037aa:	6828      	ldr	r0, [r5, #0]
 80037ac:	6803      	ldr	r3, [r0, #0]
 80037ae:	689b      	ldr	r3, [r3, #8]
 80037b0:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80037b2:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 80037b6:	2900      	cmp	r1, #0
 80037b8:	d1f7      	bne.n	80037aa <test_print+0xa>
 80037ba:	bd38      	pop	{r3, r4, r5, pc}
 80037bc:	200014b8 	.word	0x200014b8

080037c0 <test_printn>:
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 80037c0:	b570      	push	{r4, r5, r6, lr}
 80037c2:	b084      	sub	sp, #16
  char buf[16], *p;

  if (!n)
 80037c4:	b318      	cbz	r0, 800380e <test_printn+0x4e>
 80037c6:	f10d 0501 	add.w	r5, sp, #1
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 80037ca:	4e15      	ldr	r6, [pc, #84]	; (8003820 <test_printn+0x60>)
 80037cc:	462b      	mov	r3, r5
 80037ce:	fba6 1200 	umull	r1, r2, r6, r0
 80037d2:	08d2      	lsrs	r2, r2, #3
 80037d4:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 80037d8:	eba0 0141 	sub.w	r1, r0, r1, lsl #1
 80037dc:	3130      	adds	r1, #48	; 0x30
 80037de:	b2c9      	uxtb	r1, r1
 80037e0:	f803 1c01 	strb.w	r1, [r3, #-1]
 80037e4:	461c      	mov	r4, r3

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
 80037e6:	4610      	mov	r0, r2
 80037e8:	3301      	adds	r3, #1
 80037ea:	2a00      	cmp	r2, #0
 80037ec:	d1ef      	bne.n	80037ce <test_printn+0xe>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 80037ee:	466b      	mov	r3, sp
 80037f0:	429c      	cmp	r4, r3
 80037f2:	d90a      	bls.n	800380a <test_printn+0x4a>
 80037f4:	4e0b      	ldr	r6, [pc, #44]	; (8003824 <test_printn+0x64>)
 80037f6:	e002      	b.n	80037fe <test_printn+0x3e>
 80037f8:	f814 1c02 	ldrb.w	r1, [r4, #-2]
 80037fc:	3c01      	subs	r4, #1
      chSequentialStreamPut(chp, *--p);
 80037fe:	6830      	ldr	r0, [r6, #0]
 8003800:	6803      	ldr	r3, [r0, #0]
 8003802:	689b      	ldr	r3, [r3, #8]
 8003804:	4798      	blx	r3
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8003806:	42ac      	cmp	r4, r5
 8003808:	d1f6      	bne.n	80037f8 <test_printn+0x38>
      chSequentialStreamPut(chp, *--p);
  }
}
 800380a:	b004      	add	sp, #16
 800380c:	bd70      	pop	{r4, r5, r6, pc}
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    chSequentialStreamPut(chp, '0');
 800380e:	4b05      	ldr	r3, [pc, #20]	; (8003824 <test_printn+0x64>)
 8003810:	6818      	ldr	r0, [r3, #0]
 8003812:	6803      	ldr	r3, [r0, #0]
 8003814:	2130      	movs	r1, #48	; 0x30
 8003816:	689b      	ldr	r3, [r3, #8]
 8003818:	4798      	blx	r3
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
      chSequentialStreamPut(chp, *--p);
  }
}
 800381a:	b004      	add	sp, #16
 800381c:	bd70      	pop	{r4, r5, r6, pc}
 800381e:	bf00      	nop
 8003820:	cccccccd 	.word	0xcccccccd
 8003824:	200014b8 	.word	0x200014b8
 8003828:	f3af 8000 	nop.w
 800382c:	f3af 8000 	nop.w

08003830 <print_line.9144>:
    tcp->teardown();

  test_wait_threads();
}

static void print_line(void) {
 8003830:	b570      	push	{r4, r5, r6, lr}
 8003832:	4e08      	ldr	r6, [pc, #32]	; (8003854 <print_line.9144+0x24>)
 8003834:	244c      	movs	r4, #76	; 0x4c
  unsigned i;

  for (i = 0; i < 76; i++)
    chSequentialStreamPut(chp, '-');
 8003836:	6830      	ldr	r0, [r6, #0]
 8003838:	4d06      	ldr	r5, [pc, #24]	; (8003854 <print_line.9144+0x24>)
 800383a:	6803      	ldr	r3, [r0, #0]
 800383c:	212d      	movs	r1, #45	; 0x2d
 800383e:	689b      	ldr	r3, [r3, #8]
 8003840:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 8003842:	3c01      	subs	r4, #1
 8003844:	d1f7      	bne.n	8003836 <print_line.9144+0x6>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8003846:	6828      	ldr	r0, [r5, #0]
 8003848:	4903      	ldr	r1, [pc, #12]	; (8003858 <print_line.9144+0x28>)
 800384a:	6803      	ldr	r3, [r0, #0]
 800384c:	2202      	movs	r2, #2
 800384e:	681b      	ldr	r3, [r3, #0]
 8003850:	4798      	blx	r3
 8003852:	bd70      	pop	{r4, r5, r6, pc}
 8003854:	200014b8 	.word	0x200014b8
 8003858:	080068b0 	.word	0x080068b0
 800385c:	f3af 8000 	nop.w

08003860 <usb_lld_prepare_transmit>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003860:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
 8003864:	b430      	push	{r4, r5}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003866:	68dc      	ldr	r4, [r3, #12]
 8003868:	6962      	ldr	r2, [r4, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 800386a:	6853      	ldr	r3, [r2, #4]
 800386c:	6113      	str	r3, [r2, #16]
  if (isp->txsize == 0) {
 800386e:	b1a3      	cbz	r3, 800389a <usb_lld_prepare_transmit+0x3a>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
 8003870:	b169      	cbz	r1, 800388e <usb_lld_prepare_transmit+0x2e>
 8003872:	1e5d      	subs	r5, r3, #1
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8003874:	8a22      	ldrh	r2, [r4, #16]
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
 8003876:	6d00      	ldr	r0, [r0, #80]	; 0x50
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8003878:	18ac      	adds	r4, r5, r2
 800387a:	fbb4 f2f2 	udiv	r2, r4, r2
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
 800387e:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 8003882:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 8003886:	f8c1 3910 	str.w	r3, [r1, #2320]	; 0x910
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }
}
 800388a:	bc30      	pop	{r4, r5}
 800388c:	4770      	bx	lr
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
 800388e:	2b40      	cmp	r3, #64	; 0x40
 8003890:	d9ef      	bls.n	8003872 <usb_lld_prepare_transmit+0x12>
      isp->txsize = EP0_MAX_INSIZE;
 8003892:	2340      	movs	r3, #64	; 0x40
 8003894:	6053      	str	r3, [r2, #4]
 8003896:	253f      	movs	r5, #63	; 0x3f
 8003898:	e7ec      	b.n	8003874 <usb_lld_prepare_transmit+0x14>

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 800389a:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800389c:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 80038a0:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80038a4:	f8c1 3910 	str.w	r3, [r1, #2320]	; 0x910
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }
}
 80038a8:	bc30      	pop	{r4, r5}
 80038aa:	4770      	bx	lr
 80038ac:	f3af 8000 	nop.w

080038b0 <usb_lld_prepare_receive>:
 *
 * @notapi
 */
void usb_lld_prepare_receive(USBDriver *usbp, usbep_t ep) {
  uint32_t pcnt;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80038b0:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_receive(USBDriver *usbp, usbep_t ep) {
 80038b4:	b430      	push	{r4, r5}
  uint32_t pcnt;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80038b6:	68dc      	ldr	r4, [r3, #12]
 80038b8:	69a2      	ldr	r2, [r4, #24]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 80038ba:	6853      	ldr	r3, [r2, #4]
 80038bc:	6113      	str	r3, [r2, #16]
  if ((ep == 0) && (osp->rxsize  > EP0_MAX_OUTSIZE))
 80038be:	b931      	cbnz	r1, 80038ce <usb_lld_prepare_receive+0x1e>
 80038c0:	2b40      	cmp	r3, #64	; 0x40
 80038c2:	d904      	bls.n	80038ce <usb_lld_prepare_receive+0x1e>
      osp->rxsize = EP0_MAX_OUTSIZE;
 80038c4:	2540      	movs	r5, #64	; 0x40
 80038c6:	6055      	str	r5, [r2, #4]
 80038c8:	4b09      	ldr	r3, [pc, #36]	; (80038f0 <usb_lld_prepare_receive+0x40>)
 80038ca:	253f      	movs	r5, #63	; 0x3f
 80038cc:	e002      	b.n	80038d4 <usb_lld_prepare_receive+0x24>
 80038ce:	1e5d      	subs	r5, r3, #1
 80038d0:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000

  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 80038d4:	8a62      	ldrh	r2, [r4, #18]
         usbp->epc[ep]->out_maxsize;
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 80038d6:	6d00      	ldr	r0, [r0, #80]	; 0x50
  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
  if ((ep == 0) && (osp->rxsize  > EP0_MAX_OUTSIZE))
      osp->rxsize = EP0_MAX_OUTSIZE;

  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 80038d8:	18ac      	adds	r4, r5, r2
 80038da:	fbb4 f2f2 	udiv	r2, r4, r2
         usbp->epc[ep]->out_maxsize;
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 80038de:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 80038e2:	ea43 42c2 	orr.w	r2, r3, r2, lsl #19
 80038e6:	f8c1 2b10 	str.w	r2, [r1, #2832]	; 0xb10
                               DOEPTSIZ_XFRSIZ(osp->rxsize);

}
 80038ea:	bc30      	pop	{r4, r5}
 80038ec:	4770      	bx	lr
 80038ee:	bf00      	nop
 80038f0:	60000040 	.word	0x60000040
 80038f4:	f3af 8000 	nop.w
 80038f8:	f3af 8000 	nop.w
 80038fc:	f3af 8000 	nop.w

08003900 <otg_epout_handler.8634>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8003900:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  stm32_otg_t *otgp = usbp->otg;
 8003902:	6d07      	ldr	r7, [r0, #80]	; 0x50
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8003904:	eb07 1341 	add.w	r3, r7, r1, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8003908:	4605      	mov	r5, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->oe[ep].DOEPINT;
 800390a:	f8d3 4b08 	ldr.w	r4, [r3, #2824]	; 0xb08

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 800390e:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8003912:	0722      	lsls	r2, r4, #28
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8003914:	460e      	mov	r6, r1
  uint32_t epint = otgp->oe[ep].DOEPINT;

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8003916:	d503      	bpl.n	8003920 <otg_epout_handler.8634+0x20>
 8003918:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 800391c:	071b      	lsls	r3, r3, #28
 800391e:	d419      	bmi.n	8003954 <otg_epout_handler.8634+0x54>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);

  }
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8003920:	07e2      	lsls	r2, r4, #31
 8003922:	d516      	bpl.n	8003952 <otg_epout_handler.8634+0x52>
 8003924:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 8003928:	07db      	lsls	r3, r3, #31
 800392a:	d512      	bpl.n	8003952 <otg_epout_handler.8634+0x52>
    /* Receive transfer complete.*/
    USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800392c:	eb05 0386 	add.w	r3, r5, r6, lsl #2
 8003930:	68da      	ldr	r2, [r3, #12]
 8003932:	6993      	ldr	r3, [r2, #24]

    if (osp->rxsize < osp->totsize) {
 8003934:	6859      	ldr	r1, [r3, #4]
 8003936:	6918      	ldr	r0, [r3, #16]
 8003938:	4281      	cmp	r1, r0
 800393a:	d311      	bcc.n	8003960 <otg_epout_handler.8634+0x60>
      usb_lld_start_out(usbp, ep);
      chSysUnlockFromISR();
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 800393c:	8969      	ldrh	r1, [r5, #10]
 800393e:	68d3      	ldr	r3, [r2, #12]
 8003940:	2001      	movs	r0, #1
 8003942:	fa00 f206 	lsl.w	r2, r0, r6
 8003946:	ea21 0202 	bic.w	r2, r1, r2
 800394a:	816a      	strh	r2, [r5, #10]
 800394c:	4631      	mov	r1, r6
 800394e:	4628      	mov	r0, r5
 8003950:	4798      	blx	r3
 8003952:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  otgp->oe[ep].DOEPINT = epint;

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 8003954:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8003958:	68db      	ldr	r3, [r3, #12]
 800395a:	685b      	ldr	r3, [r3, #4]
 800395c:	4798      	blx	r3
 800395e:	e7df      	b.n	8003920 <otg_epout_handler.8634+0x20>

    if (osp->rxsize < osp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 8003960:	1a41      	subs	r1, r0, r1
      osp->rxcnt  = 0;
 8003962:	2400      	movs	r4, #0

    if (osp->rxsize < osp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 8003964:	6059      	str	r1, [r3, #4]
      osp->rxcnt  = 0;
 8003966:	609c      	str	r4, [r3, #8]
      usb_lld_prepare_receive(usbp, ep);
 8003968:	4628      	mov	r0, r5
 800396a:	4631      	mov	r1, r6
 800396c:	f7ff ffa0 	bl	80038b0 <usb_lld_prepare_receive>
 8003970:	2320      	movs	r3, #32
 8003972:	f383 8811 	msr	BASEPRI, r3
 8003976:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8003978:	eb03 1646 	add.w	r6, r3, r6, lsl #5
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_CNAK;
 800397c:	f8d6 3b00 	ldr.w	r3, [r6, #2816]	; 0xb00
 8003980:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8003984:	f8c6 3b00 	str.w	r3, [r6, #2816]	; 0xb00
 8003988:	f384 8811 	msr	BASEPRI, r4
 800398c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800398e:	bf00      	nop

08003990 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8003990:	4a1a      	ldr	r2, [pc, #104]	; (80039fc <chVTDoResetI+0x6c>)
 8003992:	69d3      	ldr	r3, [r2, #28]
 8003994:	4283      	cmp	r3, r0
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8003996:	b410      	push	{r4}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8003998:	d010      	beq.n	80039bc <chVTDoResetI+0x2c>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 800399a:	6841      	ldr	r1, [r0, #4]
 800399c:	6803      	ldr	r3, [r0, #0]
 800399e:	600b      	str	r3, [r1, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 80039a0:	6803      	ldr	r3, [r0, #0]
    vtp->vt_func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 80039a2:	321c      	adds	r2, #28
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
    vtp->vt_func = NULL;
 80039a4:	2400      	movs	r4, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 80039a6:	4293      	cmp	r3, r2
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
 80039a8:	6059      	str	r1, [r3, #4]
    vtp->vt_func = NULL;
 80039aa:	60c4      	str	r4, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 80039ac:	d003      	beq.n	80039b6 <chVTDoResetI+0x26>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 80039ae:	6881      	ldr	r1, [r0, #8]
 80039b0:	689a      	ldr	r2, [r3, #8]
 80039b2:	440a      	add	r2, r1
 80039b4:	609a      	str	r2, [r3, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80039b6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80039ba:	4770      	bx	lr

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80039bc:	4610      	mov	r0, r2
 80039be:	6819      	ldr	r1, [r3, #0]
 80039c0:	f840 1f1c 	str.w	r1, [r0, #28]!
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
  vtp->vt_func = NULL;
 80039c4:	2400      	movs	r4, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80039c6:	4281      	cmp	r1, r0
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80039c8:	6048      	str	r0, [r1, #4]
  vtp->vt_func = NULL;
 80039ca:	60dc      	str	r4, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80039cc:	d011      	beq.n	80039f2 <chVTDoResetI+0x62>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80039ce:	688c      	ldr	r4, [r1, #8]
 80039d0:	689b      	ldr	r3, [r3, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80039d2:	6a90      	ldr	r0, [r2, #40]	; 0x28

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80039d4:	4423      	add	r3, r4
 80039d6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80039da:	608b      	str	r3, [r1, #8]
 80039dc:	6a51      	ldr	r1, [r2, #36]	; 0x24
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80039de:	1a08      	subs	r0, r1, r0

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 80039e0:	4283      	cmp	r3, r0
 80039e2:	d9e8      	bls.n	80039b6 <chVTDoResetI+0x26>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 80039e4:	1a1b      	subs	r3, r3, r0

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80039e6:	2b01      	cmp	r3, #1
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80039e8:	bf98      	it	ls
 80039ea:	2302      	movls	r3, #2
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 80039ec:	440b      	add	r3, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80039ee:	6353      	str	r3, [r2, #52]	; 0x34
 80039f0:	e7e1      	b.n	80039b6 <chVTDoResetI+0x26>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80039f2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80039f6:	60dc      	str	r4, [r3, #12]
 80039f8:	e7dd      	b.n	80039b6 <chVTDoResetI+0x26>
 80039fa:	bf00      	nop
 80039fc:	20001208 	.word	0x20001208

08003a00 <_port_irq_epilogue>:
 8003a00:	2320      	movs	r3, #32
 8003a02:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8003a06:	4b0f      	ldr	r3, [pc, #60]	; (8003a44 <_port_irq_epilogue+0x44>)
 8003a08:	685b      	ldr	r3, [r3, #4]
 8003a0a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8003a0e:	d102      	bne.n	8003a16 <_port_irq_epilogue+0x16>
 8003a10:	f383 8811 	msr	BASEPRI, r3
 8003a14:	4770      	bx	lr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003a16:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8003a1a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8003a1e:	f843 2c04 	str.w	r2, [r3, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8003a22:	f1a3 0220 	sub.w	r2, r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003a26:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8003a2a:	4a07      	ldr	r2, [pc, #28]	; (8003a48 <_port_irq_epilogue+0x48>)
 8003a2c:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->p_prio;
 8003a2e:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8003a30:	6889      	ldr	r1, [r1, #8]
 8003a32:	6892      	ldr	r2, [r2, #8]
 8003a34:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8003a36:	bf8c      	ite	hi
 8003a38:	4a04      	ldrhi	r2, [pc, #16]	; (8003a4c <_port_irq_epilogue+0x4c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8003a3a:	4a05      	ldrls	r2, [pc, #20]	; (8003a50 <_port_irq_epilogue+0x50>)
 8003a3c:	f843 2c08 	str.w	r2, [r3, #-8]
 8003a40:	4770      	bx	lr
 8003a42:	bf00      	nop
 8003a44:	e000ed00 	.word	0xe000ed00
 8003a48:	20001208 	.word	0x20001208
 8003a4c:	080002b1 	.word	0x080002b1
 8003a50:	080002b4 	.word	0x080002b4
 8003a54:	f3af 8000 	nop.w
 8003a58:	f3af 8000 	nop.w
 8003a5c:	f3af 8000 	nop.w

08003a60 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8003a60:	b508      	push	{r3, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003a62:	2220      	movs	r2, #32
 8003a64:	4603      	mov	r3, r0
 8003a66:	f382 8811 	msr	BASEPRI, r2
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->mp_next;
 8003a6a:	6800      	ldr	r0, [r0, #0]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8003a6c:	b128      	cbz	r0, 8003a7a <chPoolAlloc+0x1a>
    mp->mp_next = mp->mp_next->ph_next;
 8003a6e:	6802      	ldr	r2, [r0, #0]
 8003a70:	601a      	str	r2, [r3, #0]
 8003a72:	2300      	movs	r3, #0
 8003a74:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 8003a78:	bd08      	pop	{r3, pc}
  objp = mp->mp_next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->mp_next = mp->mp_next->ph_next;
  }
  else if (mp->mp_provider != NULL) {
 8003a7a:	689a      	ldr	r2, [r3, #8]
 8003a7c:	2a00      	cmp	r2, #0
 8003a7e:	d0f8      	beq.n	8003a72 <chPoolAlloc+0x12>
    objp = mp->mp_provider(mp->mp_object_size);
 8003a80:	6858      	ldr	r0, [r3, #4]
 8003a82:	4790      	blx	r2
 8003a84:	2300      	movs	r3, #0
 8003a86:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 8003a8a:	bd08      	pop	{r3, pc}
 8003a8c:	f3af 8000 	nop.w

08003a90 <chEvtUnregister>:
 8003a90:	2320      	movs	r3, #32
 8003a92:	f383 8811 	msr	BASEPRI, r3
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 8003a96:	4602      	mov	r2, r0
 8003a98:	e002      	b.n	8003aa0 <chEvtUnregister+0x10>
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->el_next == elp) {
 8003a9a:	428b      	cmp	r3, r1
 8003a9c:	d007      	beq.n	8003aae <chEvtUnregister+0x1e>
 8003a9e:	461a      	mov	r2, r3
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 8003aa0:	6813      	ldr	r3, [r2, #0]
 8003aa2:	4283      	cmp	r3, r0
 8003aa4:	d1f9      	bne.n	8003a9a <chEvtUnregister+0xa>
 8003aa6:	2300      	movs	r3, #0
 8003aa8:	f383 8811 	msr	BASEPRI, r3
 8003aac:	4770      	bx	lr
  /*lint -restore*/
    if (p->el_next == elp) {
      p->el_next = elp->el_next;
 8003aae:	680b      	ldr	r3, [r1, #0]
 8003ab0:	6013      	str	r3, [r2, #0]
 8003ab2:	2300      	movs	r3, #0
 8003ab4:	f383 8811 	msr	BASEPRI, r3
 8003ab8:	4770      	bx	lr
 8003aba:	bf00      	nop
 8003abc:	f3af 8000 	nop.w

08003ac0 <chTMStopMeasurementX>:
 8003ac0:	4a0e      	ldr	r2, [pc, #56]	; (8003afc <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8003ac2:	4b0f      	ldr	r3, [pc, #60]	; (8003b00 <chTMStopMeasurementX+0x40>)
 8003ac4:	6851      	ldr	r1, [r2, #4]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8003ac6:	b4f0      	push	{r4, r5, r6, r7}
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8003ac8:	6886      	ldr	r6, [r0, #8]
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8003aca:	6f5f      	ldr	r7, [r3, #116]	; 0x74

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8003acc:	68c5      	ldr	r5, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 8003ace:	6844      	ldr	r4, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8003ad0:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8003ad4:	1b89      	subs	r1, r1, r6
 8003ad6:	1bc9      	subs	r1, r1, r7
  tmp->cumulative += (rttime_t)tmp->last;
 8003ad8:	1852      	adds	r2, r2, r1
 8003ada:	f143 0300 	adc.w	r3, r3, #0

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8003ade:	3501      	adds	r5, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 8003ae0:	42a1      	cmp	r1, r4

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8003ae2:	60c5      	str	r5, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 8003ae4:	6081      	str	r1, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8003ae6:	e9c0 2304 	strd	r2, r3, [r0, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 8003aea:	d805      	bhi.n	8003af8 <chTMStopMeasurementX+0x38>
    tmp->worst = tmp->last;
  }
  else if (tmp->last < tmp->best) {
 8003aec:	6803      	ldr	r3, [r0, #0]
 8003aee:	4299      	cmp	r1, r3
    tmp->best = tmp->last;
 8003af0:	bf38      	it	cc
 8003af2:	6001      	strcc	r1, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8003af4:	bcf0      	pop	{r4, r5, r6, r7}
 8003af6:	4770      	bx	lr
  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 8003af8:	6041      	str	r1, [r0, #4]
 8003afa:	e7fb      	b.n	8003af4 <chTMStopMeasurementX+0x34>
 8003afc:	e0001000 	.word	0xe0001000
 8003b00:	20001208 	.word	0x20001208
 8003b04:	f3af 8000 	nop.w
 8003b08:	f3af 8000 	nop.w
 8003b0c:	f3af 8000 	nop.w

08003b10 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 8003b10:	b570      	push	{r4, r5, r6, lr}
 8003b12:	2320      	movs	r3, #32
 8003b14:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 8003b18:	4a11      	ldr	r2, [pc, #68]	; (8003b60 <chThdYield+0x50>)
 8003b1a:	6810      	ldr	r0, [r2, #0]
 8003b1c:	6995      	ldr	r5, [r2, #24]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 8003b1e:	6883      	ldr	r3, [r0, #8]
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 8003b20:	68ac      	ldr	r4, [r5, #8]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 8003b22:	42a3      	cmp	r3, r4
 8003b24:	d203      	bcs.n	8003b2e <chThdYield+0x1e>
 8003b26:	2300      	movs	r3, #0
 8003b28:	f383 8811 	msr	BASEPRI, r3
 8003b2c:	bd70      	pop	{r4, r5, r6, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8003b2e:	6803      	ldr	r3, [r0, #0]
 8003b30:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8003b32:	2601      	movs	r6, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8003b34:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003b36:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8003b38:	7706      	strb	r6, [r0, #28]
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8003b3a:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8003b3c:	7729      	strb	r1, [r5, #28]
 8003b3e:	e000      	b.n	8003b42 <chThdYield+0x32>
 8003b40:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
 8003b42:	689a      	ldr	r2, [r3, #8]
 8003b44:	4294      	cmp	r4, r2
 8003b46:	d9fb      	bls.n	8003b40 <chThdYield+0x30>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8003b48:	685a      	ldr	r2, [r3, #4]
 8003b4a:	606a      	str	r2, [r5, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8003b4c:	602b      	str	r3, [r5, #0]
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
 8003b4e:	4629      	mov	r1, r5
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8003b50:	6015      	str	r5, [r2, #0]
  cp->p_prev = tp;
 8003b52:	605d      	str	r5, [r3, #4]
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
 8003b54:	f7fc fb9c 	bl	8000290 <_port_switch>
 8003b58:	2300      	movs	r3, #0
 8003b5a:	f383 8811 	msr	BASEPRI, r3
 8003b5e:	bd70      	pop	{r4, r5, r6, pc}
 8003b60:	20001208 	.word	0x20001208
 8003b64:	f3af 8000 	nop.w
 8003b68:	f3af 8000 	nop.w
 8003b6c:	f3af 8000 	nop.w

08003b70 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8003b70:	4a0d      	ldr	r2, [pc, #52]	; (8003ba8 <chSchDoRescheduleAhead+0x38>)
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8003b72:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8003b74:	b470      	push	{r4, r5, r6}

  tqp->p_next = tp->p_next;
 8003b76:	6803      	ldr	r3, [r0, #0]
  thread_t *otp, *cp;

  otp = currp;
 8003b78:	6995      	ldr	r5, [r2, #24]
 8003b7a:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8003b7c:	2601      	movs	r6, #1

  otp->p_state = CH_STATE_READY;
 8003b7e:	2100      	movs	r1, #0
 8003b80:	68ac      	ldr	r4, [r5, #8]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003b82:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8003b84:	7706      	strb	r6, [r0, #28]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8003b86:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8003b88:	7729      	strb	r1, [r5, #28]
 8003b8a:	e000      	b.n	8003b8e <chSchDoRescheduleAhead+0x1e>
 8003b8c:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 8003b8e:	689a      	ldr	r2, [r3, #8]
 8003b90:	42a2      	cmp	r2, r4
 8003b92:	d8fb      	bhi.n	8003b8c <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8003b94:	685a      	ldr	r2, [r3, #4]
 8003b96:	606a      	str	r2, [r5, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8003b98:	602b      	str	r3, [r5, #0]
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8003b9a:	4629      	mov	r1, r5
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
 8003b9c:	6015      	str	r5, [r2, #0]
  cp->p_prev = otp;
 8003b9e:	605d      	str	r5, [r3, #4]

  chSysSwitch(currp, otp);
}
 8003ba0:	bc70      	pop	{r4, r5, r6}
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8003ba2:	f7fc bb75 	b.w	8000290 <_port_switch>
 8003ba6:	bf00      	nop
 8003ba8:	20001208 	.word	0x20001208
 8003bac:	f3af 8000 	nop.w

08003bb0 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8003bb0:	4b04      	ldr	r3, [pc, #16]	; (8003bc4 <chSchRescheduleS+0x14>)
 8003bb2:	681a      	ldr	r2, [r3, #0]
 8003bb4:	699b      	ldr	r3, [r3, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8003bb6:	6892      	ldr	r2, [r2, #8]
 8003bb8:	689b      	ldr	r3, [r3, #8]
 8003bba:	429a      	cmp	r2, r3
 8003bbc:	d800      	bhi.n	8003bc0 <chSchRescheduleS+0x10>
 8003bbe:	4770      	bx	lr
    chSchDoRescheduleAhead();
 8003bc0:	f7ff bfd6 	b.w	8003b70 <chSchDoRescheduleAhead>
 8003bc4:	20001208 	.word	0x20001208
 8003bc8:	f3af 8000 	nop.w
 8003bcc:	f3af 8000 	nop.w

08003bd0 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8003bd0:	b510      	push	{r4, lr}
 8003bd2:	2320      	movs	r3, #32
 8003bd4:	f383 8811 	msr	BASEPRI, r3

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
 8003bd8:	4b08      	ldr	r3, [pc, #32]	; (8003bfc <chThdSetPriority+0x2c>)
 8003bda:	699b      	ldr	r3, [r3, #24]
 8003bdc:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
 8003bde:	6899      	ldr	r1, [r3, #8]
 8003be0:	428c      	cmp	r4, r1
 8003be2:	d001      	beq.n	8003be8 <chThdSetPriority+0x18>
 8003be4:	4281      	cmp	r1, r0
 8003be6:	d200      	bcs.n	8003bea <chThdSetPriority+0x1a>
    currp->p_prio = newprio;
 8003be8:	6098      	str	r0, [r3, #8]
  }
  currp->p_realprio = newprio;
 8003bea:	63d8      	str	r0, [r3, #60]	; 0x3c
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 8003bec:	f7ff ffe0 	bl	8003bb0 <chSchRescheduleS>
 8003bf0:	2300      	movs	r3, #0
 8003bf2:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return oldprio;
}
 8003bf6:	4620      	mov	r0, r4
 8003bf8:	bd10      	pop	{r4, pc}
 8003bfa:	bf00      	nop
 8003bfc:	20001208 	.word	0x20001208

08003c00 <chSysRestoreStatusX.part.3.4287>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 8003c00:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8003c02:	f3ef 8405 	mrs	r4, IPSR
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 8003c06:	f3c4 0408 	ubfx	r4, r4, #0, #9

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 8003c0a:	b11c      	cbz	r4, 8003c14 <chSysRestoreStatusX.part.3.4287+0x14>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003c0c:	2300      	movs	r3, #0
 8003c0e:	f383 8811 	msr	BASEPRI, r3
 8003c12:	bd10      	pop	{r4, pc}
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 8003c14:	f7ff ffcc 	bl	8003bb0 <chSchRescheduleS>
 8003c18:	f384 8811 	msr	BASEPRI, r4
 8003c1c:	bd10      	pop	{r4, pc}
 8003c1e:	bf00      	nop

08003c20 <chSchWakeupS>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8003c20:	f8df c058 	ldr.w	ip, [pc, #88]	; 8003c7c <chSchWakeupS+0x5c>
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003c24:	b4f0      	push	{r4, r5, r6, r7}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8003c26:	f8dc 7018 	ldr.w	r7, [ip, #24]
 8003c2a:	6885      	ldr	r5, [r0, #8]
 8003c2c:	68bc      	ldr	r4, [r7, #8]

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8003c2e:	6201      	str	r1, [r0, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8003c30:	42a5      	cmp	r5, r4
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003c32:	4606      	mov	r6, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8003c34:	d80d      	bhi.n	8003c52 <chSchWakeupS+0x32>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8003c36:	2200      	movs	r2, #0
  cp = (thread_t *)&ch.rlist.r_queue;
 8003c38:	4663      	mov	r3, ip
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8003c3a:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8003c3c:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8003c3e:	689a      	ldr	r2, [r3, #8]
 8003c40:	4295      	cmp	r5, r2
 8003c42:	d9fb      	bls.n	8003c3c <chSchWakeupS+0x1c>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8003c44:	685a      	ldr	r2, [r3, #4]
 8003c46:	6072      	str	r2, [r6, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8003c48:	6033      	str	r3, [r6, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8003c4a:	6016      	str	r6, [r2, #0]
  cp->p_prev = tp;
 8003c4c:	605e      	str	r6, [r3, #4]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 8003c4e:	bcf0      	pop	{r4, r5, r6, r7}
 8003c50:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8003c52:	2300      	movs	r3, #0
 8003c54:	773b      	strb	r3, [r7, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8003c56:	4663      	mov	r3, ip
  do {
    cp = cp->p_next;
 8003c58:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8003c5a:	689a      	ldr	r2, [r3, #8]
 8003c5c:	4294      	cmp	r4, r2
 8003c5e:	d9fb      	bls.n	8003c58 <chSchWakeupS+0x38>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8003c60:	685a      	ldr	r2, [r3, #4]
 8003c62:	607a      	str	r2, [r7, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8003c64:	2401      	movs	r4, #1
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8003c66:	603b      	str	r3, [r7, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8003c68:	6017      	str	r7, [r2, #0]
  cp->p_prev = tp;
 8003c6a:	605f      	str	r7, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8003c6c:	7734      	strb	r4, [r6, #28]
    chSysSwitch(ntp, otp);
 8003c6e:	4639      	mov	r1, r7
 8003c70:	4630      	mov	r0, r6
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 8003c72:	f8cc 6018 	str.w	r6, [ip, #24]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 8003c76:	bcf0      	pop	{r4, r5, r6, r7}
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8003c78:	f7fc bb0a 	b.w	8000290 <_port_switch>
 8003c7c:	20001208 	.word	0x20001208

08003c80 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 8003c80:	b508      	push	{r3, lr}
 8003c82:	2220      	movs	r2, #32
 8003c84:	4603      	mov	r3, r0
 8003c86:	f382 8811 	msr	BASEPRI, r2
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sp->s_cnt <= (cnt_t)0) {
 8003c8a:	6882      	ldr	r2, [r0, #8]
 8003c8c:	3201      	adds	r2, #1
 8003c8e:	2a00      	cmp	r2, #0
 8003c90:	6082      	str	r2, [r0, #8]
 8003c92:	dd03      	ble.n	8003c9c <chSemSignal+0x1c>
 8003c94:	2300      	movs	r3, #0
 8003c96:	f383 8811 	msr	BASEPRI, r3
 8003c9a:	bd08      	pop	{r3, pc}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8003c9c:	6800      	ldr	r0, [r0, #0]

  tqp->p_next = tp->p_next;
 8003c9e:	6802      	ldr	r2, [r0, #0]
 8003ca0:	601a      	str	r2, [r3, #0]
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
 8003ca2:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003ca4:	6053      	str	r3, [r2, #4]
 8003ca6:	f7ff ffbb 	bl	8003c20 <chSchWakeupS>
 8003caa:	2300      	movs	r3, #0
 8003cac:	f383 8811 	msr	BASEPRI, r3
 8003cb0:	bd08      	pop	{r3, pc}
 8003cb2:	bf00      	nop
 8003cb4:	f3af 8000 	nop.w
 8003cb8:	f3af 8000 	nop.w
 8003cbc:	f3af 8000 	nop.w

08003cc0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8003cc0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003cc4:	4604      	mov	r4, r0
 8003cc6:	2520      	movs	r5, #32
 8003cc8:	f385 8811 	msr	BASEPRI, r5
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8003ccc:	4e18      	ldr	r6, [pc, #96]	; (8003d30 <chThdCreateStatic+0x70>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8003cce:	f8df a064 	ldr.w	sl, [pc, #100]	; 8003d34 <chThdCreateStatic+0x74>
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8003cd2:	f8d6 e014 	ldr.w	lr, [r6, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8003cd6:	3924      	subs	r1, #36	; 0x24
 8003cd8:	1847      	adds	r7, r0, r1
 8003cda:	60c7      	str	r7, [r0, #12]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8003cdc:	2500      	movs	r5, #0

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8003cde:	5043      	str	r3, [r0, r1]
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8003ce0:	f100 0c24 	add.w	ip, r0, #36	; 0x24
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8003ce4:	f100 0328 	add.w	r3, r0, #40	; 0x28

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8003ce8:	9908      	ldr	r1, [sp, #32]
 8003cea:	6079      	str	r1, [r7, #4]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8003cec:	f04f 0902 	mov.w	r9, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8003cf0:	f04f 0801 	mov.w	r8, #1

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8003cf4:	f8c7 a020 	str.w	sl, [r7, #32]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 8003cf8:	4629      	mov	r1, r5
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8003cfa:	6082      	str	r2, [r0, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8003cfc:	6106      	str	r6, [r0, #16]
 8003cfe:	f8c0 e014 	str.w	lr, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8003d02:	63c2      	str	r2, [r0, #60]	; 0x3c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8003d04:	f880 901c 	strb.w	r9, [r0, #28]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8003d08:	f880 801e 	strb.w	r8, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8003d0c:	7745      	strb	r5, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8003d0e:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8003d10:	6345      	str	r5, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8003d12:	6185      	str	r5, [r0, #24]
  REG_INSERT(tp);
 8003d14:	f8ce 0010 	str.w	r0, [lr, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8003d18:	f8c0 c024 	str.w	ip, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003d1c:	6283      	str	r3, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8003d1e:	62c3      	str	r3, [r0, #44]	; 0x2c
 8003d20:	6170      	str	r0, [r6, #20]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 8003d22:	f7ff ff7d 	bl	8003c20 <chSchWakeupS>
 8003d26:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 8003d2a:	4620      	mov	r0, r4
 8003d2c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8003d30:	20001208 	.word	0x20001208
 8003d34:	080002a1 	.word	0x080002a1
 8003d38:	f3af 8000 	nop.w
 8003d3c:	f3af 8000 	nop.w

08003d40 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8003d40:	4b07      	ldr	r3, [pc, #28]	; (8003d60 <chSchGoSleepS+0x20>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8003d42:	b430      	push	{r4, r5}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8003d44:	681a      	ldr	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8003d46:	6999      	ldr	r1, [r3, #24]

  tqp->p_next = tp->p_next;
 8003d48:	6814      	ldr	r4, [r2, #0]
  otp->p_state = newstate;
 8003d4a:	7708      	strb	r0, [r1, #28]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8003d4c:	2501      	movs	r5, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003d4e:	6063      	str	r3, [r4, #4]
 8003d50:	7715      	strb	r5, [r2, #28]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8003d52:	601c      	str	r4, [r3, #0]
  chSysSwitch(currp, otp);
 8003d54:	4610      	mov	r0, r2
}
 8003d56:	bc30      	pop	{r4, r5}
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8003d58:	619a      	str	r2, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8003d5a:	f7fc ba99 	b.w	8000290 <_port_switch>
 8003d5e:	bf00      	nop
 8003d60:	20001208 	.word	0x20001208
 8003d64:	f3af 8000 	nop.w
 8003d68:	f3af 8000 	nop.w
 8003d6c:	f3af 8000 	nop.w

08003d70 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8003d70:	b510      	push	{r4, lr}
 8003d72:	2320      	movs	r3, #32
 8003d74:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
 8003d78:	4c0b      	ldr	r4, [pc, #44]	; (8003da8 <chMsgWait+0x38>)
 8003d7a:	69a2      	ldr	r2, [r4, #24]
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();

  return (bool)(tp->p_msgqueue.p_next != (thread_t *)&tp->p_msgqueue);
 8003d7c:	4613      	mov	r3, r2
 8003d7e:	f853 0f28 	ldr.w	r0, [r3, #40]!
 8003d82:	4298      	cmp	r0, r3
 8003d84:	d008      	beq.n	8003d98 <chMsgWait+0x28>
 8003d86:	6801      	ldr	r1, [r0, #0]
 8003d88:	6291      	str	r1, [r2, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTMSG);
  }
  tp = queue_fifo_remove(&currp->p_msgqueue);
  tp->p_state = CH_STATE_SNDMSG;
 8003d8a:	220d      	movs	r2, #13
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003d8c:	604b      	str	r3, [r1, #4]
 8003d8e:	2300      	movs	r3, #0
 8003d90:	7702      	strb	r2, [r0, #28]
 8003d92:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8003d96:	bd10      	pop	{r4, pc}
thread_t *chMsgWait(void) {
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
    chSchGoSleepS(CH_STATE_WTMSG);
 8003d98:	200e      	movs	r0, #14
 8003d9a:	f7ff ffd1 	bl	8003d40 <chSchGoSleepS>
 8003d9e:	69a2      	ldr	r2, [r4, #24]
 8003da0:	6a90      	ldr	r0, [r2, #40]	; 0x28
 8003da2:	f102 0328 	add.w	r3, r2, #40	; 0x28
 8003da6:	e7ee      	b.n	8003d86 <chMsgWait+0x16>
 8003da8:	20001208 	.word	0x20001208
 8003dac:	f3af 8000 	nop.w

08003db0 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 8003db0:	b510      	push	{r4, lr}
 8003db2:	4603      	mov	r3, r0
 8003db4:	2220      	movs	r2, #32
 8003db6:	f382 8811 	msr	BASEPRI, r2
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8003dba:	6882      	ldr	r2, [r0, #8]
 8003dbc:	3a01      	subs	r2, #1
 8003dbe:	2a00      	cmp	r2, #0
 8003dc0:	6082      	str	r2, [r0, #8]
 8003dc2:	db04      	blt.n	8003dce <chSemWait+0x1e>
    chSchGoSleepS(CH_STATE_WTSEM);

    return currp->p_u.rdymsg;
  }

  return MSG_OK;
 8003dc4:	2000      	movs	r0, #0
 8003dc6:	2300      	movs	r3, #0
 8003dc8:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 8003dcc:	bd10      	pop	{r4, pc}
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    currp->p_u.wtsemp = sp;
 8003dce:	4c08      	ldr	r4, [pc, #32]	; (8003df0 <chSemWait+0x40>)
 8003dd0:	69a2      	ldr	r2, [r4, #24]
 8003dd2:	6210      	str	r0, [r2, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8003dd4:	6841      	ldr	r1, [r0, #4]
 8003dd6:	6051      	str	r1, [r2, #4]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 8003dd8:	6010      	str	r0, [r2, #0]
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
 8003dda:	600a      	str	r2, [r1, #0]
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 8003ddc:	2005      	movs	r0, #5
  tqp->p_prev = tp;
 8003dde:	605a      	str	r2, [r3, #4]
 8003de0:	f7ff ffae 	bl	8003d40 <chSchGoSleepS>

    return currp->p_u.rdymsg;
 8003de4:	69a3      	ldr	r3, [r4, #24]
 8003de6:	6a18      	ldr	r0, [r3, #32]
 8003de8:	2300      	movs	r3, #0
 8003dea:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 8003dee:	bd10      	pop	{r4, pc}
 8003df0:	20001208 	.word	0x20001208
 8003df4:	f3af 8000 	nop.w
 8003df8:	f3af 8000 	nop.w
 8003dfc:	f3af 8000 	nop.w

08003e00 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8003e00:	2200      	movs	r2, #0
 8003e02:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8003e04:	4b08      	ldr	r3, [pc, #32]	; (8003e28 <chSchReadyI+0x28>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8003e06:	b410      	push	{r4}
 8003e08:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8003e0a:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8003e0c:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8003e0e:	689a      	ldr	r2, [r3, #8]
 8003e10:	428a      	cmp	r2, r1
 8003e12:	d2fb      	bcs.n	8003e0c <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8003e14:	685a      	ldr	r2, [r3, #4]
 8003e16:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8003e18:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;

  return tp;
}
 8003e1a:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8003e1c:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8003e1e:	605c      	str	r4, [r3, #4]

  return tp;
}
 8003e20:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003e24:	4770      	bx	lr
 8003e26:	bf00      	nop
 8003e28:	20001208 	.word	0x20001208
 8003e2c:	f3af 8000 	nop.w

08003e30 <chMsgSend>:
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
  thread_t *ctp = currp;
 8003e30:	4b0e      	ldr	r3, [pc, #56]	; (8003e6c <chMsgSend+0x3c>)
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8003e32:	b570      	push	{r4, r5, r6, lr}
 8003e34:	2220      	movs	r2, #32
  thread_t *ctp = currp;
 8003e36:	699c      	ldr	r4, [r3, #24]
 8003e38:	f382 8811 	msr	BASEPRI, r2

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 8003e3c:	f100 0528 	add.w	r5, r0, #40	; 0x28
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
 8003e40:	7f06      	ldrb	r6, [r0, #28]

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 8003e42:	6225      	str	r5, [r4, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8003e44:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8003e46:	6062      	str	r2, [r4, #4]
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
 8003e48:	2e0e      	cmp	r6, #14
  thread_t *ctp = currp;

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
 8003e4a:	6321      	str	r1, [r4, #48]	; 0x30
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 8003e4c:	6025      	str	r5, [r4, #0]
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
 8003e4e:	6014      	str	r4, [r2, #0]
  tqp->p_prev = tp;
 8003e50:	62c4      	str	r4, [r0, #44]	; 0x2c
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
 8003e52:	d007      	beq.n	8003e64 <chMsgSend+0x34>
    (void) chSchReadyI(tp);
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8003e54:	200c      	movs	r0, #12
 8003e56:	f7ff ff73 	bl	8003d40 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 8003e5a:	6a20      	ldr	r0, [r4, #32]
 8003e5c:	2300      	movs	r3, #0
 8003e5e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return msg;
}
 8003e62:	bd70      	pop	{r4, r5, r6, pc}
  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
    (void) chSchReadyI(tp);
 8003e64:	f7ff ffcc 	bl	8003e00 <chSchReadyI>
 8003e68:	e7f4      	b.n	8003e54 <chMsgSend+0x24>
 8003e6a:	bf00      	nop
 8003e6c:	20001208 	.word	0x20001208

08003e70 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8003e70:	6b42      	ldr	r2, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8003e72:	7f03      	ldrb	r3, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8003e74:	4311      	orrs	r1, r2
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8003e76:	2b0a      	cmp	r3, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8003e78:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8003e7a:	d00a      	beq.n	8003e92 <chEvtSignalI+0x22>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8003e7c:	2b0b      	cmp	r3, #11
 8003e7e:	d000      	beq.n	8003e82 <chEvtSignalI+0x12>
 8003e80:	4770      	bx	lr
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8003e82:	6a03      	ldr	r3, [r0, #32]
 8003e84:	4019      	ands	r1, r3

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8003e86:	428b      	cmp	r3, r1
 8003e88:	d1fa      	bne.n	8003e80 <chEvtSignalI+0x10>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8003e8a:	2300      	movs	r3, #0
 8003e8c:	6203      	str	r3, [r0, #32]
    (void) chSchReadyI(tp);
 8003e8e:	f7ff bfb7 	b.w	8003e00 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8003e92:	6a03      	ldr	r3, [r0, #32]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8003e94:	4219      	tst	r1, r3
 8003e96:	d1f8      	bne.n	8003e8a <chEvtSignalI+0x1a>
 8003e98:	4770      	bx	lr
 8003e9a:	bf00      	nop
 8003e9c:	f3af 8000 	nop.w

08003ea0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8003ea0:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8003ea2:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8003ea4:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8003ea6:	4606      	mov	r6, r0
 8003ea8:	460d      	mov	r5, r1
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8003eaa:	d00d      	beq.n	8003ec8 <chEvtBroadcastFlagsI+0x28>
  /*lint -restore*/
    elp->el_flags |= flags;
 8003eac:	68e3      	ldr	r3, [r4, #12]
 8003eae:	432b      	orrs	r3, r5
 8003eb0:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8003eb2:	b115      	cbz	r5, 8003eba <chEvtBroadcastFlagsI+0x1a>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 8003eb4:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8003eb6:	4213      	tst	r3, r2
 8003eb8:	d003      	beq.n	8003ec2 <chEvtBroadcastFlagsI+0x22>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8003eba:	6860      	ldr	r0, [r4, #4]
 8003ebc:	68a1      	ldr	r1, [r4, #8]
 8003ebe:	f7ff ffd7 	bl	8003e70 <chEvtSignalI>
    }
    elp = elp->el_next;
 8003ec2:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8003ec4:	42a6      	cmp	r6, r4
 8003ec6:	d1f1      	bne.n	8003eac <chEvtBroadcastFlagsI+0xc>
 8003ec8:	bd70      	pop	{r4, r5, r6, pc}
 8003eca:	bf00      	nop
 8003ecc:	f3af 8000 	nop.w

08003ed0 <chMtxUnlockAll>:
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  thread_t *ctp = currp;
 8003ed0:	4a13      	ldr	r2, [pc, #76]	; (8003f20 <chMtxUnlockAll+0x50>)
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 8003ed2:	b570      	push	{r4, r5, r6, lr}
 8003ed4:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 8003ed6:	6994      	ldr	r4, [r2, #24]
 8003ed8:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
 8003edc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003ede:	b1d3      	cbz	r3, 8003f16 <chMtxUnlockAll+0x46>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 8003ee0:	2600      	movs	r6, #0
 8003ee2:	e00b      	b.n	8003efc <chMtxUnlockAll+0x2c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8003ee4:	6811      	ldr	r1, [r2, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
        mp->m_next = tp->p_mtxlist;
 8003ee6:	6b95      	ldr	r5, [r2, #56]	; 0x38
 8003ee8:	6019      	str	r1, [r3, #0]
        tp->p_mtxlist = mp;
        (void) chSchReadyI(tp);
 8003eea:	4610      	mov	r0, r2
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003eec:	604b      	str	r3, [r1, #4]
      if (chMtxQueueNotEmptyS(mp)) {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
 8003eee:	609a      	str	r2, [r3, #8]
        mp->m_next = tp->p_mtxlist;
 8003ef0:	60dd      	str	r5, [r3, #12]
        tp->p_mtxlist = mp;
 8003ef2:	6393      	str	r3, [r2, #56]	; 0x38
        (void) chSchReadyI(tp);
 8003ef4:	f7ff ff84 	bl	8003e00 <chSchReadyI>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
      }
    } while (ctp->p_mtxlist != NULL);
 8003ef8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003efa:	b143      	cbz	r3, 8003f0e <chMtxUnlockAll+0x3e>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8003efc:	681a      	ldr	r2, [r3, #0]

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->p_mtxlist;
      ctp->p_mtxlist = mp->m_next;
 8003efe:	68d9      	ldr	r1, [r3, #12]
 8003f00:	63a1      	str	r1, [r4, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 8003f02:	4293      	cmp	r3, r2
 8003f04:	d1ee      	bne.n	8003ee4 <chMtxUnlockAll+0x14>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 8003f06:	609e      	str	r6, [r3, #8]
      }
    } while (ctp->p_mtxlist != NULL);
 8003f08:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003f0a:	2b00      	cmp	r3, #0
 8003f0c:	d1f6      	bne.n	8003efc <chMtxUnlockAll+0x2c>
    ctp->p_prio = ctp->p_realprio;
 8003f0e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8003f10:	60a3      	str	r3, [r4, #8]
    chSchRescheduleS();
 8003f12:	f7ff fe4d 	bl	8003bb0 <chSchRescheduleS>
 8003f16:	2300      	movs	r3, #0
 8003f18:	f383 8811 	msr	BASEPRI, r3
 8003f1c:	bd70      	pop	{r4, r5, r6, pc}
 8003f1e:	bf00      	nop
 8003f20:	20001208 	.word	0x20001208
 8003f24:	f3af 8000 	nop.w
 8003f28:	f3af 8000 	nop.w
 8003f2c:	f3af 8000 	nop.w

08003f30 <chMtxUnlockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8003f30:	4b12      	ldr	r3, [pc, #72]	; (8003f7c <chMtxUnlockS+0x4c>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8003f32:	b430      	push	{r4, r5}
 8003f34:	4604      	mov	r4, r0
 8003f36:	6805      	ldr	r5, [r0, #0]
  thread_t *ctp = currp;
 8003f38:	6998      	ldr	r0, [r3, #24]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8003f3a:	68e3      	ldr	r3, [r4, #12]
 8003f3c:	6383      	str	r3, [r0, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8003f3e:	42ac      	cmp	r4, r5
 8003f40:	d017      	beq.n	8003f72 <chMtxUnlockS+0x42>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8003f42:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8003f44:	b14b      	cbz	r3, 8003f5a <chMtxUnlockS+0x2a>
 8003f46:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8003f48:	4293      	cmp	r3, r2
 8003f4a:	d003      	beq.n	8003f54 <chMtxUnlockS+0x24>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 8003f4c:	6892      	ldr	r2, [r2, #8]
 8003f4e:	4291      	cmp	r1, r2
 8003f50:	bf38      	it	cc
 8003f52:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 8003f54:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8003f56:	2b00      	cmp	r3, #0
 8003f58:	d1f5      	bne.n	8003f46 <chMtxUnlockS+0x16>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8003f5a:	682b      	ldr	r3, [r5, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8003f5c:	6baa      	ldr	r2, [r5, #56]	; 0x38
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8003f5e:	6081      	str	r1, [r0, #8]
 8003f60:	6023      	str	r3, [r4, #0]
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      (void) chSchReadyI(tp);
 8003f62:	4628      	mov	r0, r5
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003f64:	605c      	str	r4, [r3, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 8003f66:	60a5      	str	r5, [r4, #8]
      mp->m_next = tp->p_mtxlist;
 8003f68:	60e2      	str	r2, [r4, #12]
      tp->p_mtxlist = mp;
 8003f6a:	63ac      	str	r4, [r5, #56]	; 0x38
      mp->m_owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 8003f6c:	bc30      	pop	{r4, r5}
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      (void) chSchReadyI(tp);
 8003f6e:	f7ff bf47 	b.w	8003e00 <chSchReadyI>
    }
    else {
      mp->m_owner = NULL;
 8003f72:	2300      	movs	r3, #0
 8003f74:	60a3      	str	r3, [r4, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 8003f76:	bc30      	pop	{r4, r5}
 8003f78:	4770      	bx	lr
 8003f7a:	bf00      	nop
 8003f7c:	20001208 	.word	0x20001208

08003f80 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8003f80:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8003f82:	4b17      	ldr	r3, [pc, #92]	; (8003fe0 <chMtxUnlock+0x60>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8003f84:	4604      	mov	r4, r0
  thread_t *ctp = currp;
 8003f86:	6998      	ldr	r0, [r3, #24]
 8003f88:	2320      	movs	r3, #32
 8003f8a:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8003f8e:	6825      	ldr	r5, [r4, #0]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8003f90:	68e3      	ldr	r3, [r4, #12]
 8003f92:	6383      	str	r3, [r0, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8003f94:	42ac      	cmp	r4, r5
 8003f96:	d01c      	beq.n	8003fd2 <chMtxUnlock+0x52>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8003f98:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8003f9a:	b14b      	cbz	r3, 8003fb0 <chMtxUnlock+0x30>
 8003f9c:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8003f9e:	4293      	cmp	r3, r2
 8003fa0:	d003      	beq.n	8003faa <chMtxUnlock+0x2a>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 8003fa2:	6892      	ldr	r2, [r2, #8]
 8003fa4:	4291      	cmp	r1, r2
 8003fa6:	bf38      	it	cc
 8003fa8:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 8003faa:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8003fac:	2b00      	cmp	r3, #0
 8003fae:	d1f5      	bne.n	8003f9c <chMtxUnlock+0x1c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8003fb0:	682b      	ldr	r3, [r5, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8003fb2:	6baa      	ldr	r2, [r5, #56]	; 0x38
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8003fb4:	6081      	str	r1, [r0, #8]
 8003fb6:	6023      	str	r3, [r4, #0]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8003fb8:	4628      	mov	r0, r5
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003fba:	605c      	str	r4, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8003fbc:	60e2      	str	r2, [r4, #12]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 8003fbe:	60a5      	str	r5, [r4, #8]
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
 8003fc0:	63ac      	str	r4, [r5, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8003fc2:	f7ff ff1d 	bl	8003e00 <chSchReadyI>
      chSchRescheduleS();
 8003fc6:	f7ff fdf3 	bl	8003bb0 <chSchRescheduleS>
 8003fca:	2300      	movs	r3, #0
 8003fcc:	f383 8811 	msr	BASEPRI, r3
 8003fd0:	bd38      	pop	{r3, r4, r5, pc}
    }
    else {
      mp->m_owner = NULL;
 8003fd2:	2300      	movs	r3, #0
 8003fd4:	60a3      	str	r3, [r4, #8]
 8003fd6:	2300      	movs	r3, #0
 8003fd8:	f383 8811 	msr	BASEPRI, r3
 8003fdc:	bd38      	pop	{r3, r4, r5, pc}
 8003fde:	bf00      	nop
 8003fe0:	20001208 	.word	0x20001208
 8003fe4:	f3af 8000 	nop.w
 8003fe8:	f3af 8000 	nop.w
 8003fec:	f3af 8000 	nop.w

08003ff0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8003ff0:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8003ff2:	4b2f      	ldr	r3, [pc, #188]	; (80040b0 <chMtxLockS+0xc0>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8003ff4:	4605      	mov	r5, r0

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8003ff6:	6880      	ldr	r0, [r0, #8]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8003ff8:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8003ffa:	2800      	cmp	r0, #0
 8003ffc:	d053      	beq.n	80040a6 <chMtxLockS+0xb6>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8003ffe:	68a2      	ldr	r2, [r4, #8]
 8004000:	6883      	ldr	r3, [r0, #8]
 8004002:	4293      	cmp	r3, r2
 8004004:	d206      	bcs.n	8004014 <chMtxLockS+0x24>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8004006:	7f03      	ldrb	r3, [r0, #28]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8004008:	6082      	str	r2, [r0, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 800400a:	2b06      	cmp	r3, #6
 800400c:	d032      	beq.n	8004074 <chMtxLockS+0x84>
 800400e:	2b07      	cmp	r3, #7
 8004010:	d01c      	beq.n	800404c <chMtxLockS+0x5c>
 8004012:	b19b      	cbz	r3, 800403c <chMtxLockS+0x4c>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8004014:	462b      	mov	r3, r5
 8004016:	e003      	b.n	8004020 <chMtxLockS+0x30>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8004018:	6899      	ldr	r1, [r3, #8]
 800401a:	68a2      	ldr	r2, [r4, #8]
 800401c:	4291      	cmp	r1, r2
 800401e:	d302      	bcc.n	8004026 <chMtxLockS+0x36>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8004020:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8004022:	429d      	cmp	r5, r3
 8004024:	d1f8      	bne.n	8004018 <chMtxLockS+0x28>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8004026:	685a      	ldr	r2, [r3, #4]
 8004028:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800402a:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800402c:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800402e:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
 8004030:	6225      	str	r5, [r4, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8004032:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
 8004034:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8004038:	f7ff be82 	b.w	8003d40 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800403c:	e890 000c 	ldmia.w	r0, {r2, r3}
 8004040:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8004042:	6802      	ldr	r2, [r0, #0]
 8004044:	6053      	str	r3, [r2, #4]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8004046:	f7ff fedb 	bl	8003e00 <chSchReadyI>
 800404a:	e7e3      	b.n	8004014 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800404c:	e890 000a 	ldmia.w	r0, {r1, r3}
 8004050:	6019      	str	r1, [r3, #0]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8004052:	6a06      	ldr	r6, [r0, #32]
  tp->p_next->p_prev = tp->p_prev;
 8004054:	6801      	ldr	r1, [r0, #0]
 8004056:	604b      	str	r3, [r1, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8004058:	4633      	mov	r3, r6
 800405a:	e002      	b.n	8004062 <chMtxLockS+0x72>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800405c:	6899      	ldr	r1, [r3, #8]
 800405e:	4291      	cmp	r1, r2
 8004060:	d302      	bcc.n	8004068 <chMtxLockS+0x78>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8004062:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8004064:	429e      	cmp	r6, r3
 8004066:	d1f9      	bne.n	800405c <chMtxLockS+0x6c>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8004068:	685a      	ldr	r2, [r3, #4]
 800406a:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800406c:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800406e:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 8004070:	6058      	str	r0, [r3, #4]
 8004072:	e7cf      	b.n	8004014 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8004074:	e890 000a 	ldmia.w	r0, {r1, r3}
 8004078:	6019      	str	r1, [r3, #0]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 800407a:	6a06      	ldr	r6, [r0, #32]
  tp->p_next->p_prev = tp->p_prev;
 800407c:	6801      	ldr	r1, [r0, #0]
 800407e:	604b      	str	r3, [r1, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8004080:	4633      	mov	r3, r6
 8004082:	e002      	b.n	800408a <chMtxLockS+0x9a>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8004084:	6899      	ldr	r1, [r3, #8]
 8004086:	4291      	cmp	r1, r2
 8004088:	d302      	bcc.n	8004090 <chMtxLockS+0xa0>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 800408a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800408c:	429e      	cmp	r6, r3
 800408e:	d1f9      	bne.n	8004084 <chMtxLockS+0x94>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8004090:	685a      	ldr	r2, [r3, #4]
 8004092:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8004094:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8004096:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 8004098:	6058      	str	r0, [r3, #4]
          tp = tp->p_u.wtmtxp->m_owner;
 800409a:	68b0      	ldr	r0, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 800409c:	68a2      	ldr	r2, [r4, #8]
 800409e:	6883      	ldr	r3, [r0, #8]
 80040a0:	4293      	cmp	r3, r2
 80040a2:	d3b0      	bcc.n	8004006 <chMtxLockS+0x16>
 80040a4:	e7b6      	b.n	8004014 <chMtxLockS+0x24>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 80040a6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80040a8:	60eb      	str	r3, [r5, #12]
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 80040aa:	60ac      	str	r4, [r5, #8]
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
 80040ac:	63a5      	str	r5, [r4, #56]	; 0x38
 80040ae:	bd70      	pop	{r4, r5, r6, pc}
 80040b0:	20001208 	.word	0x20001208
 80040b4:	f3af 8000 	nop.w
 80040b8:	f3af 8000 	nop.w
 80040bc:	f3af 8000 	nop.w

080040c0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 80040c0:	b508      	push	{r3, lr}
 80040c2:	2320      	movs	r3, #32
 80040c4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMtxLockS(mp);
 80040c8:	f7ff ff92 	bl	8003ff0 <chMtxLockS>
 80040cc:	2300      	movs	r3, #0
 80040ce:	f383 8811 	msr	BASEPRI, r3
 80040d2:	bd08      	pop	{r3, pc}
 80040d4:	f3af 8000 	nop.w
 80040d8:	f3af 8000 	nop.w
 80040dc:	f3af 8000 	nop.w

080040e0 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 80040e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
    heapp = &default_heap;
 80040e2:	4c0e      	ldr	r4, [pc, #56]	; (800411c <chHeapStatus+0x3c>)
 80040e4:	2800      	cmp	r0, #0
 80040e6:	bf18      	it	ne
 80040e8:	4604      	movne	r4, r0
  }

  H_LOCK(heapp);
 80040ea:	f104 0610 	add.w	r6, r4, #16
 80040ee:	4630      	mov	r0, r6
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 80040f0:	460f      	mov	r7, r1

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 80040f2:	f7ff ffe5 	bl	80040c0 <chMtxLock>
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 80040f6:	68a3      	ldr	r3, [r4, #8]
 80040f8:	b16b      	cbz	r3, 8004116 <chHeapStatus+0x36>
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  sz = 0;
 80040fa:	2200      	movs	r2, #0
  n = 0;
 80040fc:	4614      	mov	r4, r2
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 80040fe:	cb28      	ldmia	r3, {r3, r5}
    sz += qp->h.u.next->h.size;
    n++;
 8004100:	3401      	adds	r4, #1
  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
    sz += qp->h.u.next->h.size;
 8004102:	442a      	add	r2, r5

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8004104:	2b00      	cmp	r3, #0
 8004106:	d1fa      	bne.n	80040fe <chHeapStatus+0x1e>
    sz += qp->h.u.next->h.size;
    n++;
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
 8004108:	b107      	cbz	r7, 800410c <chHeapStatus+0x2c>
    *sizep = sz;
 800410a:	603a      	str	r2, [r7, #0]
  }
  H_UNLOCK(heapp);
 800410c:	4630      	mov	r0, r6
 800410e:	f7ff ff37 	bl	8003f80 <chMtxUnlock>

  return n;
}
 8004112:	4620      	mov	r0, r4
 8004114:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  sz = 0;
 8004116:	461a      	mov	r2, r3
  n = 0;
 8004118:	461c      	mov	r4, r3
 800411a:	e7f5      	b.n	8004108 <chHeapStatus+0x28>
 800411c:	20000fa0 	.word	0x20000fa0

08004120 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8004120:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
 8004122:	f850 5c08 	ldr.w	r5, [r0, #-8]
  qp = &heapp->h_free;

  H_LOCK(heapp);
 8004126:	f105 0710 	add.w	r7, r5, #16
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 800412a:	4606      	mov	r6, r0
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 800412c:	f1a0 0408 	sub.w	r4, r0, #8
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8004130:	3508      	adds	r5, #8

  H_LOCK(heapp);
 8004132:	4638      	mov	r0, r7
 8004134:	f7ff ffc4 	bl	80040c0 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8004138:	462b      	mov	r3, r5

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 800413a:	42ab      	cmp	r3, r5
 800413c:	d004      	beq.n	8004148 <chHeapFree+0x28>
 800413e:	42a3      	cmp	r3, r4
 8004140:	d302      	bcc.n	8004148 <chHeapFree+0x28>
 8004142:	681b      	ldr	r3, [r3, #0]
 8004144:	42ab      	cmp	r3, r5
 8004146:	d1fa      	bne.n	800413e <chHeapFree+0x1e>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8004148:	681a      	ldr	r2, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 800414a:	b11a      	cbz	r2, 8004154 <chHeapFree+0x34>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 800414c:	4294      	cmp	r4, r2
 800414e:	d301      	bcc.n	8004154 <chHeapFree+0x34>
 8004150:	4613      	mov	r3, r2
 8004152:	e7f2      	b.n	800413a <chHeapFree+0x1a>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8004154:	f856 1c04 	ldr.w	r1, [r6, #-4]
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 8004158:	f846 2c08 	str.w	r2, [r6, #-8]
      qp->h.u.next = hp;
 800415c:	601c      	str	r4, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 800415e:	f101 0208 	add.w	r2, r1, #8
 8004162:	f856 5c08 	ldr.w	r5, [r6, #-8]
 8004166:	18a0      	adds	r0, r4, r2
 8004168:	42a8      	cmp	r0, r5
 800416a:	d00a      	beq.n	8004182 <chHeapFree+0x62>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
 800416c:	685a      	ldr	r2, [r3, #4]
 800416e:	f102 0108 	add.w	r1, r2, #8
 8004172:	4419      	add	r1, r3
 8004174:	428c      	cmp	r4, r1
 8004176:	d012      	beq.n	800419e <chHeapFree+0x7e>
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8004178:	4638      	mov	r0, r7

  return;
}
 800417a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 800417e:	f7ff beff 	b.w	8003f80 <chMtxUnlock>
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8004182:	6840      	ldr	r0, [r0, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 8004184:	58a2      	ldr	r2, [r4, r2]
 8004186:	f846 2c08 	str.w	r2, [r6, #-8]
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 800418a:	180a      	adds	r2, r1, r0
 800418c:	3208      	adds	r2, #8
 800418e:	f846 2c04 	str.w	r2, [r6, #-4]
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
 8004192:	685a      	ldr	r2, [r3, #4]
 8004194:	f102 0108 	add.w	r1, r2, #8
 8004198:	4419      	add	r1, r3
 800419a:	428c      	cmp	r4, r1
 800419c:	d1ec      	bne.n	8004178 <chHeapFree+0x58>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 800419e:	f856 0c04 	ldr.w	r0, [r6, #-4]
        qp->h.u.next = hp->h.u.next;
 80041a2:	f856 1c08 	ldr.w	r1, [r6, #-8]
 80041a6:	6019      	str	r1, [r3, #0]
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 80041a8:	4402      	add	r2, r0
 80041aa:	3208      	adds	r2, #8
 80041ac:	605a      	str	r2, [r3, #4]
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 80041ae:	4638      	mov	r0, r7

  return;
}
 80041b0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 80041b4:	f7ff bee4 	b.w	8003f80 <chMtxUnlock>
 80041b8:	f3af 8000 	nop.w
 80041bc:	f3af 8000 	nop.w

080041c0 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 80041c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
    heapp = &default_heap;
 80041c2:	4e21      	ldr	r6, [pc, #132]	; (8004248 <chHeapAlloc+0x88>)
 80041c4:	2800      	cmp	r0, #0
 80041c6:	bf18      	it	ne
 80041c8:	4606      	movne	r6, r0
  }

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
 80041ca:	f106 0710 	add.w	r7, r6, #16

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
 80041ce:	3107      	adds	r1, #7
  qp = &heapp->h_free;

  H_LOCK(heapp);
 80041d0:	4638      	mov	r0, r7

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
 80041d2:	f021 0507 	bic.w	r5, r1, #7
  qp = &heapp->h_free;
 80041d6:	f106 0408 	add.w	r4, r6, #8

  H_LOCK(heapp);
 80041da:	f7ff ff71 	bl	80040c0 <chMtxLock>
 80041de:	e003      	b.n	80041e8 <chHeapAlloc+0x28>
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
 80041e0:	685a      	ldr	r2, [r3, #4]
 80041e2:	4295      	cmp	r5, r2
 80041e4:	d912      	bls.n	800420c <chHeapAlloc+0x4c>
 80041e6:	461c      	mov	r4, r3

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 80041e8:	6823      	ldr	r3, [r4, #0]
 80041ea:	2b00      	cmp	r3, #0
 80041ec:	d1f8      	bne.n	80041e0 <chHeapAlloc+0x20>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 80041ee:	4638      	mov	r0, r7
 80041f0:	f7ff fec6 	bl	8003f80 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 80041f4:	6833      	ldr	r3, [r6, #0]
 80041f6:	b32b      	cbz	r3, 8004244 <chHeapAlloc+0x84>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 80041f8:	f105 0008 	add.w	r0, r5, #8
 80041fc:	4798      	blx	r3
    if (hp != NULL) {
 80041fe:	b308      	cbz	r0, 8004244 <chHeapAlloc+0x84>
      hp->h.u.heap = heapp;
 8004200:	6006      	str	r6, [r0, #0]
      hp->h.size = size;
 8004202:	6045      	str	r5, [r0, #4]
      hp++;

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)hp;
 8004204:	f100 0408 	add.w	r4, r0, #8
      /*lint -restore*/
    }
  }

  return NULL;
}
 8004208:	4620      	mov	r0, r4
 800420a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
      if (hp->h.size < (size + sizeof(union heap_header))) {
 800420c:	f105 0108 	add.w	r1, r5, #8
 8004210:	4291      	cmp	r1, r2
 8004212:	d909      	bls.n	8004228 <chHeapAlloc+0x68>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 8004214:	681a      	ldr	r2, [r3, #0]
 8004216:	6022      	str	r2, [r4, #0]
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 8004218:	461c      	mov	r4, r3
      H_UNLOCK(heapp);
 800421a:	4638      	mov	r0, r7
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 800421c:	f844 6b08 	str.w	r6, [r4], #8
      H_UNLOCK(heapp);
 8004220:	f7ff feae 	bl	8003f80 <chMtxUnlock>
      /*lint -restore*/
    }
  }

  return NULL;
}
 8004224:	4620      	mov	r0, r4
 8004226:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 8004228:	f06f 0007 	mvn.w	r0, #7
 800422c:	1b40      	subs	r0, r0, r5
        qp->h.u.next = hp->h.u.next;
      }
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 800422e:	eb03 0e01 	add.w	lr, r3, r1
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 8004232:	4402      	add	r2, r0
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 8004234:	6818      	ldr	r0, [r3, #0]
 8004236:	5058      	str	r0, [r3, r1]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 8004238:	f8ce 2004 	str.w	r2, [lr, #4]
        qp->h.u.next = fp;
 800423c:	f8c4 e000 	str.w	lr, [r4]
        hp->h.size = size;
 8004240:	605d      	str	r5, [r3, #4]
 8004242:	e7e9      	b.n	8004218 <chHeapAlloc+0x58>
      return (void *)hp;
      /*lint -restore*/
    }
  }

  return NULL;
 8004244:	2400      	movs	r4, #0
 8004246:	e7df      	b.n	8004208 <chHeapAlloc+0x48>
 8004248:	20000fa0 	.word	0x20000fa0
 800424c:	f3af 8000 	nop.w

08004250 <chSemSignalI>:
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 8004250:	6883      	ldr	r3, [r0, #8]
 8004252:	3301      	adds	r3, #1
 8004254:	2b00      	cmp	r3, #0
 8004256:	6083      	str	r3, [r0, #8]
 8004258:	dd00      	ble.n	800425c <chSemSignalI+0xc>
 800425a:	4770      	bx	lr
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 800425c:	6803      	ldr	r3, [r0, #0]

  tqp->p_next = tp->p_next;
 800425e:	681a      	ldr	r2, [r3, #0]
 8004260:	6002      	str	r2, [r0, #0]
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 8004262:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 8004264:	6050      	str	r0, [r2, #4]
    (void) chSchReadyI(tp);
 8004266:	4618      	mov	r0, r3

  if (++sp->s_cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 8004268:	6219      	str	r1, [r3, #32]
    (void) chSchReadyI(tp);
 800426a:	f7ff bdc9 	b.w	8003e00 <chSchReadyI>
 800426e:	bf00      	nop

08004270 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8004270:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
 8004272:	6885      	ldr	r5, [r0, #8]
  sp->s_cnt = n;
 8004274:	6081      	str	r1, [r0, #8]
  while (++cnt <= (cnt_t)0) {
 8004276:	3501      	adds	r5, #1
 8004278:	2d00      	cmp	r5, #0
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 800427a:	4604      	mov	r4, r0
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 800427c:	dc0b      	bgt.n	8004296 <chSemResetI+0x26>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 800427e:	f06f 0601 	mvn.w	r6, #1

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_prev;
 8004282:	6860      	ldr	r0, [r4, #4]

  tqp->p_prev = tp->p_prev;
 8004284:	6843      	ldr	r3, [r0, #4]
 8004286:	6063      	str	r3, [r4, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 8004288:	601c      	str	r4, [r3, #0]
 800428a:	f7ff fdb9 	bl	8003e00 <chSchReadyI>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 800428e:	3501      	adds	r5, #1
 8004290:	2d01      	cmp	r5, #1
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 8004292:	6206      	str	r6, [r0, #32]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8004294:	d1f5      	bne.n	8004282 <chSemResetI+0x12>
 8004296:	bd70      	pop	{r4, r5, r6, pc}
 8004298:	f3af 8000 	nop.w
 800429c:	f3af 8000 	nop.w

080042a0 <chSysIntegrityCheckI>:
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 80042a0:	07c2      	lsls	r2, r0, #31
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 80042a2:	b410      	push	{r4}
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 80042a4:	d514      	bpl.n	80042d0 <chSysIntegrityCheckI+0x30>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
 80042a6:	4b26      	ldr	r3, [pc, #152]	; (8004340 <chSysIntegrityCheckI+0xa0>)
 80042a8:	6819      	ldr	r1, [r3, #0]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80042aa:	4299      	cmp	r1, r3
  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 80042ac:	f04f 0200 	mov.w	r2, #0
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80042b0:	d004      	beq.n	80042bc <chSysIntegrityCheckI+0x1c>
      n++;
      tp = tp->p_next;
 80042b2:	6809      	ldr	r1, [r1, #0]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80042b4:	4299      	cmp	r1, r3
      n++;
 80042b6:	f102 0201 	add.w	r2, r2, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80042ba:	d1fa      	bne.n	80042b2 <chSysIntegrityCheckI+0x12>
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 80042bc:	6859      	ldr	r1, [r3, #4]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80042be:	4299      	cmp	r1, r3
 80042c0:	d004      	beq.n	80042cc <chSysIntegrityCheckI+0x2c>
      n--;
      tp = tp->p_prev;
 80042c2:	6849      	ldr	r1, [r1, #4]
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80042c4:	4299      	cmp	r1, r3
      n--;
 80042c6:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80042ca:	d1fa      	bne.n	80042c2 <chSysIntegrityCheckI+0x22>
      n--;
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80042cc:	2a00      	cmp	r2, #0
 80042ce:	d132      	bne.n	8004336 <chSysIntegrityCheckI+0x96>
      return true;
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 80042d0:	0783      	lsls	r3, r0, #30
 80042d2:	d514      	bpl.n	80042fe <chSysIntegrityCheckI+0x5e>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
 80042d4:	4b1a      	ldr	r3, [pc, #104]	; (8004340 <chSysIntegrityCheckI+0xa0>)
 80042d6:	461c      	mov	r4, r3
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 80042d8:	2200      	movs	r2, #0
    vtp = ch.vtlist.vt_next;
 80042da:	f854 1f1c 	ldr.w	r1, [r4, #28]!
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80042de:	42a1      	cmp	r1, r4
 80042e0:	d004      	beq.n	80042ec <chSysIntegrityCheckI+0x4c>
      n++;
      vtp = vtp->vt_next;
 80042e2:	6809      	ldr	r1, [r1, #0]
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80042e4:	42a1      	cmp	r1, r4
      n++;
 80042e6:	f102 0201 	add.w	r2, r2, #1
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80042ea:	d1fa      	bne.n	80042e2 <chSysIntegrityCheckI+0x42>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 80042ec:	6a1b      	ldr	r3, [r3, #32]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80042ee:	42a3      	cmp	r3, r4
 80042f0:	d004      	beq.n	80042fc <chSysIntegrityCheckI+0x5c>
      n--;
      vtp = vtp->vt_prev;
 80042f2:	685b      	ldr	r3, [r3, #4]
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80042f4:	42a3      	cmp	r3, r4
      n--;
 80042f6:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80042fa:	d1fa      	bne.n	80042f2 <chSysIntegrityCheckI+0x52>
      n--;
      vtp = vtp->vt_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80042fc:	b9da      	cbnz	r2, 8004336 <chSysIntegrityCheckI+0x96>
      return true;
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 80042fe:	f010 0004 	ands.w	r0, r0, #4
 8004302:	d015      	beq.n	8004330 <chSysIntegrityCheckI+0x90>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
 8004304:	4b0e      	ldr	r3, [pc, #56]	; (8004340 <chSysIntegrityCheckI+0xa0>)
 8004306:	691a      	ldr	r2, [r3, #16]
    while (tp != (thread_t *)&ch.rlist) {
 8004308:	429a      	cmp	r2, r3
#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800430a:	f04f 0000 	mov.w	r0, #0
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
 800430e:	d004      	beq.n	800431a <chSysIntegrityCheckI+0x7a>
      n++;
      tp = tp->p_newer;
 8004310:	6912      	ldr	r2, [r2, #16]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
 8004312:	429a      	cmp	r2, r3
      n++;
 8004314:	f100 0001 	add.w	r0, r0, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
 8004318:	d1fa      	bne.n	8004310 <chSysIntegrityCheckI+0x70>
      n++;
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
 800431a:	695a      	ldr	r2, [r3, #20]
    while (tp != (thread_t *)&ch.rlist) {
 800431c:	429a      	cmp	r2, r3
 800431e:	d004      	beq.n	800432a <chSysIntegrityCheckI+0x8a>
      n--;
      tp = tp->p_older;
 8004320:	6952      	ldr	r2, [r2, #20]
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 8004322:	429a      	cmp	r2, r3
      n--;
 8004324:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 8004328:	d1fa      	bne.n	8004320 <chSysIntegrityCheckI+0x80>
      n--;
      tp = tp->p_older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800432a:	3000      	adds	r0, #0
 800432c:	bf18      	it	ne
 800432e:	2001      	movne	r0, #1
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 8004330:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004334:	4770      	bx	lr
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
      return true;
 8004336:	2001      	movs	r0, #1
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 8004338:	f85d 4b04 	ldr.w	r4, [sp], #4
 800433c:	4770      	bx	lr
 800433e:	bf00      	nop
 8004340:	20001208 	.word	0x20001208
 8004344:	f3af 8000 	nop.w
 8004348:	f3af 8000 	nop.w
 800434c:	f3af 8000 	nop.w

08004350 <chSysGetStatusAndLockX.part.2.4284>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8004350:	f3ef 8305 	mrs	r3, IPSR
 8004354:	f3c3 0308 	ubfx	r3, r3, #0, #9
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 8004358:	b91b      	cbnz	r3, 8004362 <chSysGetStatusAndLockX.part.2.4284+0x12>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800435a:	2320      	movs	r3, #32
 800435c:	f383 8811 	msr	BASEPRI, r3
    else {
      chSysLock();
    }
  }
  return sts;
}
 8004360:	4770      	bx	lr
 8004362:	2320      	movs	r3, #32
 8004364:	f383 8811 	msr	BASEPRI, r3
 8004368:	4770      	bx	lr
 800436a:	bf00      	nop
 800436c:	f3af 8000 	nop.w

08004370 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8004370:	e7fe      	b.n	8004370 <BusFault_Handler>
 8004372:	bf00      	nop
 8004374:	f3af 8000 	nop.w
 8004378:	f3af 8000 	nop.w
 800437c:	f3af 8000 	nop.w

08004380 <test_start_timer.constprop.2>:
/**
 * @brief   Starts the test timer.
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {
 8004380:	b508      	push	{r3, lr}

  systime_t duration = MS2ST(ms);
  test_timer_done = FALSE;
 8004382:	4b0b      	ldr	r3, [pc, #44]	; (80043b0 <test_start_timer.constprop.2+0x30>)
 8004384:	2200      	movs	r2, #0
 8004386:	701a      	strb	r2, [r3, #0]
 8004388:	2320      	movs	r3, #32
 800438a:	f383 8811 	msr	BASEPRI, r3
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 800438e:	4809      	ldr	r0, [pc, #36]	; (80043b4 <test_start_timer.constprop.2+0x34>)

  if (chVTIsArmedI(vtp)) {
 8004390:	68c3      	ldr	r3, [r0, #12]
 8004392:	b10b      	cbz	r3, 8004398 <test_start_timer.constprop.2+0x18>
    chVTDoResetI(vtp);
 8004394:	f7ff fafc 	bl	8003990 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8004398:	4806      	ldr	r0, [pc, #24]	; (80043b4 <test_start_timer.constprop.2+0x34>)
 800439a:	4a07      	ldr	r2, [pc, #28]	; (80043b8 <test_start_timer.constprop.2+0x38>)
 800439c:	f242 7110 	movw	r1, #10000	; 0x2710
 80043a0:	2300      	movs	r3, #0
 80043a2:	f7fc f985 	bl	80006b0 <chVTDoSetI>
 80043a6:	2300      	movs	r3, #0
 80043a8:	f383 8811 	msr	BASEPRI, r3
 80043ac:	bd08      	pop	{r3, pc}
 80043ae:	bf00      	nop
 80043b0:	200008c4 	.word	0x200008c4
 80043b4:	200008f8 	.word	0x200008f8
 80043b8:	08003651 	.word	0x08003651
 80043bc:	f3af 8000 	nop.w

080043c0 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 80043c0:	4603      	mov	r3, r0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 80043c2:	6880      	ldr	r0, [r0, #8]
 80043c4:	1e42      	subs	r2, r0, #1
 80043c6:	2a00      	cmp	r2, #0
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 80043c8:	b410      	push	{r4}
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 80043ca:	609a      	str	r2, [r3, #8]
 80043cc:	db03      	blt.n	80043d6 <chSemWaitTimeoutS+0x16>
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
 80043ce:	2000      	movs	r0, #0
}
 80043d0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80043d4:	4770      	bx	lr
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
 80043d6:	b161      	cbz	r1, 80043f2 <chSemWaitTimeoutS+0x32>
      sp->s_cnt++;

      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
 80043d8:	4a08      	ldr	r2, [pc, #32]	; (80043fc <chSemWaitTimeoutS+0x3c>)
 80043da:	6992      	ldr	r2, [r2, #24]
 80043dc:	6213      	str	r3, [r2, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 80043de:	685c      	ldr	r4, [r3, #4]
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 80043e0:	2005      	movs	r0, #5
 80043e2:	e882 0018 	stmia.w	r2, {r3, r4}
  tp->p_prev->p_next = tp;
 80043e6:	6022      	str	r2, [r4, #0]
  tqp->p_prev = tp;
 80043e8:	605a      	str	r2, [r3, #4]
  }

  return MSG_OK;
}
 80043ea:	f85d 4b04 	ldr.w	r4, [sp], #4
      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 80043ee:	f7fc b99f 	b.w	8000730 <chSchGoSleepTimeoutS>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;
 80043f2:	6098      	str	r0, [r3, #8]

      return MSG_TIMEOUT;
 80043f4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80043f8:	e7ea      	b.n	80043d0 <chSemWaitTimeoutS+0x10>
 80043fa:	bf00      	nop
 80043fc:	20001208 	.word	0x20001208

08004400 <chMBPost.constprop.26.4138>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8004400:	b570      	push	{r4, r5, r6, lr}
 8004402:	2320      	movs	r3, #32
 8004404:	4606      	mov	r6, r0
 8004406:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 800440a:	4d0f      	ldr	r5, [pc, #60]	; (8004448 <chMBPost.constprop.26.4138+0x48>)
 800440c:	4628      	mov	r0, r5
 800440e:	f7ff ffd7 	bl	80043c0 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 8004412:	4604      	mov	r4, r0
 8004414:	b990      	cbnz	r0, 800443c <chMBPost.constprop.26.4138+0x3c>
    *mbp->mb_wrptr++ = msg;
 8004416:	f855 1c14 	ldr.w	r1, [r5, #-20]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 800441a:	f855 0c18 	ldr.w	r0, [r5, #-24]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 800441e:	1d0a      	adds	r2, r1, #4
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8004420:	4282      	cmp	r2, r0
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8004422:	f845 2c14 	str.w	r2, [r5, #-20]
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
    }
    chSemSignalI(&mbp->mb_fullsem);
 8004426:	4809      	ldr	r0, [pc, #36]	; (800444c <chMBPost.constprop.26.4138+0x4c>)
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8004428:	600e      	str	r6, [r1, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
 800442a:	bf24      	itt	cs
 800442c:	f855 2c1c 	ldrcs.w	r2, [r5, #-28]
 8004430:	f845 2c14 	strcs.w	r2, [r5, #-20]
    }
    chSemSignalI(&mbp->mb_fullsem);
 8004434:	f7ff ff0c 	bl	8004250 <chSemSignalI>
    chSchRescheduleS();
 8004438:	f7ff fbba 	bl	8003bb0 <chSchRescheduleS>
 800443c:	2300      	movs	r3, #0
 800443e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBPostS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 8004442:	4620      	mov	r0, r4
 8004444:	bd70      	pop	{r4, r5, r6, pc}
 8004446:	bf00      	nop
 8004448:	2000085c 	.word	0x2000085c
 800444c:	20000850 	.word	0x20000850

08004450 <chMBPostAhead.constprop.24.4153>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8004450:	b570      	push	{r4, r5, r6, lr}
 8004452:	2320      	movs	r3, #32
 8004454:	4606      	mov	r6, r0
 8004456:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 800445a:	4c10      	ldr	r4, [pc, #64]	; (800449c <chMBPostAhead.constprop.24.4153+0x4c>)
 800445c:	4620      	mov	r0, r4
 800445e:	f7ff ffaf 	bl	80043c0 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 8004462:	4605      	mov	r5, r0
 8004464:	b970      	cbnz	r0, 8004484 <chMBPostAhead.constprop.24.4153+0x34>
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8004466:	f854 3c10 	ldr.w	r3, [r4, #-16]
 800446a:	f854 1c1c 	ldr.w	r1, [r4, #-28]
 800446e:	3b04      	subs	r3, #4
 8004470:	428b      	cmp	r3, r1
 8004472:	f844 3c10 	str.w	r3, [r4, #-16]
 8004476:	d30a      	bcc.n	800448e <chMBPostAhead.constprop.24.4153+0x3e>
      mbp->mb_rdptr = mbp->mb_top - 1;
    }
    *mbp->mb_rdptr = msg;
 8004478:	601e      	str	r6, [r3, #0]
    chSemSignalI(&mbp->mb_fullsem);
 800447a:	4809      	ldr	r0, [pc, #36]	; (80044a0 <chMBPostAhead.constprop.24.4153+0x50>)
 800447c:	f7ff fee8 	bl	8004250 <chSemSignalI>
    chSchRescheduleS();
 8004480:	f7ff fb96 	bl	8003bb0 <chSchRescheduleS>
 8004484:	2300      	movs	r3, #0
 8004486:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 800448a:	4628      	mov	r0, r5
 800448c:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
      mbp->mb_rdptr = mbp->mb_top - 1;
 800448e:	f854 3c18 	ldr.w	r3, [r4, #-24]
 8004492:	3b04      	subs	r3, #4
 8004494:	f844 3c10 	str.w	r3, [r4, #-16]
 8004498:	e7ee      	b.n	8004478 <chMBPostAhead.constprop.24.4153+0x28>
 800449a:	bf00      	nop
 800449c:	2000085c 	.word	0x2000085c
 80044a0:	20000850 	.word	0x20000850
 80044a4:	f3af 8000 	nop.w
 80044a8:	f3af 8000 	nop.w
 80044ac:	f3af 8000 	nop.w

080044b0 <chMBFetch.constprop.22.4168>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 80044b0:	b570      	push	{r4, r5, r6, lr}
 80044b2:	2320      	movs	r3, #32
 80044b4:	4606      	mov	r6, r0
 80044b6:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
 80044ba:	4d10      	ldr	r5, [pc, #64]	; (80044fc <chMBFetch.constprop.22.4168+0x4c>)
 80044bc:	4628      	mov	r0, r5
 80044be:	f7ff ff7f 	bl	80043c0 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 80044c2:	4604      	mov	r4, r0
 80044c4:	b9a0      	cbnz	r0, 80044f0 <chMBFetch.constprop.22.4168+0x40>
    *msgp = *mbp->mb_rdptr++;
 80044c6:	f855 2c04 	ldr.w	r2, [r5, #-4]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 80044ca:	f855 1c0c 	ldr.w	r1, [r5, #-12]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 80044ce:	6810      	ldr	r0, [r2, #0]
 80044d0:	3204      	adds	r2, #4
    if (mbp->mb_rdptr >= mbp->mb_top) {
 80044d2:	428a      	cmp	r2, r1
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 80044d4:	f845 2c04 	str.w	r2, [r5, #-4]
 80044d8:	6030      	str	r0, [r6, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
 80044da:	bf28      	it	cs
 80044dc:	f855 2c10 	ldrcs.w	r2, [r5, #-16]
    }
    chSemSignalI(&mbp->mb_emptysem);
 80044e0:	4807      	ldr	r0, [pc, #28]	; (8004500 <chMBFetch.constprop.22.4168+0x50>)

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
 80044e2:	bf28      	it	cs
 80044e4:	f845 2c04 	strcs.w	r2, [r5, #-4]
    }
    chSemSignalI(&mbp->mb_emptysem);
 80044e8:	f7ff feb2 	bl	8004250 <chSemSignalI>
    chSchRescheduleS();
 80044ec:	f7ff fb60 	bl	8003bb0 <chSchRescheduleS>
 80044f0:	2300      	movs	r3, #0
 80044f2:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBFetchS(mbp, msgp, timeout);
  chSysUnlock();

  return rdymsg;
}
 80044f6:	4620      	mov	r0, r4
 80044f8:	bd70      	pop	{r4, r5, r6, pc}
 80044fa:	bf00      	nop
 80044fc:	20000850 	.word	0x20000850
 8004500:	2000085c 	.word	0x2000085c
	...

08004510 <mbox1_execute.10277>:
static void mbox1_setup(void) {

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
}

static void mbox1_execute(void) {
 8004510:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004514:	2320      	movs	r3, #32
 8004516:	b082      	sub	sp, #8
 8004518:	f383 8811 	msr	BASEPRI, r3
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->mb_emptysem);
 800451c:	4d9e      	ldr	r5, [pc, #632]	; (8004798 <mbox1_execute.10277+0x288>)
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 800451e:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8004520:	1f4f      	subs	r7, r1, #5
 8004522:	4279      	negs	r1, r7
 8004524:	4179      	adcs	r1, r7
 8004526:	2001      	movs	r0, #1
 8004528:	f7fc fb52 	bl	8000bd0 <_test_assert>
 800452c:	2800      	cmp	r0, #0
 800452e:	f040 812c 	bne.w	800478a <mbox1_execute.10277+0x27a>
 8004532:	f380 8811 	msr	BASEPRI, r0
 8004536:	2442      	movs	r4, #66	; 0x42

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8004538:	4620      	mov	r0, r4
 800453a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800453e:	f7ff ff5f 	bl	8004400 <chMBPost.constprop.26.4138>
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
 8004542:	f1d0 0101 	rsbs	r1, r0, #1
 8004546:	bf38      	it	cc
 8004548:	2100      	movcc	r1, #0
 800454a:	2002      	movs	r0, #2
 800454c:	3401      	adds	r4, #1
 800454e:	f7fc fb3f 	bl	8000bd0 <_test_assert>
 8004552:	b980      	cbnz	r0, 8004576 <mbox1_execute.10277+0x66>
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 8004554:	2c46      	cmp	r4, #70	; 0x46
 8004556:	d1ef      	bne.n	8004538 <mbox1_execute.10277+0x28>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 8004558:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800455c:	2041      	movs	r0, #65	; 0x41
 800455e:	f7ff ff77 	bl	8004450 <chMBPostAhead.constprop.24.4153>
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");
 8004562:	f1d0 0101 	rsbs	r1, r0, #1
 8004566:	bf38      	it	cc
 8004568:	2100      	movcc	r1, #0
 800456a:	2003      	movs	r0, #3
 800456c:	f7fc fb30 	bl	8000bd0 <_test_assert>
 8004570:	2800      	cmp	r0, #0
 8004572:	f000 8115 	beq.w	80047a0 <mbox1_execute.10277+0x290>
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
}
 8004576:	b002      	add	sp, #8
 8004578:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800457c:	f384 8811 	msr	BASEPRI, r4
 8004580:	f386 8811 	msr	BASEPRI, r6
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
 8004584:	69b9      	ldr	r1, [r7, #24]
 8004586:	f1d1 0101 	rsbs	r1, r1, #1
 800458a:	bf38      	it	cc
 800458c:	2100      	movcc	r1, #0
 800458e:	201f      	movs	r0, #31
 8004590:	f7fc fb1e 	bl	8000bd0 <_test_assert>
 8004594:	2800      	cmp	r0, #0
 8004596:	f040 82b2 	bne.w	8004afe <mbox1_execute.10277+0x5ee>
 800459a:	f384 8811 	msr	BASEPRI, r4
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800459e:	68f9      	ldr	r1, [r7, #12]
 80045a0:	68bb      	ldr	r3, [r7, #8]
 80045a2:	1aca      	subs	r2, r1, r3
 80045a4:	4251      	negs	r1, r2
 80045a6:	4151      	adcs	r1, r2
 80045a8:	4630      	mov	r0, r6
 80045aa:	f7fc fb11 	bl	8000bd0 <_test_assert>
 80045ae:	2800      	cmp	r0, #0
 80045b0:	d1e1      	bne.n	8004576 <mbox1_execute.10277+0x66>
 80045b2:	f386 8811 	msr	BASEPRI, r6

  chSysLock();
  msg1 = chMBPostAheadI(&mb1, 'E');
 80045b6:	2045      	movs	r0, #69	; 0x45
 80045b8:	f7fc f9ea 	bl	8000990 <chMBPostAheadI.constprop.23>
  test_assert(33, msg1 == MSG_OK, "wrong wake-up message");
 80045bc:	f1d0 0101 	rsbs	r1, r0, #1
 80045c0:	bf38      	it	cc
 80045c2:	2100      	movcc	r1, #0
 80045c4:	2021      	movs	r0, #33	; 0x21
 80045c6:	f7fc fb03 	bl	8000bd0 <_test_assert>
 80045ca:	2800      	cmp	r0, #0
 80045cc:	d1d3      	bne.n	8004576 <mbox1_execute.10277+0x66>
  msg1 = chMBPostAheadI(&mb1, 'D');
 80045ce:	2044      	movs	r0, #68	; 0x44
 80045d0:	f7fc f9de 	bl	8000990 <chMBPostAheadI.constprop.23>
  test_assert(34, msg1 == MSG_OK, "wrong wake-up message");
 80045d4:	f1d0 0101 	rsbs	r1, r0, #1
 80045d8:	bf38      	it	cc
 80045da:	2100      	movcc	r1, #0
 80045dc:	2022      	movs	r0, #34	; 0x22
 80045de:	f7fc faf7 	bl	8000bd0 <_test_assert>
 80045e2:	2800      	cmp	r0, #0
 80045e4:	d1c7      	bne.n	8004576 <mbox1_execute.10277+0x66>
  msg1 = chMBPostAheadI(&mb1, 'C');
 80045e6:	2043      	movs	r0, #67	; 0x43
 80045e8:	f7fc f9d2 	bl	8000990 <chMBPostAheadI.constprop.23>
  test_assert(35, msg1 == MSG_OK, "wrong wake-up message");
 80045ec:	f1d0 0101 	rsbs	r1, r0, #1
 80045f0:	bf38      	it	cc
 80045f2:	2100      	movcc	r1, #0
 80045f4:	2023      	movs	r0, #35	; 0x23
 80045f6:	f7fc faeb 	bl	8000bd0 <_test_assert>
 80045fa:	2800      	cmp	r0, #0
 80045fc:	d1bb      	bne.n	8004576 <mbox1_execute.10277+0x66>
  msg1 = chMBPostAheadI(&mb1, 'B');
 80045fe:	2042      	movs	r0, #66	; 0x42
 8004600:	f7fc f9c6 	bl	8000990 <chMBPostAheadI.constprop.23>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
 8004604:	f1d0 0101 	rsbs	r1, r0, #1
 8004608:	bf38      	it	cc
 800460a:	2100      	movcc	r1, #0
 800460c:	2024      	movs	r0, #36	; 0x24
 800460e:	f7fc fadf 	bl	8000bd0 <_test_assert>
 8004612:	2800      	cmp	r0, #0
 8004614:	d1af      	bne.n	8004576 <mbox1_execute.10277+0x66>
  msg1 = chMBPostAheadI(&mb1, 'A');
 8004616:	2041      	movs	r0, #65	; 0x41
 8004618:	f7fc f9ba 	bl	8000990 <chMBPostAheadI.constprop.23>
 800461c:	2300      	movs	r3, #0
 800461e:	4601      	mov	r1, r0
 8004620:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
 8004624:	1acb      	subs	r3, r1, r3
 8004626:	4259      	negs	r1, r3
 8004628:	4159      	adcs	r1, r3
 800462a:	2025      	movs	r0, #37	; 0x25
 800462c:	f7fc fad0 	bl	8000bd0 <_test_assert>
 8004630:	2800      	cmp	r0, #0
 8004632:	d1a0      	bne.n	8004576 <mbox1_execute.10277+0x66>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8004634:	68e9      	ldr	r1, [r5, #12]
 8004636:	68ab      	ldr	r3, [r5, #8]
 8004638:	ebb1 0803 	subs.w	r8, r1, r3
 800463c:	f1d8 0100 	rsbs	r1, r8, #0
 8004640:	eb51 0108 	adcs.w	r1, r1, r8
 8004644:	2026      	movs	r0, #38	; 0x26
 8004646:	f7fc fac3 	bl	8000bd0 <_test_assert>
 800464a:	2800      	cmp	r0, #0
 800464c:	d193      	bne.n	8004576 <mbox1_execute.10277+0x66>
 800464e:	4680      	mov	r8, r0
 8004650:	2405      	movs	r4, #5
 8004652:	2720      	movs	r7, #32
 8004654:	2620      	movs	r6, #32
 8004656:	f387 8811 	msr	BASEPRI, r7
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
 800465a:	a801      	add	r0, sp, #4
 800465c:	f7fc f9b8 	bl	80009d0 <chMBFetchI.constprop.21>
 8004660:	4601      	mov	r1, r0
 8004662:	f388 8811 	msr	BASEPRI, r8
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 8004666:	f1d1 0101 	rsbs	r1, r1, #1
 800466a:	bf38      	it	cc
 800466c:	2100      	movcc	r1, #0
 800466e:	2027      	movs	r0, #39	; 0x27
 8004670:	f7fc faae 	bl	8000bd0 <_test_assert>
 8004674:	2800      	cmp	r0, #0
 8004676:	f47f af7e 	bne.w	8004576 <mbox1_execute.10277+0x66>
    test_emit_token(msg2);
 800467a:	f89d 0004 	ldrb.w	r0, [sp, #4]
 800467e:	f7ff f867 	bl	8003750 <test_emit_token>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 8004682:	3c01      	subs	r4, #1
 8004684:	d1e6      	bne.n	8004654 <mbox1_execute.10277+0x144>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(40, "ABCDE");
 8004686:	2028      	movs	r0, #40	; 0x28
 8004688:	4944      	ldr	r1, [pc, #272]	; (800479c <mbox1_execute.10277+0x28c>)
 800468a:	f7fc fa79 	bl	8000b80 <_test_assert_sequence>
 800468e:	2800      	cmp	r0, #0
 8004690:	f47f af71 	bne.w	8004576 <mbox1_execute.10277+0x66>
 8004694:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8004698:	6a69      	ldr	r1, [r5, #36]	; 0x24
 800469a:	4d3f      	ldr	r5, [pc, #252]	; (8004798 <mbox1_execute.10277+0x288>)
 800469c:	f1b1 0c05 	subs.w	ip, r1, #5
 80046a0:	f1dc 0100 	rsbs	r1, ip, #0
 80046a4:	eb51 010c 	adcs.w	r1, r1, ip
 80046a8:	2029      	movs	r0, #41	; 0x29
 80046aa:	f7fc fa91 	bl	8000bd0 <_test_assert>
 80046ae:	2800      	cmp	r0, #0
 80046b0:	f040 8225 	bne.w	8004afe <mbox1_execute.10277+0x5ee>
 80046b4:	f384 8811 	msr	BASEPRI, r4
 80046b8:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
 80046bc:	69a9      	ldr	r1, [r5, #24]
 80046be:	f1d1 0101 	rsbs	r1, r1, #1
 80046c2:	bf38      	it	cc
 80046c4:	2100      	movcc	r1, #0
 80046c6:	202a      	movs	r0, #42	; 0x2a
 80046c8:	f7fc fa82 	bl	8000bd0 <_test_assert>
 80046cc:	2800      	cmp	r0, #0
 80046ce:	f040 8216 	bne.w	8004afe <mbox1_execute.10277+0x5ee>
 80046d2:	f384 8811 	msr	BASEPRI, r4
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80046d6:	68e9      	ldr	r1, [r5, #12]
 80046d8:	68ab      	ldr	r3, [r5, #8]
 80046da:	ebb1 0e03 	subs.w	lr, r1, r3
 80046de:	f1de 0100 	rsbs	r1, lr, #0
 80046e2:	eb51 010e 	adcs.w	r1, r1, lr
 80046e6:	202b      	movs	r0, #43	; 0x2b
 80046e8:	f7fc fa72 	bl	8000bd0 <_test_assert>
 80046ec:	2800      	cmp	r0, #0
 80046ee:	f47f af42 	bne.w	8004576 <mbox1_execute.10277+0x66>
 80046f2:	f386 8811 	msr	BASEPRI, r6
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 80046f6:	682b      	ldr	r3, [r5, #0]
  mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 80046f8:	686a      	ldr	r2, [r5, #4]
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 80046fa:	60ab      	str	r3, [r5, #8]
  mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 80046fc:	1ad1      	subs	r1, r2, r3
 80046fe:	f105 001c 	add.w	r0, r5, #28
 8004702:	1089      	asrs	r1, r1, #2

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
  mbp->mb_rdptr = mbp->mb_buffer;
 8004704:	60eb      	str	r3, [r5, #12]
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 8004706:	f7ff fdb3 	bl	8004270 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
 800470a:	f105 0010 	add.w	r0, r5, #16
 800470e:	4621      	mov	r1, r4
 8004710:	f7ff fdae 	bl	8004270 <chSemResetI>
 */
void chMBReset(mailbox_t *mbp) {

  chSysLock();
  chMBResetI(mbp);
  chSchRescheduleS();
 8004714:	f7ff fa4c 	bl	8003bb0 <chSchRescheduleS>
 8004718:	f384 8811 	msr	BASEPRI, r4
 800471c:	f386 8811 	msr	BASEPRI, r6
  chMBReset(&mb1);

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8004720:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8004722:	1f4f      	subs	r7, r1, #5
 8004724:	4279      	negs	r1, r7
 8004726:	4179      	adcs	r1, r7
 8004728:	202c      	movs	r0, #44	; 0x2c
 800472a:	f7fc fa51 	bl	8000bd0 <_test_assert>
 800472e:	2800      	cmp	r0, #0
 8004730:	f040 81e5 	bne.w	8004afe <mbox1_execute.10277+0x5ee>
 8004734:	f384 8811 	msr	BASEPRI, r4
 8004738:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
 800473c:	69a9      	ldr	r1, [r5, #24]
 800473e:	f1d1 0101 	rsbs	r1, r1, #1
 8004742:	bf38      	it	cc
 8004744:	2100      	movcc	r1, #0
 8004746:	202d      	movs	r0, #45	; 0x2d
 8004748:	f7fc fa42 	bl	8000bd0 <_test_assert>
 800474c:	2800      	cmp	r0, #0
 800474e:	f040 81d6 	bne.w	8004afe <mbox1_execute.10277+0x5ee>
 8004752:	f384 8811 	msr	BASEPRI, r4
 8004756:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 800475a:	6829      	ldr	r1, [r5, #0]
 800475c:	68ab      	ldr	r3, [r5, #8]
 800475e:	1aca      	subs	r2, r1, r3
 8004760:	4251      	negs	r1, r2
 8004762:	4151      	adcs	r1, r2
 8004764:	202e      	movs	r0, #46	; 0x2e
 8004766:	f7fc fa33 	bl	8000bd0 <_test_assert>
 800476a:	2800      	cmp	r0, #0
 800476c:	f040 81c7 	bne.w	8004afe <mbox1_execute.10277+0x5ee>
 8004770:	f384 8811 	msr	BASEPRI, r4
 8004774:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 8004778:	6829      	ldr	r1, [r5, #0]
 800477a:	68eb      	ldr	r3, [r5, #12]
 800477c:	1acb      	subs	r3, r1, r3
 800477e:	4259      	negs	r1, r3
 8004780:	f04f 002f 	mov.w	r0, #47	; 0x2f
 8004784:	4159      	adcs	r1, r3
 8004786:	f7fc fa23 	bl	8000bd0 <_test_assert>
 800478a:	2300      	movs	r3, #0
 800478c:	f383 8811 	msr	BASEPRI, r3
}
 8004790:	b002      	add	sp, #8
 8004792:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004796:	bf00      	nop
 8004798:	20000840 	.word	0x20000840
 800479c:	08006818 	.word	0x08006818
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
 80047a0:	2101      	movs	r1, #1
 80047a2:	2058      	movs	r0, #88	; 0x58
 80047a4:	f7ff fe2c 	bl	8004400 <chMBPost.constprop.26.4138>
  test_assert(4, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80047a8:	f1b0 36ff 	subs.w	r6, r0, #4294967295	; 0xffffffff
 80047ac:	4271      	negs	r1, r6
 80047ae:	4171      	adcs	r1, r6
 80047b0:	2004      	movs	r0, #4
 80047b2:	f7fc fa0d 	bl	8000bd0 <_test_assert>
 80047b6:	4604      	mov	r4, r0
 80047b8:	2800      	cmp	r0, #0
 80047ba:	f47f aedc 	bne.w	8004576 <mbox1_execute.10277+0x66>
 80047be:	2620      	movs	r6, #32
 80047c0:	f386 8811 	msr	BASEPRI, r6
  chSysLock();
  msg1 = chMBPostI(&mb1, 'X');
 80047c4:	2058      	movs	r0, #88	; 0x58
 80047c6:	f7fc f8c3 	bl	8000950 <chMBPostI.constprop.25>
 80047ca:	4601      	mov	r1, r0
 80047cc:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();
  test_assert(5, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80047d0:	f1b1 34ff 	subs.w	r4, r1, #4294967295	; 0xffffffff
 80047d4:	4261      	negs	r1, r4
 80047d6:	4161      	adcs	r1, r4
 80047d8:	2005      	movs	r0, #5
 80047da:	f7fc f9f9 	bl	8000bd0 <_test_assert>
 80047de:	2800      	cmp	r0, #0
 80047e0:	f47f aec9 	bne.w	8004576 <mbox1_execute.10277+0x66>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
 80047e4:	2101      	movs	r1, #1
 80047e6:	2058      	movs	r0, #88	; 0x58
 80047e8:	f7ff fe32 	bl	8004450 <chMBPostAhead.constprop.24.4153>
  test_assert(6, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80047ec:	f1b0 32ff 	subs.w	r2, r0, #4294967295	; 0xffffffff
 80047f0:	4251      	negs	r1, r2
 80047f2:	4151      	adcs	r1, r2
 80047f4:	2006      	movs	r0, #6
 80047f6:	f7fc f9eb 	bl	8000bd0 <_test_assert>
 80047fa:	4604      	mov	r4, r0
 80047fc:	2800      	cmp	r0, #0
 80047fe:	f47f aeba 	bne.w	8004576 <mbox1_execute.10277+0x66>
 8004802:	f386 8811 	msr	BASEPRI, r6
  chSysLock();
  msg1 = chMBPostAheadI(&mb1, 'X');
 8004806:	2058      	movs	r0, #88	; 0x58
 8004808:	f7fc f8c2 	bl	8000990 <chMBPostAheadI.constprop.23>
 800480c:	4601      	mov	r1, r0
 800480e:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();
  test_assert(7, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8004812:	f1b1 33ff 	subs.w	r3, r1, #4294967295	; 0xffffffff
 8004816:	4259      	negs	r1, r3
 8004818:	f04f 0007 	mov.w	r0, #7
 800481c:	4159      	adcs	r1, r3
 800481e:	f7fc f9d7 	bl	8000bd0 <_test_assert>
 8004822:	4680      	mov	r8, r0
 8004824:	2800      	cmp	r0, #0
 8004826:	f47f aea6 	bne.w	8004576 <mbox1_execute.10277+0x66>
 800482a:	f386 8811 	msr	BASEPRI, r6

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
 800482e:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8004830:	4cb4      	ldr	r4, [pc, #720]	; (8004b04 <mbox1_execute.10277+0x5f4>)
 8004832:	f1d1 0101 	rsbs	r1, r1, #1
 8004836:	bf38      	it	cc
 8004838:	2100      	movcc	r1, #0
 800483a:	2008      	movs	r0, #8
 800483c:	f7fc f9c8 	bl	8000bd0 <_test_assert>
 8004840:	4607      	mov	r7, r0
 8004842:	b110      	cbz	r0, 800484a <mbox1_execute.10277+0x33a>
 8004844:	f388 8811 	msr	BASEPRI, r8
 8004848:	e695      	b.n	8004576 <mbox1_execute.10277+0x66>
 800484a:	f380 8811 	msr	BASEPRI, r0
 800484e:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 8004852:	69a1      	ldr	r1, [r4, #24]
 8004854:	f1b1 0805 	subs.w	r8, r1, #5
 8004858:	f1d8 0100 	rsbs	r1, r8, #0
 800485c:	eb51 0108 	adcs.w	r1, r1, r8
 8004860:	2009      	movs	r0, #9
 8004862:	f7fc f9b5 	bl	8000bd0 <_test_assert>
 8004866:	b110      	cbz	r0, 800486e <mbox1_execute.10277+0x35e>
 8004868:	f387 8811 	msr	BASEPRI, r7
 800486c:	e683      	b.n	8004576 <mbox1_execute.10277+0x66>
 800486e:	f380 8811 	msr	BASEPRI, r0
 8004872:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8004876:	68e1      	ldr	r1, [r4, #12]
 8004878:	68a3      	ldr	r3, [r4, #8]
 800487a:	ebb1 0c03 	subs.w	ip, r1, r3
 800487e:	f1dc 0100 	rsbs	r1, ip, #0
 8004882:	f04f 000a 	mov.w	r0, #10
 8004886:	eb51 010c 	adcs.w	r1, r1, ip
 800488a:	f7fc f9a1 	bl	8000bd0 <_test_assert>
 800488e:	2300      	movs	r3, #0
 8004890:	2800      	cmp	r0, #0
 8004892:	f47f af7b 	bne.w	800478c <mbox1_execute.10277+0x27c>
 8004896:	f383 8811 	msr	BASEPRI, r3
 800489a:	2405      	movs	r4, #5
 800489c:	e005      	b.n	80048aa <mbox1_execute.10277+0x39a>
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
 800489e:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80048a2:	f7fe ff55 	bl	8003750 <test_emit_token>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 80048a6:	3c01      	subs	r4, #1
 80048a8:	d00e      	beq.n	80048c8 <mbox1_execute.10277+0x3b8>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80048aa:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80048ae:	a801      	add	r0, sp, #4
 80048b0:	f7ff fdfe 	bl	80044b0 <chMBFetch.constprop.22.4168>
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 80048b4:	f1d0 0101 	rsbs	r1, r0, #1
 80048b8:	bf38      	it	cc
 80048ba:	2100      	movcc	r1, #0
 80048bc:	200b      	movs	r0, #11
 80048be:	f7fc f987 	bl	8000bd0 <_test_assert>
 80048c2:	2800      	cmp	r0, #0
 80048c4:	d0eb      	beq.n	800489e <mbox1_execute.10277+0x38e>
 80048c6:	e656      	b.n	8004576 <mbox1_execute.10277+0x66>
    test_emit_token(msg2);
  }
  test_assert_sequence(12, "ABCDE");
 80048c8:	200c      	movs	r0, #12
 80048ca:	498f      	ldr	r1, [pc, #572]	; (8004b08 <mbox1_execute.10277+0x5f8>)
 80048cc:	f7fc f958 	bl	8000b80 <_test_assert_sequence>
 80048d0:	2800      	cmp	r0, #0
 80048d2:	f47f ae50 	bne.w	8004576 <mbox1_execute.10277+0x66>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 80048d6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80048da:	2047      	movs	r0, #71	; 0x47
 80048dc:	f7ff fd90 	bl	8004400 <chMBPost.constprop.26.4138>
  test_assert(13, msg1 == MSG_OK, "wrong wake-up message");
 80048e0:	f1d0 0101 	rsbs	r1, r0, #1
 80048e4:	bf38      	it	cc
 80048e6:	2100      	movcc	r1, #0
 80048e8:	200d      	movs	r0, #13
 80048ea:	f7fc f971 	bl	8000bd0 <_test_assert>
 80048ee:	2800      	cmp	r0, #0
 80048f0:	f47f ae41 	bne.w	8004576 <mbox1_execute.10277+0x66>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80048f4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80048f8:	a801      	add	r0, sp, #4
 80048fa:	f7ff fdd9 	bl	80044b0 <chMBFetch.constprop.22.4168>
  test_assert(14, msg1 == MSG_OK, "wrong wake-up message");
 80048fe:	f1d0 0101 	rsbs	r1, r0, #1
 8004902:	bf38      	it	cc
 8004904:	2100      	movcc	r1, #0
 8004906:	200e      	movs	r0, #14
 8004908:	f7fc f962 	bl	8000bd0 <_test_assert>
 800490c:	2800      	cmp	r0, #0
 800490e:	f47f ae32 	bne.w	8004576 <mbox1_execute.10277+0x66>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 8004912:	6829      	ldr	r1, [r5, #0]
 8004914:	68ab      	ldr	r3, [r5, #8]
 8004916:	4e7b      	ldr	r6, [pc, #492]	; (8004b04 <mbox1_execute.10277+0x5f4>)
 8004918:	ebb1 0e03 	subs.w	lr, r1, r3
 800491c:	f1de 0100 	rsbs	r1, lr, #0
 8004920:	eb51 010e 	adcs.w	r1, r1, lr
 8004924:	200f      	movs	r0, #15
 8004926:	f7fc f953 	bl	8000bd0 <_test_assert>
 800492a:	2800      	cmp	r0, #0
 800492c:	f47f ae23 	bne.w	8004576 <mbox1_execute.10277+0x66>
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 8004930:	6831      	ldr	r1, [r6, #0]
 8004932:	68f3      	ldr	r3, [r6, #12]
 8004934:	1acf      	subs	r7, r1, r3
 8004936:	4279      	negs	r1, r7
 8004938:	4179      	adcs	r1, r7
 800493a:	2010      	movs	r0, #16
 800493c:	f7fc f948 	bl	8000bd0 <_test_assert>
 8004940:	2800      	cmp	r0, #0
 8004942:	f47f ae18 	bne.w	8004576 <mbox1_execute.10277+0x66>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
 8004946:	2101      	movs	r1, #1
 8004948:	a801      	add	r0, sp, #4
 800494a:	f7ff fdb1 	bl	80044b0 <chMBFetch.constprop.22.4168>
  test_assert(17, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800494e:	f1b0 32ff 	subs.w	r2, r0, #4294967295	; 0xffffffff
 8004952:	4251      	negs	r1, r2
 8004954:	4151      	adcs	r1, r2
 8004956:	2011      	movs	r0, #17
 8004958:	f7fc f93a 	bl	8000bd0 <_test_assert>
 800495c:	2800      	cmp	r0, #0
 800495e:	f47f ae0a 	bne.w	8004576 <mbox1_execute.10277+0x66>
 8004962:	2720      	movs	r7, #32
 8004964:	f387 8811 	msr	BASEPRI, r7
  chSysLock();
  msg1 = chMBFetchI(&mb1, &msg2);
 8004968:	a801      	add	r0, sp, #4
 800496a:	f7fc f831 	bl	80009d0 <chMBFetchI.constprop.21>
 800496e:	4601      	mov	r1, r0
 8004970:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();
  test_assert(18, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8004974:	f1b1 33ff 	subs.w	r3, r1, #4294967295	; 0xffffffff
 8004978:	4259      	negs	r1, r3
 800497a:	4159      	adcs	r1, r3
 800497c:	2012      	movs	r0, #18
 800497e:	f7fc f927 	bl	8000bd0 <_test_assert>
 8004982:	2800      	cmp	r0, #0
 8004984:	f47f adf7 	bne.w	8004576 <mbox1_execute.10277+0x66>
 8004988:	f387 8811 	msr	BASEPRI, r7

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800498c:	6a71      	ldr	r1, [r6, #36]	; 0x24
 800498e:	f1b1 0805 	subs.w	r8, r1, #5
 8004992:	f1d8 0100 	rsbs	r1, r8, #0
 8004996:	eb51 0108 	adcs.w	r1, r1, r8
 800499a:	2013      	movs	r0, #19
 800499c:	f7fc f918 	bl	8000bd0 <_test_assert>
 80049a0:	2800      	cmp	r0, #0
 80049a2:	f47f aef2 	bne.w	800478a <mbox1_execute.10277+0x27a>
 80049a6:	f04f 0800 	mov.w	r8, #0
 80049aa:	f388 8811 	msr	BASEPRI, r8
 80049ae:	2420      	movs	r4, #32
 80049b0:	f384 8811 	msr	BASEPRI, r4
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
 80049b4:	69a9      	ldr	r1, [r5, #24]
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->mb_fullsem);
 80049b6:	4e53      	ldr	r6, [pc, #332]	; (8004b04 <mbox1_execute.10277+0x5f4>)
 80049b8:	ebb1 0c08 	subs.w	ip, r1, r8
 80049bc:	f1dc 0100 	rsbs	r1, ip, #0
 80049c0:	eb51 010c 	adcs.w	r1, r1, ip
 80049c4:	2014      	movs	r0, #20
 80049c6:	f7fc f903 	bl	8000bd0 <_test_assert>
 80049ca:	4607      	mov	r7, r0
 80049cc:	2800      	cmp	r0, #0
 80049ce:	f47f af39 	bne.w	8004844 <mbox1_execute.10277+0x334>
 80049d2:	f380 8811 	msr	BASEPRI, r0
 80049d6:	f384 8811 	msr	BASEPRI, r4
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80049da:	68f1      	ldr	r1, [r6, #12]
 80049dc:	68b3      	ldr	r3, [r6, #8]
 80049de:	ebb1 0e03 	subs.w	lr, r1, r3
 80049e2:	f1de 0100 	rsbs	r1, lr, #0
 80049e6:	eb51 010e 	adcs.w	r1, r1, lr
 80049ea:	2015      	movs	r0, #21
 80049ec:	f7fc f8f0 	bl	8000bd0 <_test_assert>
 80049f0:	2800      	cmp	r0, #0
 80049f2:	f47f af39 	bne.w	8004868 <mbox1_execute.10277+0x358>
 80049f6:	f380 8811 	msr	BASEPRI, r0
 80049fa:	f384 8811 	msr	BASEPRI, r4

  /*
   * Testing I-Class.
   */
  chSysLock();
  msg1 = chMBPostI(&mb1, 'A');
 80049fe:	2041      	movs	r0, #65	; 0x41
 8004a00:	f7fb ffa6 	bl	8000950 <chMBPostI.constprop.25>
  test_assert(22, msg1 == MSG_OK, "wrong wake-up message");
 8004a04:	f1d0 0101 	rsbs	r1, r0, #1
 8004a08:	bf38      	it	cc
 8004a0a:	2100      	movcc	r1, #0
 8004a0c:	2016      	movs	r0, #22
 8004a0e:	f7fc f8df 	bl	8000bd0 <_test_assert>
 8004a12:	2800      	cmp	r0, #0
 8004a14:	f47f adaf 	bne.w	8004576 <mbox1_execute.10277+0x66>
  msg1 = chMBPostI(&mb1, 'B');
 8004a18:	2042      	movs	r0, #66	; 0x42
 8004a1a:	f7fb ff99 	bl	8000950 <chMBPostI.constprop.25>
  test_assert(23, msg1 == MSG_OK, "wrong wake-up message");
 8004a1e:	f1d0 0101 	rsbs	r1, r0, #1
 8004a22:	bf38      	it	cc
 8004a24:	2100      	movcc	r1, #0
 8004a26:	2017      	movs	r0, #23
 8004a28:	f7fc f8d2 	bl	8000bd0 <_test_assert>
 8004a2c:	2800      	cmp	r0, #0
 8004a2e:	f47f ada2 	bne.w	8004576 <mbox1_execute.10277+0x66>
  msg1 = chMBPostI(&mb1, 'C');
 8004a32:	2043      	movs	r0, #67	; 0x43
 8004a34:	f7fb ff8c 	bl	8000950 <chMBPostI.constprop.25>
  test_assert(24, msg1 == MSG_OK, "wrong wake-up message");
 8004a38:	f1d0 0101 	rsbs	r1, r0, #1
 8004a3c:	bf38      	it	cc
 8004a3e:	2100      	movcc	r1, #0
 8004a40:	2018      	movs	r0, #24
 8004a42:	f7fc f8c5 	bl	8000bd0 <_test_assert>
 8004a46:	2800      	cmp	r0, #0
 8004a48:	f47f ad95 	bne.w	8004576 <mbox1_execute.10277+0x66>
  msg1 = chMBPostI(&mb1, 'D');
 8004a4c:	2044      	movs	r0, #68	; 0x44
 8004a4e:	f7fb ff7f 	bl	8000950 <chMBPostI.constprop.25>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
 8004a52:	f1d0 0101 	rsbs	r1, r0, #1
 8004a56:	bf38      	it	cc
 8004a58:	2100      	movcc	r1, #0
 8004a5a:	2019      	movs	r0, #25
 8004a5c:	f7fc f8b8 	bl	8000bd0 <_test_assert>
 8004a60:	4607      	mov	r7, r0
 8004a62:	2800      	cmp	r0, #0
 8004a64:	f47f ad87 	bne.w	8004576 <mbox1_execute.10277+0x66>
  msg1 = chMBPostI(&mb1, 'E');
 8004a68:	2045      	movs	r0, #69	; 0x45
 8004a6a:	f7fb ff71 	bl	8000950 <chMBPostI.constprop.25>
 8004a6e:	4601      	mov	r1, r0
 8004a70:	f387 8811 	msr	BASEPRI, r7
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
 8004a74:	f1d1 0101 	rsbs	r1, r1, #1
 8004a78:	bf38      	it	cc
 8004a7a:	2100      	movcc	r1, #0
 8004a7c:	201a      	movs	r0, #26
 8004a7e:	f7fc f8a7 	bl	8000bd0 <_test_assert>
 8004a82:	2800      	cmp	r0, #0
 8004a84:	f47f ad77 	bne.w	8004576 <mbox1_execute.10277+0x66>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8004a88:	68f1      	ldr	r1, [r6, #12]
 8004a8a:	68b3      	ldr	r3, [r6, #8]
 8004a8c:	1ace      	subs	r6, r1, r3
 8004a8e:	4271      	negs	r1, r6
 8004a90:	4171      	adcs	r1, r6
 8004a92:	201b      	movs	r0, #27
 8004a94:	f7fc f89c 	bl	8000bd0 <_test_assert>
 8004a98:	2800      	cmp	r0, #0
 8004a9a:	f47f ad6c 	bne.w	8004576 <mbox1_execute.10277+0x66>
 8004a9e:	46a0      	mov	r8, r4
 8004aa0:	4607      	mov	r7, r0
 8004aa2:	2405      	movs	r4, #5
 8004aa4:	2620      	movs	r6, #32
 8004aa6:	f388 8811 	msr	BASEPRI, r8
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
 8004aaa:	a801      	add	r0, sp, #4
 8004aac:	f7fb ff90 	bl	80009d0 <chMBFetchI.constprop.21>
 8004ab0:	4601      	mov	r1, r0
 8004ab2:	f387 8811 	msr	BASEPRI, r7
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 8004ab6:	f1d1 0101 	rsbs	r1, r1, #1
 8004aba:	bf38      	it	cc
 8004abc:	2100      	movcc	r1, #0
 8004abe:	201c      	movs	r0, #28
 8004ac0:	f7fc f886 	bl	8000bd0 <_test_assert>
 8004ac4:	2800      	cmp	r0, #0
 8004ac6:	f47f ad56 	bne.w	8004576 <mbox1_execute.10277+0x66>
    test_emit_token(msg2);
 8004aca:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8004ace:	f7fe fe3f 	bl	8003750 <test_emit_token>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 8004ad2:	3c01      	subs	r4, #1
 8004ad4:	d1e6      	bne.n	8004aa4 <mbox1_execute.10277+0x594>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
 8004ad6:	201d      	movs	r0, #29
 8004ad8:	490b      	ldr	r1, [pc, #44]	; (8004b08 <mbox1_execute.10277+0x5f8>)
 8004ada:	f7fc f851 	bl	8000b80 <_test_assert_sequence>
 8004ade:	2800      	cmp	r0, #0
 8004ae0:	f47f ad49 	bne.w	8004576 <mbox1_execute.10277+0x66>
 8004ae4:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8004ae8:	6a69      	ldr	r1, [r5, #36]	; 0x24
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->mb_emptysem);
 8004aea:	4f06      	ldr	r7, [pc, #24]	; (8004b04 <mbox1_execute.10277+0x5f4>)
 8004aec:	1f48      	subs	r0, r1, #5
 8004aee:	4241      	negs	r1, r0
 8004af0:	4141      	adcs	r1, r0
 8004af2:	201e      	movs	r0, #30
 8004af4:	f7fc f86c 	bl	8000bd0 <_test_assert>
 8004af8:	2800      	cmp	r0, #0
 8004afa:	f43f ad3f 	beq.w	800457c <mbox1_execute.10277+0x6c>
 8004afe:	f384 8811 	msr	BASEPRI, r4
 8004b02:	e538      	b.n	8004576 <mbox1_execute.10277+0x66>
 8004b04:	20000840 	.word	0x20000840
 8004b08:	08006818 	.word	0x08006818
 8004b0c:	f3af 8000 	nop.w

08004b10 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8004b10:	b508      	push	{r3, lr}
 8004b12:	4601      	mov	r1, r0
 8004b14:	2320      	movs	r3, #32
 8004b16:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8004b1a:	2008      	movs	r0, #8
 8004b1c:	f7fb fe08 	bl	8000730 <chSchGoSleepTimeoutS>
 8004b20:	2300      	movs	r3, #0
 8004b22:	f383 8811 	msr	BASEPRI, r3
 8004b26:	bd08      	pop	{r3, pc}
 8004b28:	f3af 8000 	nop.w
 8004b2c:	f3af 8000 	nop.w

08004b30 <Thread1.11685>:
/*
 * This is a periodic thread that does absolutely nothing except flashing
 * a LED.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8004b30:	b508      	push	{r3, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8004b32:	4b09      	ldr	r3, [pc, #36]	; (8004b58 <Thread1.11685+0x28>)
 8004b34:	4a09      	ldr	r2, [pc, #36]	; (8004b5c <Thread1.11685+0x2c>)
 8004b36:	699b      	ldr	r3, [r3, #24]

  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
    palSetPad(GPIOD, GPIOD_LED3);       /* Orange.  */
 8004b38:	4c09      	ldr	r4, [pc, #36]	; (8004b60 <Thread1.11685+0x30>)
 8004b3a:	619a      	str	r2, [r3, #24]
 8004b3c:	f44f 5500 	mov.w	r5, #8192	; 0x2000
 8004b40:	462e      	mov	r6, r5
 8004b42:	8326      	strh	r6, [r4, #24]
    chThdSleepMilliseconds(500);
 8004b44:	f241 3088 	movw	r0, #5000	; 0x1388
 8004b48:	f7ff ffe2 	bl	8004b10 <chThdSleep>
    palClearPad(GPIOD, GPIOD_LED3);     /* Orange.  */
 8004b4c:	8365      	strh	r5, [r4, #26]
    chThdSleepMilliseconds(500);
 8004b4e:	f241 3088 	movw	r0, #5000	; 0x1388
 8004b52:	f7ff ffdd 	bl	8004b10 <chThdSleep>
 8004b56:	e7f4      	b.n	8004b42 <Thread1.11685+0x12>
 8004b58:	20001208 	.word	0x20001208
 8004b5c:	080068c0 	.word	0x080068c0
 8004b60:	40020c00 	.word	0x40020c00
 8004b64:	f3af 8000 	nop.w
 8004b68:	f3af 8000 	nop.w
 8004b6c:	f3af 8000 	nop.w

08004b70 <thread1.10408>:
static void evt2_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static THD_FUNCTION(thread1, p) {
 8004b70:	b510      	push	{r4, lr}
 8004b72:	4604      	mov	r4, r0

  chThdSleepMilliseconds(50);
 8004b74:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8004b78:	f7ff ffca 	bl	8004b10 <chThdSleep>
 8004b7c:	2320      	movs	r3, #32
 8004b7e:	f383 8811 	msr	BASEPRI, r3
void chEvtSignal(thread_t *tp, eventmask_t events) {

  chDbgCheck(tp != NULL);

  chSysLock();
  chEvtSignalI(tp, events);
 8004b82:	2101      	movs	r1, #1
 8004b84:	4620      	mov	r0, r4
 8004b86:	f7ff f973 	bl	8003e70 <chEvtSignalI>
  chSchRescheduleS();
 8004b8a:	f7ff f811 	bl	8003bb0 <chSchRescheduleS>
 8004b8e:	2300      	movs	r3, #0
 8004b90:	f383 8811 	msr	BASEPRI, r3
 8004b94:	bd10      	pop	{r4, pc}
 8004b96:	bf00      	nop
 8004b98:	f3af 8000 	nop.w
 8004b9c:	f3af 8000 	nop.w

08004ba0 <thread4b.9904>:
  chThdSleepMilliseconds(50);
  chMtxLock(&m2);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread4b, p) {
 8004ba0:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
 8004ba2:	4c06      	ldr	r4, [pc, #24]	; (8004bbc <thread4b.9904+0x1c>)
}

static THD_FUNCTION(thread4b, p) {

  (void)p;
  chThdSleepMilliseconds(150);
 8004ba4:	f240 50dc 	movw	r0, #1500	; 0x5dc
 8004ba8:	f7ff ffb2 	bl	8004b10 <chThdSleep>
  chMtxLock(&m1);
 8004bac:	4620      	mov	r0, r4
 8004bae:	f7ff fa87 	bl	80040c0 <chMtxLock>
  chMtxUnlock(&m1);
 8004bb2:	4620      	mov	r0, r4
}
 8004bb4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static THD_FUNCTION(thread4b, p) {

  (void)p;
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
 8004bb8:	f7ff b9e2 	b.w	8003f80 <chMtxUnlock>
 8004bbc:	20000830 	.word	0x20000830

08004bc0 <thread4a.9907>:

  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread4a, p) {
 8004bc0:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(50);
  chMtxLock(&m2);
 8004bc2:	4c06      	ldr	r4, [pc, #24]	; (8004bdc <thread4a.9907+0x1c>)
}

static THD_FUNCTION(thread4a, p) {

  (void)p;
  chThdSleepMilliseconds(50);
 8004bc4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8004bc8:	f7ff ffa2 	bl	8004b10 <chThdSleep>
  chMtxLock(&m2);
 8004bcc:	4620      	mov	r0, r4
 8004bce:	f7ff fa77 	bl	80040c0 <chMtxLock>
  chMtxUnlock(&m2);
 8004bd2:	4620      	mov	r0, r4
}
 8004bd4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static THD_FUNCTION(thread4a, p) {

  (void)p;
  chThdSleepMilliseconds(50);
  chMtxLock(&m2);
  chMtxUnlock(&m2);
 8004bd8:	f7ff b9d2 	b.w	8003f80 <chMtxUnlock>
 8004bdc:	20000820 	.word	0x20000820

08004be0 <thread2.9656>:
static void sem2_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread2, p) {
 8004be0:	b508      	push	{r3, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 8004be2:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8004be6:	f7ff ff93 	bl	8004b10 <chThdSleep>
 8004bea:	2320      	movs	r3, #32
 8004bec:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chSemSignalI(&sem1); /* For coverage reasons */
 8004bf0:	4804      	ldr	r0, [pc, #16]	; (8004c04 <thread2.9656+0x24>)
 8004bf2:	f7ff fb2d 	bl	8004250 <chSemSignalI>
  chSchRescheduleS();
 8004bf6:	f7fe ffdb 	bl	8003bb0 <chSchRescheduleS>
 8004bfa:	2300      	movs	r3, #0
 8004bfc:	f383 8811 	msr	BASEPRI, r3
 8004c00:	bd08      	pop	{r3, pc}
 8004c02:	bf00      	nop
 8004c04:	20000800 	.word	0x20000800
 8004c08:	f3af 8000 	nop.w
 8004c0c:	f3af 8000 	nop.w

08004c10 <test_wait_tick>:
/**
 * @brief   Delays execution until next system time tick.
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {
 8004c10:	b508      	push	{r3, lr}

  chThdSleep(1);
 8004c12:	2001      	movs	r0, #1
 8004c14:	f7ff ff7c 	bl	8004b10 <chThdSleep>
 8004c18:	2320      	movs	r3, #32
 8004c1a:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8004c1e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8004c22:	2300      	movs	r3, #0
 8004c24:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8004c26:	f383 8811 	msr	BASEPRI, r3
  return chVTGetSystemTime();
}
 8004c2a:	bd08      	pop	{r3, pc}
 8004c2c:	f3af 8000 	nop.w

08004c30 <thd4_execute.9391>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
 8004c30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  systime_t time;

  test_wait_tick();
 8004c32:	f7ff ffed 	bl	8004c10 <test_wait_tick>
 8004c36:	2620      	movs	r6, #32
 8004c38:	f386 8811 	msr	BASEPRI, r6
 8004c3c:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8004c40:	2300      	movs	r3, #0
 8004c42:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8004c44:	f383 8811 	msr	BASEPRI, r3

  /* Timeouts in microseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMicroseconds(100000);
 8004c48:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004c4c:	f7ff ff60 	bl	8004b10 <chThdSleep>
  test_assert_time_window(1,
 8004c50:	f504 717a 	add.w	r1, r4, #1000	; 0x3e8
 8004c54:	f204 32eb 	addw	r2, r4, #1003	; 0x3eb
 8004c58:	2001      	movs	r0, #1
 8004c5a:	f7fb ff71 	bl	8000b40 <_test_assert_time_window>
 8004c5e:	b100      	cbz	r0, 8004c62 <thd4_execute.9391+0x32>
 8004c60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004c62:	f386 8811 	msr	BASEPRI, r6
 8004c66:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8004c68:	f380 8811 	msr	BASEPRI, r0
                          time + US2ST(100000),
                          time + US2ST(100000) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in milliseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMilliseconds(100);
 8004c6c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004c70:	f7ff ff4e 	bl	8004b10 <chThdSleep>
  test_assert_time_window(2,
 8004c74:	f504 717a 	add.w	r1, r4, #1000	; 0x3e8
 8004c78:	f204 32eb 	addw	r2, r4, #1003	; 0x3eb
 8004c7c:	2002      	movs	r0, #2
 8004c7e:	f7fb ff5f 	bl	8000b40 <_test_assert_time_window>
 8004c82:	2800      	cmp	r0, #0
 8004c84:	d1ec      	bne.n	8004c60 <thd4_execute.9391+0x30>
 8004c86:	f386 8811 	msr	BASEPRI, r6
 8004c8a:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8004c8c:	f380 8811 	msr	BASEPRI, r0
                          time + MS2ST(100),
                          time + MS2ST(100) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in seconds.*/
  time = chVTGetSystemTime();
  chThdSleepSeconds(1);
 8004c90:	f242 7010 	movw	r0, #10000	; 0x2710
 8004c94:	f7ff ff3c 	bl	8004b10 <chThdSleep>
  test_assert_time_window(3,
 8004c98:	f504 511c 	add.w	r1, r4, #9984	; 0x2700
 8004c9c:	460a      	mov	r2, r1
 8004c9e:	3213      	adds	r2, #19
 8004ca0:	3110      	adds	r1, #16
 8004ca2:	2003      	movs	r0, #3
 8004ca4:	f7fb ff4c 	bl	8000b40 <_test_assert_time_window>
 8004ca8:	2800      	cmp	r0, #0
 8004caa:	d1d9      	bne.n	8004c60 <thd4_execute.9391+0x30>
 8004cac:	f386 8811 	msr	BASEPRI, r6
 8004cb0:	6a6f      	ldr	r7, [r5, #36]	; 0x24
 8004cb2:	f380 8811 	msr	BASEPRI, r0
                          time + S2ST(1),
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
 8004cb6:	f507 747a 	add.w	r4, r7, #1000	; 0x3e8
 8004cba:	f386 8811 	msr	BASEPRI, r6
 8004cbe:	6a69      	ldr	r1, [r5, #36]	; 0x24
 */
void chThdSleepUntil(systime_t time) {

  chSysLock();
  time -= chVTGetSystemTimeX();
  if (time > (systime_t)0) {
 8004cc0:	1a61      	subs	r1, r4, r1
 8004cc2:	d10a      	bne.n	8004cda <thd4_execute.9391+0xaa>
 8004cc4:	2300      	movs	r3, #0
 8004cc6:	f383 8811 	msr	BASEPRI, r3
  chThdSleepUntil(time);
  test_assert_time_window(4,
 8004cca:	2004      	movs	r0, #4
 8004ccc:	4621      	mov	r1, r4
 8004cce:	f207 32eb 	addw	r2, r7, #1003	; 0x3eb
                          time,
                          time + CH_CFG_ST_TIMEDELTA + 1);
}
 8004cd2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
  chThdSleepUntil(time);
  test_assert_time_window(4,
 8004cd6:	f7fb bf33 	b.w	8000b40 <_test_assert_time_window>
 8004cda:	2008      	movs	r0, #8
 8004cdc:	f7fb fd28 	bl	8000730 <chSchGoSleepTimeoutS>
 8004ce0:	e7f0      	b.n	8004cc4 <thd4_execute.9391+0x94>
 8004ce2:	bf00      	nop
 8004ce4:	f3af 8000 	nop.w
 8004ce8:	f3af 8000 	nop.w
 8004cec:	f3af 8000 	nop.w

08004cf0 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8004cf0:	b570      	push	{r4, r5, r6, lr}
 8004cf2:	2320      	movs	r3, #32
 8004cf4:	460e      	mov	r6, r1
 8004cf6:	4604      	mov	r4, r0
 8004cf8:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 8004cfc:	69c3      	ldr	r3, [r0, #28]
 8004cfe:	b12b      	cbz	r3, 8004d0c <chIQGetTimeout+0x1c>
    iqp->q_notify(iqp);
 8004d00:	4798      	blx	r3
 8004d02:	e003      	b.n	8004d0c <chIQGetTimeout+0x1c>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8004d04:	f7fb fd3c 	bl	8000780 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8004d08:	2800      	cmp	r0, #0
 8004d0a:	db16      	blt.n	8004d3a <chIQGetTimeout+0x4a>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8004d0c:	68a5      	ldr	r5, [r4, #8]
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8004d0e:	4620      	mov	r0, r4
 8004d10:	4631      	mov	r1, r6
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8004d12:	2d00      	cmp	r5, #0
 8004d14:	d0f6      	beq.n	8004d04 <chIQGetTimeout+0x14>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8004d16:	69a2      	ldr	r2, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8004d18:	68a0      	ldr	r0, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8004d1a:	6921      	ldr	r1, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8004d1c:	1c53      	adds	r3, r2, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 8004d1e:	428b      	cmp	r3, r1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8004d20:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
  b = *iqp->q_rdptr++;
 8004d24:	61a3      	str	r3, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8004d26:	60a0      	str	r0, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8004d28:	bf28      	it	cs
 8004d2a:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8004d2c:	7810      	ldrb	r0, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8004d2e:	bf28      	it	cs
 8004d30:	61a3      	strcs	r3, [r4, #24]
 8004d32:	2300      	movs	r3, #0
 8004d34:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return (msg_t)b;
}
 8004d38:	bd70      	pop	{r4, r5, r6, pc}
 8004d3a:	f385 8811 	msr	BASEPRI, r5
 8004d3e:	bd70      	pop	{r4, r5, r6, pc}

08004d40 <thread1.11019>:
}

static THD_FUNCTION(thread1, p) {

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
 8004d40:	4802      	ldr	r0, [pc, #8]	; (8004d4c <thread1.11019+0xc>)
 8004d42:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 8004d46:	f7ff bfd3 	b.w	8004cf0 <chIQGetTimeout>
 8004d4a:	bf00      	nop
 8004d4c:	2000086c 	.word	0x2000086c

08004d50 <gett.7428>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8004d50:	300c      	adds	r0, #12
 8004d52:	f7ff bfcd 	b.w	8004cf0 <chIQGetTimeout>
 8004d56:	bf00      	nop
 8004d58:	f3af 8000 	nop.w
 8004d5c:	f3af 8000 	nop.w

08004d60 <get.7432>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8004d60:	300c      	adds	r0, #12
 8004d62:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8004d66:	f7ff bfc3 	b.w	8004cf0 <chIQGetTimeout>
 8004d6a:	bf00      	nop
 8004d6c:	f3af 8000 	nop.w

08004d70 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8004d70:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004d74:	4604      	mov	r4, r0
 8004d76:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 8004d78:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8004d7c:	f04f 0b20 	mov.w	fp, #32
 8004d80:	f38b 8811 	msr	BASEPRI, fp
  size_t r = 0;
 8004d84:	2600      	movs	r6, #0
 8004d86:	eb01 0a02 	add.w	sl, r1, r2
 8004d8a:	f101 0901 	add.w	r9, r1, #1

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 8004d8e:	f1b8 0f00 	cmp.w	r8, #0
 8004d92:	d005      	beq.n	8004da0 <chIQReadTimeout+0x30>
      nfy(iqp);
 8004d94:	4620      	mov	r0, r4
 8004d96:	47c0      	blx	r8
 8004d98:	e002      	b.n	8004da0 <chIQReadTimeout+0x30>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8004d9a:	f7fb fcf1 	bl	8000780 <chThdEnqueueTimeoutS>
 8004d9e:	b9f8      	cbnz	r0, 8004de0 <chIQReadTimeout+0x70>
 8004da0:	68a7      	ldr	r7, [r4, #8]
 8004da2:	4620      	mov	r0, r4
 8004da4:	4629      	mov	r1, r5
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8004da6:	2f00      	cmp	r7, #0
 8004da8:	d0f7      	beq.n	8004d9a <chIQReadTimeout+0x2a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8004daa:	69a3      	ldr	r3, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8004dac:	68a1      	ldr	r1, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8004dae:	1c5a      	adds	r2, r3, #1
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8004db0:	3901      	subs	r1, #1
    *bp++ = *iqp->q_rdptr++;
 8004db2:	61a2      	str	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8004db4:	60a1      	str	r1, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8004db6:	781b      	ldrb	r3, [r3, #0]
 8004db8:	f809 3c01 	strb.w	r3, [r9, #-1]
    if (iqp->q_rdptr >= iqp->q_top) {
 8004dbc:	6923      	ldr	r3, [r4, #16]
 8004dbe:	69a2      	ldr	r2, [r4, #24]
 8004dc0:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8004dc2:	bf24      	itt	cs
 8004dc4:	68e3      	ldrcs	r3, [r4, #12]
 8004dc6:	61a3      	strcs	r3, [r4, #24]
 8004dc8:	2300      	movs	r3, #0
 8004dca:	f383 8811 	msr	BASEPRI, r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
    if (--n == 0U) {
 8004dce:	45d1      	cmp	r9, sl
    if (iqp->q_rdptr >= iqp->q_top) {
      iqp->q_rdptr = iqp->q_buffer;
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 8004dd0:	f106 0601 	add.w	r6, r6, #1
    if (--n == 0U) {
 8004dd4:	d006      	beq.n	8004de4 <chIQReadTimeout+0x74>
 8004dd6:	f38b 8811 	msr	BASEPRI, fp
 8004dda:	f109 0901 	add.w	r9, r9, #1
 8004dde:	e7d6      	b.n	8004d8e <chIQReadTimeout+0x1e>
 8004de0:	f387 8811 	msr	BASEPRI, r7
      return r;
    }

    chSysLock();
  }
}
 8004de4:	4630      	mov	r0, r6
 8004de6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004dea:	bf00      	nop
 8004dec:	f3af 8000 	nop.w

08004df0 <readt.7405>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8004df0:	300c      	adds	r0, #12
 8004df2:	f7ff bfbd 	b.w	8004d70 <chIQReadTimeout>
 8004df6:	bf00      	nop
 8004df8:	f3af 8000 	nop.w
 8004dfc:	f3af 8000 	nop.w

08004e00 <read.7412>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8004e00:	300c      	adds	r0, #12
 8004e02:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004e06:	f7ff bfb3 	b.w	8004d70 <chIQReadTimeout>
 8004e0a:	bf00      	nop
 8004e0c:	f3af 8000 	nop.w

08004e10 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8004e10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004e12:	4604      	mov	r4, r0
 8004e14:	460f      	mov	r7, r1
 8004e16:	4616      	mov	r6, r2
 8004e18:	2320      	movs	r3, #32
 8004e1a:	f383 8811 	msr	BASEPRI, r3
 8004e1e:	e003      	b.n	8004e28 <chOQPutTimeout+0x18>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8004e20:	f7fb fcae 	bl	8000780 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8004e24:	2800      	cmp	r0, #0
 8004e26:	db19      	blt.n	8004e5c <chOQPutTimeout+0x4c>
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8004e28:	68a5      	ldr	r5, [r4, #8]
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8004e2a:	4620      	mov	r0, r4
 8004e2c:	4631      	mov	r1, r6
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 8004e2e:	2d00      	cmp	r5, #0
 8004e30:	d0f6      	beq.n	8004e20 <chOQPutTimeout+0x10>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8004e32:	6963      	ldr	r3, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8004e34:	68a1      	ldr	r1, [r4, #8]
  *oqp->q_wrptr++ = b;
 8004e36:	1c5a      	adds	r2, r3, #1
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8004e38:	3901      	subs	r1, #1
  *oqp->q_wrptr++ = b;
 8004e3a:	6162      	str	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8004e3c:	60a1      	str	r1, [r4, #8]
  *oqp->q_wrptr++ = b;
 8004e3e:	701f      	strb	r7, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8004e40:	6923      	ldr	r3, [r4, #16]
 8004e42:	6962      	ldr	r2, [r4, #20]
 8004e44:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8004e46:	bf24      	itt	cs
 8004e48:	68e3      	ldrcs	r3, [r4, #12]
 8004e4a:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 8004e4c:	69e3      	ldr	r3, [r4, #28]
 8004e4e:	b10b      	cbz	r3, 8004e54 <chOQPutTimeout+0x44>
    oqp->q_notify(oqp);
 8004e50:	4620      	mov	r0, r4
 8004e52:	4798      	blx	r3
 8004e54:	2000      	movs	r0, #0
 8004e56:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 8004e5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004e5c:	f385 8811 	msr	BASEPRI, r5
 8004e60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004e62:	bf00      	nop
 8004e64:	f3af 8000 	nop.w
 8004e68:	f3af 8000 	nop.w
 8004e6c:	f3af 8000 	nop.w

08004e70 <thread2.11022>:
}

static THD_FUNCTION(thread2, p) {

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
 8004e70:	4802      	ldr	r0, [pc, #8]	; (8004e7c <thread2.11022+0xc>)
 8004e72:	2100      	movs	r1, #0
 8004e74:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8004e78:	f7ff bfca 	b.w	8004e10 <chOQPutTimeout>
 8004e7c:	20000890 	.word	0x20000890

08004e80 <putt.7435>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8004e80:	3030      	adds	r0, #48	; 0x30
 8004e82:	f7ff bfc5 	b.w	8004e10 <chOQPutTimeout>
 8004e86:	bf00      	nop
 8004e88:	f3af 8000 	nop.w
 8004e8c:	f3af 8000 	nop.w

08004e90 <put.7440>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8004e90:	3030      	adds	r0, #48	; 0x30
 8004e92:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004e96:	f7ff bfbb 	b.w	8004e10 <chOQPutTimeout>
 8004e9a:	bf00      	nop
 8004e9c:	f3af 8000 	nop.w

08004ea0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8004ea0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004ea4:	b083      	sub	sp, #12
 8004ea6:	4604      	mov	r4, r0
 8004ea8:	460d      	mov	r5, r1
 8004eaa:	4616      	mov	r6, r2
 8004eac:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 8004eae:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8004eb2:	f04f 0a20 	mov.w	sl, #32
 8004eb6:	f38a 8811 	msr	BASEPRI, sl
  size_t w = 0;
 8004eba:	2700      	movs	r7, #0
 8004ebc:	46b9      	mov	r9, r7
 8004ebe:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8004ec0:	f105 0b01 	add.w	fp, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 8004ec4:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8004ec6:	b303      	cbz	r3, 8004f0a <chOQWriteTimeout+0x6a>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8004ec8:	6963      	ldr	r3, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8004eca:	68a1      	ldr	r1, [r4, #8]
 8004ecc:	1e4a      	subs	r2, r1, #1
    *oqp->q_wrptr++ = *bp++;
 8004ece:	1c59      	adds	r1, r3, #1
 8004ed0:	6161      	str	r1, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8004ed2:	60a2      	str	r2, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8004ed4:	7829      	ldrb	r1, [r5, #0]
 8004ed6:	7019      	strb	r1, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8004ed8:	6923      	ldr	r3, [r4, #16]
 8004eda:	6961      	ldr	r1, [r4, #20]
 8004edc:	4299      	cmp	r1, r3
      oqp->q_wrptr = oqp->q_buffer;
 8004ede:	bf24      	itt	cs
 8004ee0:	68e3      	ldrcs	r3, [r4, #12]
 8004ee2:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy != NULL) {
 8004ee4:	f1b8 0f00 	cmp.w	r8, #0
 8004ee8:	d000      	beq.n	8004eec <chOQWriteTimeout+0x4c>
      nfy(oqp);
 8004eea:	47c0      	blx	r8
 8004eec:	f389 8811 	msr	BASEPRI, r9
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 8004ef0:	3e01      	subs	r6, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 8004ef2:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
 8004ef6:	d012      	beq.n	8004f1e <chOQWriteTimeout+0x7e>
 8004ef8:	f38a 8811 	msr	BASEPRI, sl
 8004efc:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8004efe:	465d      	mov	r5, fp
 8004f00:	f105 0b01 	add.w	fp, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 8004f04:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8004f06:	2b00      	cmp	r3, #0
 8004f08:	d1de      	bne.n	8004ec8 <chOQWriteTimeout+0x28>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8004f0a:	4620      	mov	r0, r4
 8004f0c:	9901      	ldr	r1, [sp, #4]
 8004f0e:	9300      	str	r3, [sp, #0]
 8004f10:	f7fb fc36 	bl	8000780 <chThdEnqueueTimeoutS>
 8004f14:	9b00      	ldr	r3, [sp, #0]
 8004f16:	2800      	cmp	r0, #0
 8004f18:	d0d1      	beq.n	8004ebe <chOQWriteTimeout+0x1e>
 8004f1a:	f383 8811 	msr	BASEPRI, r3
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 8004f1e:	4638      	mov	r0, r7
 8004f20:	b003      	add	sp, #12
 8004f22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004f26:	bf00      	nop
 8004f28:	f3af 8000 	nop.w
 8004f2c:	f3af 8000 	nop.w

08004f30 <writet.7417>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8004f30:	3030      	adds	r0, #48	; 0x30
 8004f32:	f7ff bfb5 	b.w	8004ea0 <chOQWriteTimeout>
 8004f36:	bf00      	nop
 8004f38:	f3af 8000 	nop.w
 8004f3c:	f3af 8000 	nop.w

08004f40 <write.7423>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8004f40:	3030      	adds	r0, #48	; 0x30
 8004f42:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004f46:	f7ff bfab 	b.w	8004ea0 <chOQWriteTimeout>
 8004f4a:	bf00      	nop
 8004f4c:	f3af 8000 	nop.w

08004f50 <evt2_execute.10428>:
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
  chEvtBroadcast(&es2);
}

static void evt2_execute(void) {
 8004f50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004f54:	2520      	movs	r5, #32
 8004f56:	b08d      	sub	sp, #52	; 0x34
 8004f58:	f385 8811 	msr	BASEPRI, r5
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {

  chSysLock();
  currp->p_epending |= events;
 8004f5c:	4cac      	ldr	r4, [pc, #688]	; (8005210 <evt2_execute.10428+0x2c0>)
 8004f5e:	69a3      	ldr	r3, [r4, #24]
 8004f60:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004f62:	f042 0207 	orr.w	r2, r2, #7
 8004f66:	635a      	str	r2, [r3, #52]	; 0x34
 8004f68:	2300      	movs	r3, #0
 8004f6a:	f383 8811 	msr	BASEPRI, r3

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
  m = chEvtWaitOne(ALL_EVENTS);
 8004f6e:	f7fb fcaf 	bl	80008d0 <chEvtWaitOne.constprop.34>
  test_assert(1, m == 1, "single event error");
 8004f72:	f1b0 0901 	subs.w	r9, r0, #1
 8004f76:	f1d9 0100 	rsbs	r1, r9, #0
 8004f7a:	eb51 0109 	adcs.w	r1, r1, r9
 8004f7e:	2001      	movs	r0, #1
 8004f80:	f7fb fe26 	bl	8000bd0 <_test_assert>
 8004f84:	b110      	cbz	r0, 8004f8c <evt2_execute.10428+0x3c>
  test_wait_threads();
  chEvtUnregister(&es1, &el1);
  chEvtUnregister(&es2, &el2);
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
}
 8004f86:	b00d      	add	sp, #52	; 0x34
 8004f88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert(1, m == 1, "single event error");
  m = chEvtWaitOne(ALL_EVENTS);
 8004f8c:	f7fb fca0 	bl	80008d0 <chEvtWaitOne.constprop.34>
  test_assert(2, m == 2, "single event error");
 8004f90:	f1b0 0802 	subs.w	r8, r0, #2
 8004f94:	f1d8 0100 	rsbs	r1, r8, #0
 8004f98:	eb51 0108 	adcs.w	r1, r1, r8
 8004f9c:	2002      	movs	r0, #2
 8004f9e:	f7fb fe17 	bl	8000bd0 <_test_assert>
 8004fa2:	2800      	cmp	r0, #0
 8004fa4:	d1ef      	bne.n	8004f86 <evt2_execute.10428+0x36>
  m = chEvtWaitOne(ALL_EVENTS);
 8004fa6:	f7fb fc93 	bl	80008d0 <chEvtWaitOne.constprop.34>
  test_assert(3, m == 4, "single event error");
 8004faa:	f1b0 0c04 	subs.w	ip, r0, #4
 8004fae:	f1dc 0100 	rsbs	r1, ip, #0
 8004fb2:	eb51 010c 	adcs.w	r1, r1, ip
 8004fb6:	2003      	movs	r0, #3
 8004fb8:	f7fb fe0a 	bl	8000bd0 <_test_assert>
 8004fbc:	2800      	cmp	r0, #0
 8004fbe:	d1e2      	bne.n	8004f86 <evt2_execute.10428+0x36>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004fc0:	f7fb fc5e 	bl	8000880 <chEvtGetAndClearEvents.constprop.38>
  test_assert(4, m == 0, "stuck event");
 8004fc4:	f1d0 0101 	rsbs	r1, r0, #1
 8004fc8:	bf38      	it	cc
 8004fca:	2100      	movcc	r1, #0
 8004fcc:	2004      	movs	r0, #4
 8004fce:	f7fb fdff 	bl	8000bd0 <_test_assert>
 8004fd2:	4606      	mov	r6, r0
 8004fd4:	2800      	cmp	r0, #0
 8004fd6:	d1d6      	bne.n	8004f86 <evt2_execute.10428+0x36>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
 8004fd8:	f7ff fe1a 	bl	8004c10 <test_wait_tick>
 8004fdc:	f385 8811 	msr	BASEPRI, r5
 8004fe0:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
 8004fe4:	f8d8 7024 	ldr.w	r7, [r8, #36]	; 0x24
 8004fe8:	f386 8811 	msr	BASEPRI, r6
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004fec:	69a1      	ldr	r1, [r4, #24]
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8004fee:	4b89      	ldr	r3, [pc, #548]	; (8005214 <evt2_execute.10428+0x2c4>)
 8004ff0:	688a      	ldr	r2, [r1, #8]
 8004ff2:	4889      	ldr	r0, [pc, #548]	; (8005218 <evt2_execute.10428+0x2c8>)
 8004ff4:	9100      	str	r1, [sp, #0]
 8004ff6:	3a01      	subs	r2, #1
 8004ff8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004ffc:	f7fe fe60 	bl	8003cc0 <chThdCreateStatic>
 8005000:	4e86      	ldr	r6, [pc, #536]	; (800521c <evt2_execute.10428+0x2cc>)
 8005002:	6030      	str	r0, [r6, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 8005004:	f7fb fc64 	bl	80008d0 <chEvtWaitOne.constprop.34>
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 8005008:	f507 71fa 	add.w	r1, r7, #500	; 0x1f4
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 800500c:	4681      	mov	r9, r0
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 800500e:	f207 2226 	addw	r2, r7, #550	; 0x226
 8005012:	2005      	movs	r0, #5
 8005014:	f7fb fd94 	bl	8000b40 <_test_assert_time_window>
 8005018:	2800      	cmp	r0, #0
 800501a:	d1b4      	bne.n	8004f86 <evt2_execute.10428+0x36>
  test_assert(6, m == 1, "single event error");
 800501c:	f1b9 0e01 	subs.w	lr, r9, #1
 8005020:	f1de 0100 	rsbs	r1, lr, #0
 8005024:	eb51 010e 	adcs.w	r1, r1, lr
 8005028:	2006      	movs	r0, #6
 800502a:	f7fb fdd1 	bl	8000bd0 <_test_assert>
 800502e:	2800      	cmp	r0, #0
 8005030:	d1a9      	bne.n	8004f86 <evt2_execute.10428+0x36>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8005032:	f7fb fc25 	bl	8000880 <chEvtGetAndClearEvents.constprop.38>
  test_assert(7, m == 0, "stuck event");
 8005036:	f1d0 0101 	rsbs	r1, r0, #1
 800503a:	bf38      	it	cc
 800503c:	2100      	movcc	r1, #0
 800503e:	2007      	movs	r0, #7
 8005040:	f7fb fdc6 	bl	8000bd0 <_test_assert>
 8005044:	4607      	mov	r7, r0
 8005046:	2800      	cmp	r0, #0
 8005048:	d19d      	bne.n	8004f86 <evt2_execute.10428+0x36>
  test_wait_threads();
 800504a:	f7fc fee1 	bl	8001e10 <test_wait_threads>
 800504e:	f385 8811 	msr	BASEPRI, r5
 8005052:	69a3      	ldr	r3, [r4, #24]
 8005054:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8005056:	f042 0205 	orr.w	r2, r2, #5
 800505a:	635a      	str	r2, [r3, #52]	; 0x34
 800505c:	f387 8811 	msr	BASEPRI, r7

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
  m = chEvtWaitAny(ALL_EVENTS);
 8005060:	f7fb fc56 	bl	8000910 <chEvtWaitAny.constprop.33>
  test_assert(8, m == 5, "unexpected pending bit");
 8005064:	1f47      	subs	r7, r0, #5
 8005066:	4279      	negs	r1, r7
 8005068:	4179      	adcs	r1, r7
 800506a:	2008      	movs	r0, #8
 800506c:	f7fb fdb0 	bl	8000bd0 <_test_assert>
 8005070:	2800      	cmp	r0, #0
 8005072:	d188      	bne.n	8004f86 <evt2_execute.10428+0x36>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8005074:	f7fb fc04 	bl	8000880 <chEvtGetAndClearEvents.constprop.38>
  test_assert(9, m == 0, "stuck event");
 8005078:	f1d0 0101 	rsbs	r1, r0, #1
 800507c:	bf38      	it	cc
 800507e:	2100      	movcc	r1, #0
 8005080:	2009      	movs	r0, #9
 8005082:	f7fb fda5 	bl	8000bd0 <_test_assert>
 8005086:	4607      	mov	r7, r0
 8005088:	2800      	cmp	r0, #0
 800508a:	f47f af7c 	bne.w	8004f86 <evt2_execute.10428+0x36>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
 800508e:	f7ff fdbf 	bl	8004c10 <test_wait_tick>
 8005092:	f385 8811 	msr	BASEPRI, r5
 8005096:	f8d8 5024 	ldr.w	r5, [r8, #36]	; 0x24
 800509a:	f387 8811 	msr	BASEPRI, r7
 800509e:	69a1      	ldr	r1, [r4, #24]
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80050a0:	4b5c      	ldr	r3, [pc, #368]	; (8005214 <evt2_execute.10428+0x2c4>)
 80050a2:	688a      	ldr	r2, [r1, #8]
 80050a4:	485c      	ldr	r0, [pc, #368]	; (8005218 <evt2_execute.10428+0x2c8>)
 80050a6:	9100      	str	r1, [sp, #0]
 80050a8:	3a01      	subs	r2, #1
 80050aa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80050ae:	f7fe fe07 	bl	8003cc0 <chThdCreateStatic>
 80050b2:	6030      	str	r0, [r6, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 80050b4:	f7fb fc2c 	bl	8000910 <chEvtWaitAny.constprop.33>
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 80050b8:	f505 71fa 	add.w	r1, r5, #500	; 0x1f4
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 80050bc:	4607      	mov	r7, r0
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 80050be:	f205 2226 	addw	r2, r5, #550	; 0x226
 80050c2:	200a      	movs	r0, #10
 80050c4:	f7fb fd3c 	bl	8000b40 <_test_assert_time_window>
 80050c8:	2800      	cmp	r0, #0
 80050ca:	f47f af5c 	bne.w	8004f86 <evt2_execute.10428+0x36>
  test_assert(11, m == 1, "single event error");
 80050ce:	1e78      	subs	r0, r7, #1
 80050d0:	4241      	negs	r1, r0
 80050d2:	4141      	adcs	r1, r0
 80050d4:	200b      	movs	r0, #11
 80050d6:	f7fb fd7b 	bl	8000bd0 <_test_assert>
 80050da:	2800      	cmp	r0, #0
 80050dc:	f47f af53 	bne.w	8004f86 <evt2_execute.10428+0x36>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 80050e0:	f7fb fbce 	bl	8000880 <chEvtGetAndClearEvents.constprop.38>
  test_assert(12, m == 0, "stuck event");
 80050e4:	f1d0 0101 	rsbs	r1, r0, #1
 80050e8:	bf38      	it	cc
 80050ea:	2100      	movcc	r1, #0
 80050ec:	200c      	movs	r0, #12
 80050ee:	f7fb fd6f 	bl	8000bd0 <_test_assert>
 80050f2:	4607      	mov	r7, r0
 80050f4:	2800      	cmp	r0, #0
 80050f6:	f47f af46 	bne.w	8004f86 <evt2_execute.10428+0x36>
  test_wait_threads();
 80050fa:	f7fc fe89 	bl	8001e10 <test_wait_threads>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 80050fe:	4d48      	ldr	r5, [pc, #288]	; (8005220 <evt2_execute.10428+0x2d0>)
 8005100:	4b48      	ldr	r3, [pc, #288]	; (8005224 <evt2_execute.10428+0x2d4>)
 8005102:	602d      	str	r5, [r5, #0]
 8005104:	601b      	str	r3, [r3, #0]
 8005106:	f04f 0a20 	mov.w	sl, #32
 800510a:	f38a 8811 	msr	BASEPRI, sl
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 800510e:	f10d 0930 	add.w	r9, sp, #48	; 0x30
 8005112:	682a      	ldr	r2, [r5, #0]
 8005114:	f849 2d28 	str.w	r2, [r9, #-40]!
  esp->es_next     = elp;
  elp->el_listener = currp;
 8005118:	69a1      	ldr	r1, [r4, #24]
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 800511a:	9705      	str	r7, [sp, #20]

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
 800511c:	2001      	movs	r0, #1
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 800511e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 8005122:	9103      	str	r1, [sp, #12]
  elp->el_events   = events;
 8005124:	9004      	str	r0, [sp, #16]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
 8005126:	f8c5 9000 	str.w	r9, [r5]
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 800512a:	9206      	str	r2, [sp, #24]
 800512c:	f387 8811 	msr	BASEPRI, r7
 8005130:	f38a 8811 	msr	BASEPRI, sl
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8005134:	f10d 0830 	add.w	r8, sp, #48	; 0x30
 8005138:	6819      	ldr	r1, [r3, #0]
 800513a:	f848 1d14 	str.w	r1, [r8, #-20]!
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
 800513e:	2004      	movs	r0, #4
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 8005140:	69a1      	ldr	r1, [r4, #24]
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 8005142:	970a      	str	r7, [sp, #40]	; 0x28
  elp->el_wflags   = wflags;
 8005144:	920b      	str	r2, [sp, #44]	; 0x2c
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 8005146:	9108      	str	r1, [sp, #32]
  elp->el_events   = events;
 8005148:	9009      	str	r0, [sp, #36]	; 0x24

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
 800514a:	f8c3 8000 	str.w	r8, [r3]
 800514e:	f387 8811 	msr	BASEPRI, r7
   */
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
 8005152:	f7ff fd5d 	bl	8004c10 <test_wait_tick>
 8005156:	f38a 8811 	msr	BASEPRI, sl
 800515a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800515e:	f8d3 b024 	ldr.w	fp, [r3, #36]	; 0x24
 8005162:	f387 8811 	msr	BASEPRI, r7
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005166:	69a3      	ldr	r3, [r4, #24]
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8005168:	492f      	ldr	r1, [pc, #188]	; (8005228 <evt2_execute.10428+0x2d8>)
 800516a:	689a      	ldr	r2, [r3, #8]
 800516c:	482a      	ldr	r0, [pc, #168]	; (8005218 <evt2_execute.10428+0x2c8>)
 800516e:	9100      	str	r1, [sp, #0]
 8005170:	3a01      	subs	r2, #1
 8005172:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8005176:	4b2d      	ldr	r3, [pc, #180]	; (800522c <evt2_execute.10428+0x2dc>)
 8005178:	f7fe fda2 	bl	8003cc0 <chThdCreateStatic>
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 800517c:	f50b 77fa 	add.w	r7, fp, #500	; 0x1f4
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8005180:	6030      	str	r0, [r6, #0]
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
  thread_t *ctp = currp;
 8005182:	69a4      	ldr	r4, [r4, #24]
 8005184:	f38a 8811 	msr	BASEPRI, sl

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 8005188:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800518a:	f003 0205 	and.w	r2, r3, #5
 800518e:	2a05      	cmp	r2, #5
 8005190:	d005      	beq.n	800519e <evt2_execute.10428+0x24e>
    ctp->p_u.ewmask = events;
 8005192:	2305      	movs	r3, #5
 8005194:	6223      	str	r3, [r4, #32]
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8005196:	200b      	movs	r0, #11
 8005198:	f7fe fdd2 	bl	8003d40 <chSchGoSleepS>
 800519c:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  ctp->p_epending &= ~events;
 800519e:	f023 0305 	bic.w	r3, r3, #5
 80051a2:	6363      	str	r3, [r4, #52]	; 0x34
 80051a4:	2300      	movs	r3, #0
 80051a6:	f383 8811 	msr	BASEPRI, r3
                                 thread2, "A");
  m = chEvtWaitAll(5);
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
 80051aa:	200d      	movs	r0, #13
 80051ac:	4639      	mov	r1, r7
 80051ae:	f20b 2226 	addw	r2, fp, #550	; 0x226
 80051b2:	f7fb fcc5 	bl	8000b40 <_test_assert_time_window>
 80051b6:	2800      	cmp	r0, #0
 80051b8:	f47f aee5 	bne.w	8004f86 <evt2_execute.10428+0x36>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 80051bc:	f7fb fb60 	bl	8000880 <chEvtGetAndClearEvents.constprop.38>
  test_assert(14, m == 0, "stuck event");
 80051c0:	f1d0 0101 	rsbs	r1, r0, #1
 80051c4:	bf38      	it	cc
 80051c6:	2100      	movcc	r1, #0
 80051c8:	200e      	movs	r0, #14
 80051ca:	f7fb fd01 	bl	8000bd0 <_test_assert>
 80051ce:	2800      	cmp	r0, #0
 80051d0:	f47f aed9 	bne.w	8004f86 <evt2_execute.10428+0x36>
  test_wait_threads();
  chEvtUnregister(&es1, &el1);
  chEvtUnregister(&es2, &el2);
 80051d4:	4c13      	ldr	r4, [pc, #76]	; (8005224 <evt2_execute.10428+0x2d4>)
                                 thread2, "A");
  m = chEvtWaitAll(5);
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
  m = chEvtGetAndClearEvents(ALL_EVENTS);
  test_assert(14, m == 0, "stuck event");
  test_wait_threads();
 80051d6:	f7fc fe1b 	bl	8001e10 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
 80051da:	4649      	mov	r1, r9
 80051dc:	4810      	ldr	r0, [pc, #64]	; (8005220 <evt2_execute.10428+0x2d0>)
 80051de:	f7fe fc57 	bl	8003a90 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
 80051e2:	4641      	mov	r1, r8
 80051e4:	4620      	mov	r0, r4
 80051e6:	f7fe fc53 	bl	8003a90 <chEvtUnregister>
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
 80051ea:	6829      	ldr	r1, [r5, #0]
 80051ec:	1b4a      	subs	r2, r1, r5
 80051ee:	4251      	negs	r1, r2
 80051f0:	4151      	adcs	r1, r2
 80051f2:	200f      	movs	r0, #15
 80051f4:	f7fb fcec 	bl	8000bd0 <_test_assert>
 80051f8:	2800      	cmp	r0, #0
 80051fa:	f47f aec4 	bne.w	8004f86 <evt2_execute.10428+0x36>
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
 80051fe:	6821      	ldr	r1, [r4, #0]
 8005200:	1b0b      	subs	r3, r1, r4
 8005202:	4259      	negs	r1, r3
 8005204:	4159      	adcs	r1, r3
 8005206:	2010      	movs	r0, #16
 8005208:	f7fb fce2 	bl	8000bd0 <_test_assert>
 800520c:	e6bb      	b.n	8004f86 <evt2_execute.10428+0x36>
 800520e:	bf00      	nop
 8005210:	20001208 	.word	0x20001208
 8005214:	08004b71 	.word	0x08004b71
 8005218:	20000928 	.word	0x20000928
 800521c:	20001358 	.word	0x20001358
 8005220:	200008b4 	.word	0x200008b4
 8005224:	20000868 	.word	0x20000868
 8005228:	08006894 	.word	0x08006894
 800522c:	080019c1 	.word	0x080019c1

08005230 <sem4_execute.9676>:
static THD_FUNCTION(thread4, p) {

  chBSemSignal((binary_semaphore_t *)p);
}

static void sem4_execute(void) {
 8005230:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005232:	b087      	sub	sp, #28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8005234:	ad03      	add	r5, sp, #12
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
  sp->s_cnt = n;
 8005236:	2400      	movs	r4, #0
 8005238:	9503      	str	r5, [sp, #12]
  tqp->p_prev = (thread_t *)tqp;
 800523a:	9504      	str	r5, [sp, #16]
 800523c:	9405      	str	r4, [sp, #20]
 800523e:	2620      	movs	r6, #32
 8005240:	f386 8811 	msr	BASEPRI, r6
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();
  chSemResetI(sp, n);
 8005244:	4628      	mov	r0, r5
 8005246:	4621      	mov	r1, r4
 8005248:	f7ff f812 	bl	8004270 <chSemResetI>
  chSchRescheduleS();
 800524c:	f7fe fcb0 	bl	8003bb0 <chSchRescheduleS>
 8005250:	f384 8811 	msr	BASEPRI, r4
 8005254:	f386 8811 	msr	BASEPRI, r6
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
 8005258:	9905      	ldr	r1, [sp, #20]
  binary_semaphore_t bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
 800525a:	42a1      	cmp	r1, r4
 800525c:	f04f 0001 	mov.w	r0, #1
 8005260:	bfcc      	ite	gt
 8005262:	2100      	movgt	r1, #0
 8005264:	2101      	movle	r1, #1
 8005266:	f7fb fcb3 	bl	8000bd0 <_test_assert>
 800526a:	4607      	mov	r7, r0
 800526c:	b118      	cbz	r0, 8005276 <sem4_execute.9676+0x46>
 800526e:	f384 8811 	msr	BASEPRI, r4

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
}
 8005272:	b007      	add	sp, #28
 8005274:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005276:	f380 8811 	msr	BASEPRI, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800527a:	4b3f      	ldr	r3, [pc, #252]	; (8005378 <sem4_execute.9676+0x148>)
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800527c:	483f      	ldr	r0, [pc, #252]	; (800537c <sem4_execute.9676+0x14c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 800527e:	699a      	ldr	r2, [r3, #24]
 8005280:	4b3f      	ldr	r3, [pc, #252]	; (8005380 <sem4_execute.9676+0x150>)
 8005282:	6892      	ldr	r2, [r2, #8]
 8005284:	9500      	str	r5, [sp, #0]
 8005286:	3a01      	subs	r2, #1
 8005288:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800528c:	f7fe fd18 	bl	8003cc0 <chThdCreateStatic>
 8005290:	4b3c      	ldr	r3, [pc, #240]	; (8005384 <sem4_execute.9676+0x154>)
 8005292:	6018      	str	r0, [r3, #0]
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {

  return chSemWait(&bsp->bs_sem);
 8005294:	4628      	mov	r0, r5
 8005296:	f7fe fd8b 	bl	8003db0 <chSemWait>
 800529a:	f386 8811 	msr	BASEPRI, r6
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
 800529e:	9905      	ldr	r1, [sp, #20]
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
  
  /* The binary semaphore is expected to be taken.*/
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
 80052a0:	2900      	cmp	r1, #0
 80052a2:	bfcc      	ite	gt
 80052a4:	2100      	movgt	r1, #0
 80052a6:	2101      	movle	r1, #1
 80052a8:	2002      	movs	r0, #2
 80052aa:	f7fb fc91 	bl	8000bd0 <_test_assert>
 80052ae:	b118      	cbz	r0, 80052b8 <sem4_execute.9676+0x88>
 80052b0:	f387 8811 	msr	BASEPRI, r7

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
}
 80052b4:	b007      	add	sp, #28
 80052b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80052b8:	f380 8811 	msr	BASEPRI, r0
 80052bc:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 80052c0:	9b05      	ldr	r3, [sp, #20]
 80052c2:	2b00      	cmp	r3, #0
 80052c4:	dd22      	ble.n	800530c <sem4_execute.9676+0xdc>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 80052c6:	f7fe fc73 	bl	8003bb0 <chSchRescheduleS>
 80052ca:	2400      	movs	r4, #0
 80052cc:	f384 8811 	msr	BASEPRI, r4
 80052d0:	2720      	movs	r7, #32
 80052d2:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
 80052d6:	9905      	ldr	r1, [sp, #20]
 80052d8:	42a1      	cmp	r1, r4
 80052da:	f04f 0003 	mov.w	r0, #3
 80052de:	bfd4      	ite	le
 80052e0:	2100      	movle	r1, #0
 80052e2:	2101      	movgt	r1, #1
 80052e4:	f7fb fc74 	bl	8000bd0 <_test_assert>
 80052e8:	4606      	mov	r6, r0
 80052ea:	2800      	cmp	r0, #0
 80052ec:	d1bf      	bne.n	800526e <sem4_execute.9676+0x3e>
 80052ee:	f380 8811 	msr	BASEPRI, r0
 80052f2:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 80052f6:	9905      	ldr	r1, [sp, #20]
 80052f8:	1e4a      	subs	r2, r1, #1
 80052fa:	4251      	negs	r1, r2
 80052fc:	4151      	adcs	r1, r2
 80052fe:	2004      	movs	r0, #4
 8005300:	f7fb fc66 	bl	8000bd0 <_test_assert>
 8005304:	b130      	cbz	r0, 8005314 <sem4_execute.9676+0xe4>
 8005306:	f386 8811 	msr	BASEPRI, r6
 800530a:	e7b2      	b.n	8005272 <sem4_execute.9676+0x42>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 800530c:	4628      	mov	r0, r5
 800530e:	f7fe ff9f 	bl	8004250 <chSemSignalI>
 8005312:	e7d8      	b.n	80052c6 <sem4_execute.9676+0x96>
 8005314:	f380 8811 	msr	BASEPRI, r0
 8005318:	f387 8811 	msr	BASEPRI, r7
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 800531c:	9b05      	ldr	r3, [sp, #20]
 800531e:	2b00      	cmp	r3, #0
 8005320:	dd22      	ble.n	8005368 <sem4_execute.9676+0x138>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8005322:	f7fe fc45 	bl	8003bb0 <chSchRescheduleS>
 8005326:	2400      	movs	r4, #0
 8005328:	f384 8811 	msr	BASEPRI, r4
 800532c:	2620      	movs	r6, #32
 800532e:	f386 8811 	msr	BASEPRI, r6

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
 8005332:	9905      	ldr	r1, [sp, #20]
 8005334:	42a1      	cmp	r1, r4
 8005336:	f04f 0003 	mov.w	r0, #3
 800533a:	bfd4      	ite	le
 800533c:	2100      	movle	r1, #0
 800533e:	2101      	movgt	r1, #1
 8005340:	f7fb fc46 	bl	8000bd0 <_test_assert>
 8005344:	4605      	mov	r5, r0
 8005346:	2800      	cmp	r0, #0
 8005348:	d191      	bne.n	800526e <sem4_execute.9676+0x3e>
 800534a:	f380 8811 	msr	BASEPRI, r0
 800534e:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 8005352:	9905      	ldr	r1, [sp, #20]
 8005354:	1e4b      	subs	r3, r1, #1
 8005356:	4259      	negs	r1, r3
 8005358:	4159      	adcs	r1, r3
 800535a:	2005      	movs	r0, #5
 800535c:	f7fb fc38 	bl	8000bd0 <_test_assert>
 8005360:	b130      	cbz	r0, 8005370 <sem4_execute.9676+0x140>
 8005362:	f385 8811 	msr	BASEPRI, r5
 8005366:	e784      	b.n	8005272 <sem4_execute.9676+0x42>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 8005368:	4628      	mov	r0, r5
 800536a:	f7fe ff71 	bl	8004250 <chSemSignalI>
 800536e:	e7d8      	b.n	8005322 <sem4_execute.9676+0xf2>
 8005370:	f380 8811 	msr	BASEPRI, r0
 8005374:	e77d      	b.n	8005272 <sem4_execute.9676+0x42>
 8005376:	bf00      	nop
 8005378:	20001208 	.word	0x20001208
 800537c:	20000928 	.word	0x20000928
 8005380:	08002ee1 	.word	0x08002ee1
 8005384:	20001358 	.word	0x20001358
 8005388:	f3af 8000 	nop.w
 800538c:	f3af 8000 	nop.w

08005390 <evt3_execute.10432>:
static void evt3_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void evt3_execute(void) {
 8005390:	b570      	push	{r4, r5, r6, lr}
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8005392:	4c55      	ldr	r4, [pc, #340]	; (80054e8 <evt3_execute.10432+0x158>)
 8005394:	2320      	movs	r3, #32
 8005396:	69a2      	ldr	r2, [r4, #24]
 8005398:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800539c:	6b53      	ldr	r3, [r2, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800539e:	b93b      	cbnz	r3, 80053b0 <evt3_execute.10432+0x20>
 80053a0:	f383 8811 	msr	BASEPRI, r3
 80053a4:	2101      	movs	r1, #1

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(1, m == 0, "spurious event");
 80053a6:	2001      	movs	r0, #1
 80053a8:	f7fb fc12 	bl	8000bd0 <_test_assert>
 80053ac:	b180      	cbz	r0, 80053d0 <evt3_execute.10432+0x40>
 80053ae:	bd70      	pop	{r4, r5, r6, pc}
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
  }
  m ^= m & (m - (eventmask_t)1);
 80053b0:	4259      	negs	r1, r3
 80053b2:	4019      	ands	r1, r3
  ctp->p_epending &= ~m;
 80053b4:	ea23 0301 	bic.w	r3, r3, r1
 80053b8:	6353      	str	r3, [r2, #52]	; 0x34
 80053ba:	2300      	movs	r3, #0
 80053bc:	f383 8811 	msr	BASEPRI, r3
 80053c0:	1ac8      	subs	r0, r1, r3
 80053c2:	4241      	negs	r1, r0
 80053c4:	4141      	adcs	r1, r0
 80053c6:	2001      	movs	r0, #1
 80053c8:	f7fb fc02 	bl	8000bd0 <_test_assert>
 80053cc:	2800      	cmp	r0, #0
 80053ce:	d1ee      	bne.n	80053ae <evt3_execute.10432+0x1e>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 80053d0:	69a3      	ldr	r3, [r4, #24]
 80053d2:	2220      	movs	r2, #32
 80053d4:	f382 8811 	msr	BASEPRI, r2
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
  if (m == (eventmask_t)0) {
 80053d8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80053da:	2a00      	cmp	r2, #0
 80053dc:	d06f      	beq.n	80054be <evt3_execute.10432+0x12e>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
  }
  ctp->p_epending &= ~m;
 80053de:	6358      	str	r0, [r3, #52]	; 0x34
 80053e0:	f380 8811 	msr	BASEPRI, r0
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(2, m == 0, "spurious event");
 80053e4:	4601      	mov	r1, r0
 80053e6:	2002      	movs	r0, #2
 80053e8:	f7fb fbf2 	bl	8000bd0 <_test_assert>
 80053ec:	2800      	cmp	r0, #0
 80053ee:	d1de      	bne.n	80053ae <evt3_execute.10432+0x1e>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 80053f0:	69a3      	ldr	r3, [r4, #24]
 80053f2:	2220      	movs	r2, #32
 80053f4:	f382 8811 	msr	BASEPRI, r2

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 80053f8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80053fa:	3201      	adds	r2, #1
 80053fc:	d063      	beq.n	80054c6 <evt3_execute.10432+0x136>
 80053fe:	f380 8811 	msr	BASEPRI, r0
 8005402:	2001      	movs	r0, #1
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(3, m == 0, "spurious event");
 8005404:	4601      	mov	r1, r0
 8005406:	2003      	movs	r0, #3
 8005408:	f7fb fbe2 	bl	8000bd0 <_test_assert>
 800540c:	2800      	cmp	r0, #0
 800540e:	d1ce      	bne.n	80053ae <evt3_execute.10432+0x1e>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8005410:	69a6      	ldr	r6, [r4, #24]
 8005412:	2320      	movs	r3, #32
 8005414:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 8005418:	6b75      	ldr	r5, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800541a:	b94d      	cbnz	r5, 8005430 <evt3_execute.10432+0xa0>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 800541c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8005420:	200a      	movs	r0, #10
  if (m == (eventmask_t)0) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 8005422:	6233      	str	r3, [r6, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8005424:	4601      	mov	r1, r0
 8005426:	f7fb f983 	bl	8000730 <chSchGoSleepTimeoutS>
 800542a:	2800      	cmp	r0, #0
 800542c:	db4f      	blt.n	80054ce <evt3_execute.10432+0x13e>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 800542e:	6b75      	ldr	r5, [r6, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 8005430:	4269      	negs	r1, r5
 8005432:	4029      	ands	r1, r5
  ctp->p_epending &= ~m;
 8005434:	ea25 0501 	bic.w	r5, r5, r1
 8005438:	6375      	str	r5, [r6, #52]	; 0x34
 800543a:	2300      	movs	r3, #0
 800543c:	f383 8811 	msr	BASEPRI, r3
 8005440:	1aca      	subs	r2, r1, r3
 8005442:	4251      	negs	r1, r2
 8005444:	4151      	adcs	r1, r2
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
  test_assert(4, m == 0, "spurious event");
 8005446:	2004      	movs	r0, #4
 8005448:	f7fb fbc2 	bl	8000bd0 <_test_assert>
 800544c:	2800      	cmp	r0, #0
 800544e:	d1ae      	bne.n	80053ae <evt3_execute.10432+0x1e>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8005450:	69a5      	ldr	r5, [r4, #24]
 8005452:	2320      	movs	r3, #32
 8005454:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 8005458:	6b6e      	ldr	r6, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800545a:	b94e      	cbnz	r6, 8005470 <evt3_execute.10432+0xe0>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 800545c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8005460:	200a      	movs	r0, #10
  if (m == (eventmask_t)0) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 8005462:	622b      	str	r3, [r5, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8005464:	4601      	mov	r1, r0
 8005466:	f7fb f963 	bl	8000730 <chSchGoSleepTimeoutS>
 800546a:	2800      	cmp	r0, #0
 800546c:	db33      	blt.n	80054d6 <evt3_execute.10432+0x146>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 800546e:	6b6e      	ldr	r6, [r5, #52]	; 0x34
  }
  ctp->p_epending &= ~m;
 8005470:	2300      	movs	r3, #0
 8005472:	636b      	str	r3, [r5, #52]	; 0x34
 8005474:	f383 8811 	msr	BASEPRI, r3
 8005478:	1af3      	subs	r3, r6, r3
 800547a:	4259      	negs	r1, r3
 800547c:	4159      	adcs	r1, r3
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
  test_assert(5, m == 0, "spurious event");
 800547e:	2005      	movs	r0, #5
 8005480:	f7fb fba6 	bl	8000bd0 <_test_assert>
 8005484:	4605      	mov	r5, r0
 8005486:	2800      	cmp	r0, #0
 8005488:	d191      	bne.n	80053ae <evt3_execute.10432+0x1e>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 800548a:	69a4      	ldr	r4, [r4, #24]
 800548c:	2320      	movs	r3, #32
 800548e:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 8005492:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005494:	3301      	adds	r3, #1
 8005496:	d008      	beq.n	80054aa <evt3_execute.10432+0x11a>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 8005498:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800549c:	6223      	str	r3, [r4, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 800549e:	200b      	movs	r0, #11
 80054a0:	210a      	movs	r1, #10
 80054a2:	f7fb f945 	bl	8000730 <chSchGoSleepTimeoutS>
 80054a6:	2800      	cmp	r0, #0
 80054a8:	db19      	blt.n	80054de <evt3_execute.10432+0x14e>
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->p_epending &= ~events;
 80054aa:	2300      	movs	r3, #0
 80054ac:	6363      	str	r3, [r4, #52]	; 0x34
 80054ae:	f383 8811 	msr	BASEPRI, r3
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
  test_assert(6, m == 0, "spurious event");
 80054b2:	4629      	mov	r1, r5
 80054b4:	2006      	movs	r0, #6
}
 80054b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
  test_assert(4, m == 0, "spurious event");
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
  test_assert(5, m == 0, "spurious event");
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
  test_assert(6, m == 0, "spurious event");
 80054ba:	f7fb bb89 	b.w	8000bd0 <_test_assert>
 80054be:	f380 8811 	msr	BASEPRI, r0
 80054c2:	2001      	movs	r0, #1
 80054c4:	e78e      	b.n	80053e4 <evt3_execute.10432+0x54>
 80054c6:	6358      	str	r0, [r3, #52]	; 0x34
 80054c8:	f380 8811 	msr	BASEPRI, r0
 80054cc:	e79a      	b.n	8005404 <evt3_execute.10432+0x74>
 80054ce:	f385 8811 	msr	BASEPRI, r5
 80054d2:	2101      	movs	r1, #1
 80054d4:	e7b7      	b.n	8005446 <evt3_execute.10432+0xb6>
 80054d6:	f386 8811 	msr	BASEPRI, r6
 80054da:	2101      	movs	r1, #1
 80054dc:	e7cf      	b.n	800547e <evt3_execute.10432+0xee>
 80054de:	f385 8811 	msr	BASEPRI, r5
 80054e2:	2501      	movs	r5, #1
 80054e4:	e7e5      	b.n	80054b2 <evt3_execute.10432+0x122>
 80054e6:	bf00      	nop
 80054e8:	20001208 	.word	0x20001208
 80054ec:	f3af 8000 	nop.w

080054f0 <Vector14C.4399>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 80054f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 80054f4:	4e7e      	ldr	r6, [pc, #504]	; (80056f0 <Vector14C.4399+0x200>)
 80054f6:	6d34      	ldr	r4, [r6, #80]	; 0x50
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 80054f8:	6963      	ldr	r3, [r4, #20]
  sts &= otgp->GINTMSK;
 80054fa:	69a5      	ldr	r5, [r4, #24]
 80054fc:	401d      	ands	r5, r3
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 80054fe:	04e8      	lsls	r0, r5, #19
  stm32_otg_t *otgp = usbp->otg;
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
  sts &= otgp->GINTMSK;
  otgp->GINTSTS = sts;
 8005500:	6165      	str	r5, [r4, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8005502:	d436      	bmi.n	8005572 <Vector14C.4399+0x82>
    _usb_reset(usbp);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 8005504:	04ab      	lsls	r3, r5, #18
    (void)otgp->DSTS;
 8005506:	bf48      	it	mi
 8005508:	f8d4 3808 	ldrmi.w	r3, [r4, #2056]	; 0x808
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 800550c:	072f      	lsls	r7, r5, #28
 800550e:	d504      	bpl.n	800551a <Vector14C.4399+0x2a>
    _usb_isr_invoke_sof_cb(usbp);
 8005510:	6873      	ldr	r3, [r6, #4]
 8005512:	68db      	ldr	r3, [r3, #12]
 8005514:	b10b      	cbz	r3, 800551a <Vector14C.4399+0x2a>
 8005516:	4876      	ldr	r0, [pc, #472]	; (80056f0 <Vector14C.4399+0x200>)
 8005518:	4798      	blx	r3
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 800551a:	06e8      	lsls	r0, r5, #27
 800551c:	f100 80a2 	bmi.w	8005664 <Vector14C.4399+0x174>
    osalSysUnlockFromISR();
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
  if (sts & GINTSTS_IEPINT) {
 8005520:	0369      	lsls	r1, r5, #13
    osalThreadResumeI(&usbp->wait, MSG_OK);
    osalSysUnlockFromISR();
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 8005522:	f8d4 4818 	ldr.w	r4, [r4, #2072]	; 0x818
  if (sts & GINTSTS_IEPINT) {
 8005526:	d50b      	bpl.n	8005540 <Vector14C.4399+0x50>
    if (src & (1 << 0))
 8005528:	07e2      	lsls	r2, r4, #31
 800552a:	f100 80c6 	bmi.w	80056ba <Vector14C.4399+0x1ca>
      otg_epin_handler(usbp, 0);
    if (src & (1 << 1))
 800552e:	07a3      	lsls	r3, r4, #30
 8005530:	f100 80ca 	bmi.w	80056c8 <Vector14C.4399+0x1d8>
      otg_epin_handler(usbp, 1);
    if (src & (1 << 2))
 8005534:	0767      	lsls	r7, r4, #29
 8005536:	f100 80ce 	bmi.w	80056d6 <Vector14C.4399+0x1e6>
      otg_epin_handler(usbp, 2);
    if (src & (1 << 3))
 800553a:	0726      	lsls	r6, r4, #28
 800553c:	f100 80d2 	bmi.w	80056e4 <Vector14C.4399+0x1f4>
      otg_epin_handler(usbp, 4);
    if (src & (1 << 5))
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
 8005540:	032d      	lsls	r5, r5, #12
 8005542:	d50a      	bpl.n	800555a <Vector14C.4399+0x6a>
    if (src & (1 << 16))
 8005544:	03e0      	lsls	r0, r4, #15
 8005546:	f100 80a9 	bmi.w	800569c <Vector14C.4399+0x1ac>
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
 800554a:	03a1      	lsls	r1, r4, #14
 800554c:	f100 80ad 	bmi.w	80056aa <Vector14C.4399+0x1ba>
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
 8005550:	0362      	lsls	r2, r4, #13
 8005552:	f100 809b 	bmi.w	800568c <Vector14C.4399+0x19c>
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
 8005556:	0323      	lsls	r3, r4, #12
 8005558:	d403      	bmi.n	8005562 <Vector14C.4399+0x72>
  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
}
 800555a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 800555e:	f7fe ba4f 	b.w	8003a00 <_port_irq_epilogue>
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
      otg_epout_handler(usbp, 3);
 8005562:	4863      	ldr	r0, [pc, #396]	; (80056f0 <Vector14C.4399+0x200>)
 8005564:	2103      	movs	r1, #3
 8005566:	f7fe f9cb 	bl	8003900 <otg_epout_handler.8634>
  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
}
 800556a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 800556e:	f7fe ba47 	b.w	8003a00 <_port_irq_epilogue>
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  usbp->state         = USB_READY;
  usbp->status        = 0;
 8005572:	2300      	movs	r3, #0
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  usbp->state         = USB_READY;
 8005574:	2102      	movs	r1, #2
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8005576:	2220      	movs	r2, #32
  usbp->status        = 0;
 8005578:	f8a6 304c 	strh.w	r3, [r6, #76]	; 0x4c
  usbp->address       = 0;
 800557c:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
  usbp->configuration = 0;
 8005580:	f886 304f 	strb.w	r3, [r6, #79]	; 0x4f
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 8005584:	6133      	str	r3, [r6, #16]
 8005586:	6173      	str	r3, [r6, #20]
 8005588:	61b3      	str	r3, [r6, #24]
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800558a:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34

  usbp->state         = USB_READY;
  usbp->status        = 0;
  usbp->address       = 0;
  usbp->configuration = 0;
  usbp->transmitting  = 0;
 800558e:	8133      	strh	r3, [r6, #8]
  usbp->receiving     = 0;
 8005590:	8173      	strh	r3, [r6, #10]
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  usbp->state         = USB_READY;
 8005592:	7031      	strb	r1, [r6, #0]
 8005594:	6122      	str	r2, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8005596:	6923      	ldr	r3, [r4, #16]
 8005598:	0699      	lsls	r1, r3, #26
 800559a:	d4fc      	bmi.n	8005596 <Vector14C.4399+0xa6>
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 800559c:	4a55      	ldr	r2, [pc, #340]	; (80056f4 <Vector14C.4399+0x204>)
 800559e:	6851      	ldr	r1, [r2, #4]
 80055a0:	6853      	ldr	r3, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)((cnt - start) < (end - start));
 80055a2:	1a5b      	subs	r3, r3, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 80055a4:	2b0b      	cmp	r3, #11
 80055a6:	d9fb      	bls.n	80055a0 <Vector14C.4399+0xb0>
 80055a8:	f8d6 c054 	ldr.w	ip, [r6, #84]	; 0x54
 80055ac:	f8dc 7008 	ldr.w	r7, [ip, #8]
 80055b0:	2200      	movs	r2, #0
  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 80055b2:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
    otgp->ie[i].DIEPINT = 0xFF;
 80055b6:	21ff      	movs	r1, #255	; 0xff
 80055b8:	eb04 1342 	add.w	r3, r4, r2, lsl #5

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80055bc:	3201      	adds	r2, #1
 80055be:	42ba      	cmp	r2, r7
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 80055c0:	f8c3 0900 	str.w	r0, [r3, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 80055c4:	f8c3 0b00 	str.w	r0, [r3, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFF;
 80055c8:	f8c3 1908 	str.w	r1, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFF;
 80055cc:	f8c3 1b08 	str.w	r1, [r3, #2824]	; 0xb08

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80055d0:	d9f2      	bls.n	80055b8 <Vector14C.4399+0xc8>
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 80055d2:	f8dc 0000 	ldr.w	r0, [ip]
 80055d6:	65b0      	str	r0, [r6, #88]	; 0x58

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 80055d8:	f8dc 2000 	ldr.w	r2, [ip]
    otgp->ie[i].DIEPINT = 0xFF;
    otgp->oe[i].DOEPINT = 0xFF;
  }

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DAINT = 0xFFFFFFFF;
 80055dc:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80055e0:	f04f 1101 	mov.w	r1, #65537	; 0x10001
}

static void otg_rxfifo_flush(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 80055e4:	2310      	movs	r3, #16
    otgp->ie[i].DIEPINT = 0xFF;
    otgp->oe[i].DOEPINT = 0xFF;
  }

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DAINT = 0xFFFFFFFF;
 80055e6:	f8c4 7818 	str.w	r7, [r4, #2072]	; 0x818
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80055ea:	f8c4 181c 	str.w	r1, [r4, #2076]	; 0x81c

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 80055ee:	6262      	str	r2, [r4, #36]	; 0x24
}

static void otg_rxfifo_flush(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 80055f0:	6123      	str	r3, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 80055f2:	6923      	ldr	r3, [r4, #16]
 80055f4:	06da      	lsls	r2, r3, #27
 80055f6:	d4fc      	bmi.n	80055f2 <Vector14C.4399+0x102>
 80055f8:	4a3e      	ldr	r2, [pc, #248]	; (80056f4 <Vector14C.4399+0x204>)
 80055fa:	6851      	ldr	r1, [r2, #4]
 80055fc:	6853      	ldr	r3, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)((cnt - start) < (end - start));
 80055fe:	1a5b      	subs	r3, r3, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8005600:	2b0b      	cmp	r3, #11
 8005602:	d9fb      	bls.n	80055fc <Vector14C.4399+0x10c>
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8005604:	f8d4 1800 	ldr.w	r1, [r4, #2048]	; 0x800
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
    _usb_reset(usbp);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8005608:	6873      	ldr	r3, [r6, #4]
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 800560a:	4a3b      	ldr	r2, [pc, #236]	; (80056f8 <Vector14C.4399+0x208>)
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
    _usb_reset(usbp);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 800560c:	f8d3 c000 	ldr.w	ip, [r3]
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8005610:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 80056fc <Vector14C.4399+0x20c>
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8005614:	f421 63fe 	bic.w	r3, r1, #2032	; 0x7f0
 8005618:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 800561c:	69a3      	ldr	r3, [r4, #24]
 800561e:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8005622:	2709      	movs	r7, #9
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
 8005624:	2100      	movs	r1, #0
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 8005626:	f100 0910 	add.w	r9, r0, #16

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 800562a:	f043 0310 	orr.w	r3, r3, #16
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 800562e:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8005632:	61a3      	str	r3, [r4, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8005634:	f8c4 7810 	str.w	r7, [r4, #2064]	; 0x810
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 8005638:	f8c6 9058 	str.w	r9, [r6, #88]	; 0x58
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 800563c:	f8c4 7814 	str.w	r7, [r4, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8005640:	f8c6 800c 	str.w	r8, [r6, #12]
  otgp->oe[0].DOEPTSIZ = 0;
 8005644:	f8c4 1b10 	str.w	r1, [r4, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8005648:	f8c4 2b00 	str.w	r2, [r4, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 800564c:	f8c4 1910 	str.w	r1, [r4, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8005650:	f8c4 2900 	str.w	r2, [r4, #2304]	; 0x900
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8005654:	62a0      	str	r0, [r4, #40]	; 0x28
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
    _usb_reset(usbp);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8005656:	f1bc 0f00 	cmp.w	ip, #0
 800565a:	f43f af53 	beq.w	8005504 <Vector14C.4399+0x14>
 800565e:	4824      	ldr	r0, [pc, #144]	; (80056f0 <Vector14C.4399+0x200>)
 8005660:	47e0      	blx	ip
 8005662:	e74f      	b.n	8005504 <Vector14C.4399+0x14>
 8005664:	2320      	movs	r3, #32
 8005666:	f383 8811 	msr	BASEPRI, r3
  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 800566a:	69a2      	ldr	r2, [r4, #24]
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 800566c:	6e33      	ldr	r3, [r6, #96]	; 0x60
 800566e:	4920      	ldr	r1, [pc, #128]	; (80056f0 <Vector14C.4399+0x200>)
 8005670:	f022 0210 	bic.w	r2, r2, #16
 8005674:	61a2      	str	r2, [r4, #24]
 8005676:	b12b      	cbz	r3, 8005684 <Vector14C.4399+0x194>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8005678:	2200      	movs	r2, #0
 800567a:	660a      	str	r2, [r1, #96]	; 0x60
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 800567c:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 800567e:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 8005680:	f7fe fbbe 	bl	8003e00 <chSchReadyI>
 8005684:	2300      	movs	r3, #0
 8005686:	f383 8811 	msr	BASEPRI, r3
 800568a:	e749      	b.n	8005520 <Vector14C.4399+0x30>
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
      otg_epout_handler(usbp, 2);
 800568c:	4818      	ldr	r0, [pc, #96]	; (80056f0 <Vector14C.4399+0x200>)
 800568e:	2102      	movs	r1, #2
 8005690:	f7fe f936 	bl	8003900 <otg_epout_handler.8634>
    if (src & (1 << 19))
 8005694:	0323      	lsls	r3, r4, #12
 8005696:	f57f af60 	bpl.w	800555a <Vector14C.4399+0x6a>
 800569a:	e762      	b.n	8005562 <Vector14C.4399+0x72>
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
 800569c:	2100      	movs	r1, #0
 800569e:	4814      	ldr	r0, [pc, #80]	; (80056f0 <Vector14C.4399+0x200>)
 80056a0:	f7fe f92e 	bl	8003900 <otg_epout_handler.8634>
    if (src & (1 << 17))
 80056a4:	03a1      	lsls	r1, r4, #14
 80056a6:	f57f af53 	bpl.w	8005550 <Vector14C.4399+0x60>
      otg_epout_handler(usbp, 1);
 80056aa:	4811      	ldr	r0, [pc, #68]	; (80056f0 <Vector14C.4399+0x200>)
 80056ac:	2101      	movs	r1, #1
 80056ae:	f7fe f927 	bl	8003900 <otg_epout_handler.8634>
    if (src & (1 << 18))
 80056b2:	0362      	lsls	r2, r4, #13
 80056b4:	f57f af4f 	bpl.w	8005556 <Vector14C.4399+0x66>
 80056b8:	e7e8      	b.n	800568c <Vector14C.4399+0x19c>

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
  if (sts & GINTSTS_IEPINT) {
    if (src & (1 << 0))
      otg_epin_handler(usbp, 0);
 80056ba:	480d      	ldr	r0, [pc, #52]	; (80056f0 <Vector14C.4399+0x200>)
 80056bc:	2100      	movs	r1, #0
 80056be:	f7fd ff57 	bl	8003570 <otg_epin_handler.8642>
    if (src & (1 << 1))
 80056c2:	07a3      	lsls	r3, r4, #30
 80056c4:	f57f af36 	bpl.w	8005534 <Vector14C.4399+0x44>
      otg_epin_handler(usbp, 1);
 80056c8:	4809      	ldr	r0, [pc, #36]	; (80056f0 <Vector14C.4399+0x200>)
 80056ca:	2101      	movs	r1, #1
 80056cc:	f7fd ff50 	bl	8003570 <otg_epin_handler.8642>
    if (src & (1 << 2))
 80056d0:	0767      	lsls	r7, r4, #29
 80056d2:	f57f af32 	bpl.w	800553a <Vector14C.4399+0x4a>
      otg_epin_handler(usbp, 2);
 80056d6:	4806      	ldr	r0, [pc, #24]	; (80056f0 <Vector14C.4399+0x200>)
 80056d8:	2102      	movs	r1, #2
 80056da:	f7fd ff49 	bl	8003570 <otg_epin_handler.8642>
    if (src & (1 << 3))
 80056de:	0726      	lsls	r6, r4, #28
 80056e0:	f57f af2e 	bpl.w	8005540 <Vector14C.4399+0x50>
      otg_epin_handler(usbp, 3);
 80056e4:	4802      	ldr	r0, [pc, #8]	; (80056f0 <Vector14C.4399+0x200>)
 80056e6:	2103      	movs	r1, #3
 80056e8:	f7fd ff42 	bl	8003570 <otg_epin_handler.8642>
 80056ec:	e728      	b.n	8005540 <Vector14C.4399+0x50>
 80056ee:	bf00      	nop
 80056f0:	20000fc8 	.word	0x20000fc8
 80056f4:	e0001000 	.word	0xe0001000
 80056f8:	10008040 	.word	0x10008040
 80056fc:	080068f0 	.word	0x080068f0

08005700 <__early_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8005700:	492c      	ldr	r1, [pc, #176]	; (80057b4 <__early_init+0xb4>)

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8005702:	4b2d      	ldr	r3, [pc, #180]	; (80057b8 <__early_init+0xb8>)
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8005704:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8005708:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800570c:	6408      	str	r0, [r1, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800570e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8005710:	680b      	ldr	r3, [r1, #0]
 8005712:	f043 0301 	orr.w	r3, r3, #1
 8005716:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8005718:	680b      	ldr	r3, [r1, #0]
 800571a:	4a26      	ldr	r2, [pc, #152]	; (80057b4 <__early_init+0xb4>)
 800571c:	0798      	lsls	r0, r3, #30
 800571e:	d5fb      	bpl.n	8005718 <__early_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8005720:	6893      	ldr	r3, [r2, #8]
 8005722:	f023 0303 	bic.w	r3, r3, #3
 8005726:	6093      	str	r3, [r2, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8005728:	6893      	ldr	r3, [r2, #8]
 800572a:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800572c:	4611      	mov	r1, r2
 800572e:	688b      	ldr	r3, [r1, #8]
 8005730:	4a20      	ldr	r2, [pc, #128]	; (80057b4 <__early_init+0xb4>)
 8005732:	f013 030c 	ands.w	r3, r3, #12
 8005736:	d1fa      	bne.n	800572e <__early_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8005738:	6811      	ldr	r1, [r2, #0]
 800573a:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 800573e:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8005740:	6093      	str	r3, [r2, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8005742:	6813      	ldr	r3, [r2, #0]
 8005744:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8005748:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800574a:	6813      	ldr	r3, [r2, #0]
 800574c:	4919      	ldr	r1, [pc, #100]	; (80057b4 <__early_init+0xb4>)
 800574e:	039b      	lsls	r3, r3, #14
 8005750:	d5fb      	bpl.n	800574a <__early_init+0x4a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8005752:	6f4b      	ldr	r3, [r1, #116]	; 0x74
 8005754:	f043 0301 	orr.w	r3, r3, #1
 8005758:	674b      	str	r3, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800575a:	6f4b      	ldr	r3, [r1, #116]	; 0x74
 800575c:	4a15      	ldr	r2, [pc, #84]	; (80057b4 <__early_init+0xb4>)
 800575e:	0798      	lsls	r0, r3, #30
 8005760:	d5fb      	bpl.n	800575a <__early_init+0x5a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8005762:	4b16      	ldr	r3, [pc, #88]	; (80057bc <__early_init+0xbc>)
 8005764:	6053      	str	r3, [r2, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8005766:	6813      	ldr	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8005768:	4913      	ldr	r1, [pc, #76]	; (80057b8 <__early_init+0xb8>)

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 800576a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800576e:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8005770:	684b      	ldr	r3, [r1, #4]
 8005772:	045a      	lsls	r2, r3, #17
 8005774:	d5fc      	bpl.n	8005770 <__early_init+0x70>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8005776:	490f      	ldr	r1, [pc, #60]	; (80057b4 <__early_init+0xb4>)
 8005778:	680b      	ldr	r3, [r1, #0]
 800577a:	4a0e      	ldr	r2, [pc, #56]	; (80057b4 <__early_init+0xb4>)
 800577c:	019b      	lsls	r3, r3, #6
 800577e:	d5fb      	bpl.n	8005778 <__early_init+0x78>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8005780:	4b0f      	ldr	r3, [pc, #60]	; (80057c0 <__early_init+0xc0>)
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8005782:	4910      	ldr	r1, [pc, #64]	; (80057c4 <__early_init+0xc4>)
 8005784:	6091      	str	r1, [r2, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8005786:	f240 7105 	movw	r1, #1797	; 0x705
 800578a:	6019      	str	r1, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800578c:	6893      	ldr	r3, [r2, #8]
 800578e:	f043 0302 	orr.w	r3, r3, #2
 8005792:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8005794:	4611      	mov	r1, r2
 8005796:	688b      	ldr	r3, [r1, #8]
 8005798:	4a06      	ldr	r2, [pc, #24]	; (80057b4 <__early_init+0xb4>)
 800579a:	f003 030c 	and.w	r3, r3, #12
 800579e:	2b08      	cmp	r3, #8
 80057a0:	d1f9      	bne.n	8005796 <__early_init+0x96>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80057a2:	6c53      	ldr	r3, [r2, #68]	; 0x44
 80057a4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80057a8:	6453      	str	r3, [r2, #68]	; 0x44
 80057aa:	6e53      	ldr	r3, [r2, #100]	; 0x64
 80057ac:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80057b0:	6653      	str	r3, [r2, #100]	; 0x64
 80057b2:	4770      	bx	lr
 80057b4:	40023800 	.word	0x40023800
 80057b8:	40007000 	.word	0x40007000
 80057bc:	07405408 	.word	0x07405408
 80057c0:	40023c00 	.word	0x40023c00
 80057c4:	38089400 	.word	0x38089400
 80057c8:	f3af 8000 	nop.w
 80057cc:	f3af 8000 	nop.w

080057d0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80057d0:	b538      	push	{r3, r4, r5, lr}
 80057d2:	2220      	movs	r2, #32
 80057d4:	4603      	mov	r3, r0
 80057d6:	f382 8811 	msr	BASEPRI, r2
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 80057da:	4a0e      	ldr	r2, [pc, #56]	; (8005814 <chThdExit+0x44>)
 80057dc:	6994      	ldr	r4, [r2, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 80057de:	6a60      	ldr	r0, [r4, #36]	; 0x24

  tp->p_u.exitcode = msg;
 80057e0:	6223      	str	r3, [r4, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80057e2:	f104 0524 	add.w	r5, r4, #36	; 0x24
 80057e6:	42a8      	cmp	r0, r5
 80057e8:	d006      	beq.n	80057f8 <chThdExit+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 80057ea:	6803      	ldr	r3, [r0, #0]
 80057ec:	6263      	str	r3, [r4, #36]	; 0x24
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 80057ee:	f7fe fb07 	bl	8003e00 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 80057f2:	6a60      	ldr	r0, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80057f4:	42a8      	cmp	r0, r5
 80057f6:	d1f8      	bne.n	80057ea <chThdExit+0x1a>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 80057f8:	7f63      	ldrb	r3, [r4, #29]
 80057fa:	079b      	lsls	r3, r3, #30
 80057fc:	d104      	bne.n	8005808 <chThdExit+0x38>
    REG_REMOVE(tp);
 80057fe:	6963      	ldr	r3, [r4, #20]
 8005800:	6922      	ldr	r2, [r4, #16]
 8005802:	611a      	str	r2, [r3, #16]
 8005804:	6922      	ldr	r2, [r4, #16]
 8005806:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8005808:	200f      	movs	r0, #15
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 800580a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 800580e:	f7fe ba97 	b.w	8003d40 <chSchGoSleepS>
 8005812:	bf00      	nop
 8005814:	20001208 	.word	0x20001208
 8005818:	f3af 8000 	nop.w
 800581c:	f3af 8000 	nop.w

08005820 <thread1.11361>:
static mutex_t mtx1;
#endif

static THD_FUNCTION(thread1, p) {

  chThdExit((msg_t)p);
 8005820:	f7ff bfd6 	b.w	80057d0 <chThdExit>
 8005824:	f3af 8000 	nop.w
 8005828:	f3af 8000 	nop.w
 800582c:	f3af 8000 	nop.w

08005830 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8005830:	f7fe b99e 	b.w	8003b70 <chSchDoRescheduleAhead>
 8005834:	f3af 8000 	nop.w
 8005838:	f3af 8000 	nop.w
 800583c:	f3af 8000 	nop.w

08005840 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8005840:	e7fe      	b.n	8005840 <__default_exit>
 8005842:	bf00      	nop
 8005844:	f3af 8000 	nop.w
 8005848:	f3af 8000 	nop.w
 800584c:	f3af 8000 	nop.w

08005850 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8005850:	4770      	bx	lr
 8005852:	bf00      	nop
 8005854:	f3af 8000 	nop.w
 8005858:	f3af 8000 	nop.w
 800585c:	f3af 8000 	nop.w

08005860 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 8005860:	4770      	bx	lr
 8005862:	bf00      	nop
 8005864:	f3af 8000 	nop.w
 8005868:	f3af 8000 	nop.w
 800586c:	f3af 8000 	nop.w

08005870 <main>:
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8005870:	4bc2      	ldr	r3, [pc, #776]	; (8005b7c <main+0x30c>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8005872:	48c3      	ldr	r0, [pc, #780]	; (8005b80 <main+0x310>)
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8005874:	691a      	ldr	r2, [r3, #16]
 8005876:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800587a:	2200      	movs	r2, #0
}

/*
 * Application entry point.
 */
int main(void) {
 800587c:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8005880:	6119      	str	r1, [r3, #16]
 8005882:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 8005884:	695c      	ldr	r4, [r3, #20]
 8005886:	6159      	str	r1, [r3, #20]
 8005888:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800588a:	6a1c      	ldr	r4, [r3, #32]
 800588c:	f064 5480 	orn	r4, r4, #268435456	; 0x10000000
 8005890:	621c      	str	r4, [r3, #32]
 8005892:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8005894:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8005896:	6259      	str	r1, [r3, #36]	; 0x24
 8005898:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800589a:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800589c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80058a0:	6419      	str	r1, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80058a2:	6801      	ldr	r1, [r0, #0]
 80058a4:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80058a8:	6001      	str	r1, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 80058aa:	6f19      	ldr	r1, [r3, #112]	; 0x70
 80058ac:	f401 7140 	and.w	r1, r1, #768	; 0x300
 80058b0:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 80058b4:	b08d      	sub	sp, #52	; 0x34
 80058b6:	d003      	beq.n	80058c0 <main+0x50>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80058b8:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 80058bc:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 80058be:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 80058c0:	4aaf      	ldr	r2, [pc, #700]	; (8005b80 <main+0x310>)
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80058c2:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 8005b7c <main+0x30c>
 80058c6:	6856      	ldr	r6, [r2, #4]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80058c8:	49ae      	ldr	r1, [pc, #696]	; (8005b84 <main+0x314>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80058ca:	f8df 92f4 	ldr.w	r9, [pc, #756]	; 8005bc0 <main+0x350>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80058ce:	f8df e2f4 	ldr.w	lr, [pc, #756]	; 8005bc4 <main+0x354>
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 80058d2:	f8df a2f4 	ldr.w	sl, [pc, #756]	; 8005bc8 <main+0x358>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80058d6:	f8df c2f4 	ldr.w	ip, [pc, #756]	; 8005bcc <main+0x35c>
 80058da:	4fab      	ldr	r7, [pc, #684]	; (8005b88 <main+0x318>)
 80058dc:	4bab      	ldr	r3, [pc, #684]	; (8005b8c <main+0x31c>)
 80058de:	4dac      	ldr	r5, [pc, #688]	; (8005b90 <main+0x320>)
 80058e0:	4cac      	ldr	r4, [pc, #688]	; (8005b94 <main+0x324>)
 80058e2:	48ad      	ldr	r0, [pc, #692]	; (8005b98 <main+0x328>)
 80058e4:	f8df b2e8 	ldr.w	fp, [pc, #744]	; 8005bd0 <main+0x360>
 80058e8:	f426 7600 	bic.w	r6, r6, #512	; 0x200
 80058ec:	6056      	str	r6, [r2, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80058ee:	f8d8 2030 	ldr.w	r2, [r8, #48]	; 0x30
 80058f2:	ea6f 2252 	mvn.w	r2, r2, lsr #9
 80058f6:	ea6f 2242 	mvn.w	r2, r2, lsl #9
 80058fa:	f8c8 2030 	str.w	r2, [r8, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 80058fe:	f8d8 2050 	ldr.w	r2, [r8, #80]	; 0x50
 8005902:	ea6f 2252 	mvn.w	r2, r2, lsr #9
 8005906:	ea6f 2242 	mvn.w	r2, r2, lsl #9
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800590a:	2600      	movs	r6, #0
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 800590c:	f8c8 2050 	str.w	r2, [r8, #80]	; 0x50
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8005910:	f46f 42a8 	mvn.w	r2, #21504	; 0x5400
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005914:	604e      	str	r6, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005916:	608a      	str	r2, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8005918:	f8c1 900c 	str.w	r9, [r1, #12]
  gpiop->ODR     = config->odr;
 800591c:	f64f 72ff 	movw	r2, #65535	; 0xffff
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8005920:	f8df 92b0 	ldr.w	r9, [pc, #688]	; 8005bd4 <main+0x364>
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8005924:	614a      	str	r2, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8005926:	f8c1 a020 	str.w	sl, [r1, #32]
  gpiop->AFRH    = config->afrh;
 800592a:	f8c1 9024 	str.w	r9, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800592e:	f8df a2a8 	ldr.w	sl, [pc, #680]	; 8005bd8 <main+0x368>
 8005932:	f8c1 a000 	str.w	sl, [r1]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005936:	f44f 7910 	mov.w	r9, #576	; 0x240
 800593a:	f8ce 9004 	str.w	r9, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800593e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  gpiop->PUPDR   = config->pupdr;
 8005942:	f8df a298 	ldr.w	sl, [pc, #664]	; 8005bdc <main+0x36c>
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8005946:	f8ce 1008 	str.w	r1, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 800594a:	f04f 6980 	mov.w	r9, #67108864	; 0x4000000

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 800594e:	f8ce a00c 	str.w	sl, [lr, #12]
  gpiop->ODR     = config->odr;
 8005952:	f8ce 2014 	str.w	r2, [lr, #20]
  gpiop->AFRL    = config->afrl;
 8005956:	f8ce 9020 	str.w	r9, [lr, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 800595a:	f8df 9284 	ldr.w	r9, [pc, #644]	; 8005be0 <main+0x370>
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 800595e:	f04f 0a40 	mov.w	sl, #64	; 0x40
 8005962:	f8ce a024 	str.w	sl, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005966:	f8ce 9000 	str.w	r9, [lr]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 800596a:	f109 49aa 	add.w	r9, r9, #1426063360	; 0x55000000
 800596e:	f5a9 0943 	sub.w	r9, r9, #12779520	; 0xc30000
 8005972:	f6a9 392c 	subw	r9, r9, #2860	; 0xb2c
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005976:	f8cc 6004 	str.w	r6, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800597a:	f8cc 1008 	str.w	r1, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
 800597e:	f8cc 900c 	str.w	r9, [ip, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8005982:	f04f 49c0 	mov.w	r9, #1610612736	; 0x60000000
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8005986:	f8cc 2014 	str.w	r2, [ip, #20]
  gpiop->AFRL    = config->afrl;
 800598a:	f8cc 9020 	str.w	r9, [ip, #32]
  gpiop->AFRH    = config->afrh;
 800598e:	f8df 9254 	ldr.w	r9, [pc, #596]	; 8005be4 <main+0x374>
 8005992:	f8cc 9024 	str.w	r9, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005996:	f8df 9250 	ldr.w	r9, [pc, #592]	; 8005be8 <main+0x378>
 800599a:	f8cc 9000 	str.w	r9, [ip]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 800599e:	f8df c24c 	ldr.w	ip, [pc, #588]	; 8005bec <main+0x37c>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80059a2:	607e      	str	r6, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80059a4:	60b9      	str	r1, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 80059a6:	f8c7 c00c 	str.w	ip, [r7, #12]
  gpiop->ODR     = config->odr;
 80059aa:	f640 7cff 	movw	ip, #4095	; 0xfff
 80059ae:	f8c7 c014 	str.w	ip, [r7, #20]
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80059b2:	f8df c23c 	ldr.w	ip, [pc, #572]	; 8005bf0 <main+0x380>

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 80059b6:	623e      	str	r6, [r7, #32]
  gpiop->AFRH    = config->afrh;
 80059b8:	627e      	str	r6, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80059ba:	f8c7 c000 	str.w	ip, [r7]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80059be:	605e      	str	r6, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80059c0:	6099      	str	r1, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80059c2:	60de      	str	r6, [r3, #12]
  gpiop->ODR     = config->odr;
 80059c4:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80059c6:	621e      	str	r6, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80059c8:	625e      	str	r6, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80059ca:	f8c3 a000 	str.w	sl, [r3]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80059ce:	606e      	str	r6, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80059d0:	60a9      	str	r1, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 80059d2:	60ee      	str	r6, [r5, #12]
  gpiop->ODR     = config->odr;
 80059d4:	616a      	str	r2, [r5, #20]
  gpiop->AFRL    = config->afrl;
 80059d6:	622e      	str	r6, [r5, #32]
  gpiop->AFRH    = config->afrh;
 80059d8:	626e      	str	r6, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80059da:	602e      	str	r6, [r5, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80059dc:	6066      	str	r6, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80059de:	60a1      	str	r1, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 80059e0:	60e6      	str	r6, [r4, #12]
  gpiop->ODR     = config->odr;
 80059e2:	6162      	str	r2, [r4, #20]
  gpiop->AFRL    = config->afrl;
 80059e4:	6226      	str	r6, [r4, #32]
  gpiop->AFRH    = config->afrh;
 80059e6:	6266      	str	r6, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80059e8:	6026      	str	r6, [r4, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80059ea:	6046      	str	r6, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80059ec:	6081      	str	r1, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 80059ee:	60c6      	str	r6, [r0, #12]
  gpiop->ODR     = config->odr;
 80059f0:	6142      	str	r2, [r0, #20]
  gpiop->AFRL    = config->afrl;
 80059f2:	6206      	str	r6, [r0, #32]
  gpiop->AFRH    = config->afrh;
 80059f4:	6246      	str	r6, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80059f6:	6006      	str	r6, [r0, #0]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80059f8:	4868      	ldr	r0, [pc, #416]	; (8005b9c <main+0x32c>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80059fa:	f8cb 6004 	str.w	r6, [fp, #4]
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 80059fe:	f8df e19c 	ldr.w	lr, [pc, #412]	; 8005b9c <main+0x32c>
  gpiop->OSPEEDR = config->ospeedr;
 8005a02:	f8cb 1008 	str.w	r1, [fp, #8]
  gpiop->PUPDR   = config->pupdr;
 8005a06:	f8cb 600c 	str.w	r6, [fp, #12]
  gpiop->ODR     = config->odr;
 8005a0a:	f8cb 2014 	str.w	r2, [fp, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8005a0e:	4602      	mov	r2, r0
  gpiop->AFRL    = config->afrl;
 8005a10:	f8cb 6020 	str.w	r6, [fp, #32]
 8005a14:	4f62      	ldr	r7, [pc, #392]	; (8005ba0 <main+0x330>)
  gpiop->AFRH    = config->afrh;
 8005a16:	f8cb 6024 	str.w	r6, [fp, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005a1a:	f8cb 6000 	str.w	r6, [fp]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8005a1e:	4683      	mov	fp, r0
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 8005a20:	4b60      	ldr	r3, [pc, #384]	; (8005ba4 <main+0x334>)
 8005a22:	f84e 7b04 	str.w	r7, [lr], #4
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8005a26:	62d0      	str	r0, [r2, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8005a28:	6510      	str	r0, [r2, #80]	; 0x50
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8005a2a:	4d5f      	ldr	r5, [pc, #380]	; (8005ba8 <main+0x338>)
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8005a2c:	6146      	str	r6, [r0, #20]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8005a2e:	f100 0274 	add.w	r2, r0, #116	; 0x74
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8005a32:	6286      	str	r6, [r0, #40]	; 0x28
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8005a34:	f100 0454 	add.w	r4, r0, #84	; 0x54
 8005a38:	f100 0c0c 	add.w	ip, r0, #12
 8005a3c:	f100 0730 	add.w	r7, r0, #48	; 0x30
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8005a40:	f8cb 2040 	str.w	r2, [fp, #64]	; 0x40
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8005a44:	3064      	adds	r0, #100	; 0x64
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8005a46:	2201      	movs	r2, #1
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8005a48:	f8cb 504c 	str.w	r5, [fp, #76]	; 0x4c
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
 8005a4c:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 8005bf4 <main+0x384>
 8005a50:	f88b 2008 	strb.w	r2, [fp, #8]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8005a54:	2510      	movs	r5, #16
 8005a56:	701a      	strb	r2, [r3, #0]
  usbp->config       = NULL;
 8005a58:	605e      	str	r6, [r3, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8005a5a:	61de      	str	r6, [r3, #28]
    usbp->out_params[i] = NULL;
 8005a5c:	629e      	str	r6, [r3, #40]	; 0x28
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8005a5e:	621e      	str	r6, [r3, #32]
    usbp->out_params[i] = NULL;
 8005a60:	62de      	str	r6, [r3, #44]	; 0x2c
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8005a62:	625e      	str	r6, [r3, #36]	; 0x24
    usbp->out_params[i] = NULL;
 8005a64:	631e      	str	r6, [r3, #48]	; 0x30
  }
  usbp->transmitting = 0;
 8005a66:	811e      	strh	r6, [r3, #8]
  usbp->receiving    = 0;
 8005a68:	815e      	strh	r6, [r3, #10]
 8005a6a:	f8cb 9074 	str.w	r9, [fp, #116]	; 0x74
 8005a6e:	f8cb e004 	str.w	lr, [fp, #4]
 8005a72:	f8cb c00c 	str.w	ip, [fp, #12]
  tqp->p_prev = (thread_t *)tqp;
 8005a76:	f8cb c010 	str.w	ip, [fp, #16]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8005a7a:	f8cb 4018 	str.w	r4, [fp, #24]
  iqp->q_rdptr   = bp;
 8005a7e:	f8cb 4024 	str.w	r4, [fp, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8005a82:	f8cb 4020 	str.w	r4, [fp, #32]
  iqp->q_top     = bp + size;
 8005a86:	f8cb 001c 	str.w	r0, [fp, #28]
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8005a8a:	f8cb 003c 	str.w	r0, [fp, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8005a8e:	f8cb 0048 	str.w	r0, [fp, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8005a92:	f8cb 0044 	str.w	r0, [fp, #68]	; 0x44
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8005a96:	f8cb 7030 	str.w	r7, [fp, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
 8005a9a:	f8cb 7034 	str.w	r7, [fp, #52]	; 0x34
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8005a9e:	f8cb 5038 	str.w	r5, [fp, #56]	; 0x38
void usb_lld_init(void) {

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
 8005aa2:	661e      	str	r6, [r3, #96]	; 0x60

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8005aa4:	f8d8 e040 	ldr.w	lr, [r8, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8005aa8:	4c40      	ldr	r4, [pc, #256]	; (8005bac <main+0x33c>)
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 8005aaa:	665e      	str	r6, [r3, #100]	; 0x64

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8005aac:	ea4e 0e02 	orr.w	lr, lr, r2
 8005ab0:	f8c8 e040 	str.w	lr, [r8, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8005ab4:	f8d4 c008 	ldr.w	ip, [r4, #8]
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8005ab8:	483d      	ldr	r0, [pc, #244]	; (8005bb0 <main+0x340>)
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8005aba:	f8df 913c 	ldr.w	r9, [pc, #316]	; 8005bf8 <main+0x388>
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 8005abe:	4f3d      	ldr	r7, [pc, #244]	; (8005bb4 <main+0x344>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8005ac0:	f8df e138 	ldr.w	lr, [pc, #312]	; 8005bfc <main+0x38c>
 8005ac4:	ea4c 0c02 	orr.w	ip, ip, r2
 8005ac8:	f8c4 c008 	str.w	ip, [r4, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8005acc:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 8005ad0:	f242 0ccf 	movw	ip, #8399	; 0x20cf
 8005ad4:	f8c4 c028 	str.w	ip, [r4, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8005ad8:	62e1      	str	r1, [r4, #44]	; 0x2c
 8005ada:	f04f 0c80 	mov.w	ip, #128	; 0x80
  STM32_ST_TIM->CCMR1  = 0;
 8005ade:	61a6      	str	r6, [r4, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8005ae0:	6366      	str	r6, [r4, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8005ae2:	60e6      	str	r6, [r4, #12]
  STM32_ST_TIM->CR2    = 0;
 8005ae4:	6066      	str	r6, [r4, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8005ae6:	6162      	str	r2, [r4, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8005ae8:	6022      	str	r2, [r4, #0]
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8005aea:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8005aee:	f889 c31c 	strb.w	ip, [r9, #796]	; 0x31c
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8005af2:	f8c9 4180 	str.w	r4, [r9, #384]	; 0x180
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 8005af6:	f8c9 4000 	str.w	r4, [r9]
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8005afa:	6086      	str	r6, [r0, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8005afc:	f8d0 c00c 	ldr.w	ip, [r0, #12]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 8005b00:	f64f 04ff 	movw	r4, #63743	; 0xf8ff
 8005b04:	ea0c 0404 	and.w	r4, ip, r4
  reg_value  =  (reg_value                                 |
 8005b08:	4327      	orrs	r7, r4
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8005b0a:	60c7      	str	r7, [r0, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8005b0c:	f8de c00c 	ldr.w	ip, [lr, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8005b10:	4c29      	ldr	r4, [pc, #164]	; (8005bb8 <main+0x348>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8005b12:	4f2a      	ldr	r7, [pc, #168]	; (8005bbc <main+0x34c>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8005b14:	f04c 7c80 	orr.w	ip, ip, #16777216	; 0x1000000
 8005b18:	f8ce c00c 	str.w	ip, [lr, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8005b1c:	f8d4 e000 	ldr.w	lr, [r4]
  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;
 8005b20:	f8df c0dc 	ldr.w	ip, [pc, #220]	; 8005c00 <main+0x390>
 8005b24:	f8c3 c054 	str.w	ip, [r3, #84]	; 0x54
 8005b28:	ea4e 0e02 	orr.w	lr, lr, r2
 8005b2c:	f8c4 e000 	str.w	lr, [r4]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8005b30:	f04f 0b20 	mov.w	fp, #32

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
 8005b34:	f04f 44a0 	mov.w	r4, #1342177280	; 0x50000000
 8005b38:	77c5      	strb	r5, [r0, #31]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8005b3a:	f107 0e1c 	add.w	lr, r7, #28
 8005b3e:	f880 b022 	strb.w	fp, [r0, #34]	; 0x22

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8005b42:	2500      	movs	r5, #0
 8005b44:	651c      	str	r4, [r3, #80]	; 0x50
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8005b46:	a806      	add	r0, sp, #24

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8005b48:	2400      	movs	r4, #0
 8005b4a:	f8c7 e01c 	str.w	lr, [r7, #28]
 8005b4e:	603f      	str	r7, [r7, #0]
  tqp->p_prev = (thread_t *)tqp;
 8005b50:	607f      	str	r7, [r7, #4]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8005b52:	60be      	str	r6, [r7, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 8005b54:	613f      	str	r7, [r7, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8005b56:	617f      	str	r7, [r7, #20]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8005b58:	f8c7 e020 	str.w	lr, [r7, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 8005b5c:	6279      	str	r1, [r7, #36]	; 0x24
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8005b5e:	9106      	str	r1, [sp, #24]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8005b60:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8005b64:	62be      	str	r6, [r7, #40]	; 0x28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8005b66:	677e      	str	r6, [r7, #116]	; 0x74
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8005b68:	9607      	str	r6, [sp, #28]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8005b6a:	9203      	str	r2, [sp, #12]
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
 8005b6c:	9608      	str	r6, [sp, #32]
  tmp->n          = (ucnt_t)0;
 8005b6e:	9609      	str	r6, [sp, #36]	; 0x24
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8005b70:	f7fa fe1e 	bl	80007b0 <chTMStartMeasurementX.constprop.58>
  chTMStopMeasurementX(&tm);
 8005b74:	a806      	add	r0, sp, #24
 8005b76:	f7fd ffa3 	bl	8003ac0 <chTMStopMeasurementX>
 8005b7a:	e043      	b.n	8005c04 <main+0x394>
 8005b7c:	40023800 	.word	0x40023800
 8005b80:	40007000 	.word	0x40007000
 8005b84:	40020000 	.word	0x40020000
 8005b88:	40020c00 	.word	0x40020c00
 8005b8c:	40021000 	.word	0x40021000
 8005b90:	40021400 	.word	0x40021400
 8005b94:	40021800 	.word	0x40021800
 8005b98:	40021c00 	.word	0x40021c00
 8005b9c:	20001178 	.word	0x20001178
 8005ba0:	08006be0 	.word	0x08006be0
 8005ba4:	20000fc8 	.word	0x20000fc8
 8005ba8:	08003661 	.word	0x08003661
 8005bac:	e0042000 	.word	0xe0042000
 8005bb0:	e000ed00 	.word	0xe000ed00
 8005bb4:	05fa0300 	.word	0x05fa0300
 8005bb8:	e0001000 	.word	0xe0001000
 8005bbc:	20001208 	.word	0x20001208
 8005bc0:	40010054 	.word	0x40010054
 8005bc4:	40020400 	.word	0x40020400
 8005bc8:	55560000 	.word	0x55560000
 8005bcc:	40020800 	.word	0x40020800
 8005bd0:	40022000 	.word	0x40022000
 8005bd4:	000aaa00 	.word	0x000aaa00
 8005bd8:	2aa0aa00 	.word	0x2aa0aa00
 8005bdc:	55514515 	.word	0x55514515
 8005be0:	00082080 	.word	0x00082080
 8005be4:	00060600 	.word	0x00060600
 8005be8:	02208001 	.word	0x02208001
 8005bec:	00555055 	.word	0x00555055
 8005bf0:	55000100 	.word	0x55000100
 8005bf4:	40004400 	.word	0x40004400
 8005bf8:	e000e100 	.word	0xe000e100
 8005bfc:	e000edf0 	.word	0xe000edf0
 8005c00:	08006c40 	.word	0x08006c40
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8005c04:	4946      	ldr	r1, [pc, #280]	; (8005d20 <main+0x4b0>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8005c06:	4b47      	ldr	r3, [pc, #284]	; (8005d24 <main+0x4b4>)
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8005c08:	f8d7 c014 	ldr.w	ip, [r7, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8005c0c:	f887 604d 	strb.w	r6, [r7, #77]	; 0x4d
 8005c10:	f023 0e07 	bic.w	lr, r3, #7
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8005c14:	f101 0310 	add.w	r3, r1, #16
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8005c18:	9a03      	ldr	r2, [sp, #12]
  ch.tm.offset = tm.last;
 8005c1a:	9808      	ldr	r0, [sp, #32]
 8005c1c:	610b      	str	r3, [r1, #16]
  tqp->p_prev = (thread_t *)tqp;
 8005c1e:	614b      	str	r3, [r1, #20]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8005c20:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8005c24:	6778      	str	r0, [r7, #116]	; 0x74
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8005c26:	f8c7 a038 	str.w	sl, [r7, #56]	; 0x38
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8005c2a:	f8c7 a06c 	str.w	sl, [r7, #108]	; 0x6c
  tp->p_mtxlist = NULL;
 8005c2e:	66be      	str	r6, [r7, #104]	; 0x68
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8005c30:	667e      	str	r6, [r7, #100]	; 0x64
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8005c32:	f887 204e 	strb.w	r2, [r7, #78]	; 0x4e
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8005c36:	64be      	str	r6, [r7, #72]	; 0x48
  REG_INSERT(tp);
 8005c38:	643f      	str	r7, [r7, #64]	; 0x40
 8005c3a:	f8c7 c044 	str.w	ip, [r7, #68]	; 0x44
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8005c3e:	618e      	str	r6, [r1, #24]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8005c40:	4c39      	ldr	r4, [pc, #228]	; (8005d28 <main+0x4b8>)
 8005c42:	f8cc 3010 	str.w	r3, [ip, #16]
 8005c46:	617b      	str	r3, [r7, #20]
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8005c48:	61bb      	str	r3, [r7, #24]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8005c4a:	f107 0354 	add.w	r3, r7, #84	; 0x54
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8005c4e:	4d37      	ldr	r5, [pc, #220]	; (8005d2c <main+0x4bc>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8005c50:	4837      	ldr	r0, [pc, #220]	; (8005d30 <main+0x4c0>)
 8005c52:	657b      	str	r3, [r7, #84]	; 0x54
 8005c54:	4b37      	ldr	r3, [pc, #220]	; (8005d34 <main+0x4c4>)
 8005c56:	600b      	str	r3, [r1, #0]
 8005c58:	f024 0407 	bic.w	r4, r4, #7
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8005c5c:	f107 0358 	add.w	r3, r7, #88	; 0x58
  default_heap.h_free.h.u.next = NULL;
 8005c60:	608e      	str	r6, [r1, #8]
  default_heap.h_free.h.size = 0;
 8005c62:	60ce      	str	r6, [r1, #12]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8005c64:	f887 204c 	strb.w	r2, [r7, #76]	; 0x4c
 8005c68:	65bb      	str	r3, [r7, #88]	; 0x58
  tqp->p_prev = (thread_t *)tqp;
 8005c6a:	65fb      	str	r3, [r7, #92]	; 0x5c
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8005c6c:	f8c5 e000 	str.w	lr, [r5]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8005c70:	6004      	str	r4, [r0, #0]
 8005c72:	f386 8811 	msr	BASEPRI, r6
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005c76:	b662      	cpsie	i
 8005c78:	69bb      	ldr	r3, [r7, #24]
 8005c7a:	492f      	ldr	r1, [pc, #188]	; (8005d38 <main+0x4c8>)
 8005c7c:	6199      	str	r1, [r3, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8005c7e:	f107 0078 	add.w	r0, r7, #120	; 0x78
 8005c82:	9600      	str	r6, [sp, #0]
 8005c84:	21d8      	movs	r1, #216	; 0xd8
 8005c86:	4b2d      	ldr	r3, [pc, #180]	; (8005d3c <main+0x4cc>)
 8005c88:	f7fe f81a 	bl	8003cc0 <chThdCreateStatic>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8005c8c:	4b2c      	ldr	r3, [pc, #176]	; (8005d40 <main+0x4d0>)
 8005c8e:	6183      	str	r3, [r0, #24]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8005c90:	f38b 8811 	msr	BASEPRI, fp
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8005c94:	4a2b      	ldr	r2, [pc, #172]	; (8005d44 <main+0x4d4>)
 8005c96:	7a13      	ldrb	r3, [r2, #8]
 8005c98:	2b01      	cmp	r3, #1
 8005c9a:	d10c      	bne.n	8005cb6 <main+0x446>
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
      rccEnableUSART2(FALSE);
 8005c9c:	f8d8 2040 	ldr.w	r2, [r8, #64]	; 0x40
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 8005ca0:	23c0      	movs	r3, #192	; 0xc0
 8005ca2:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8005ca6:	f8c8 2040 	str.w	r2, [r8, #64]	; 0x40
 8005caa:	f889 3326 	strb.w	r3, [r9, #806]	; 0x326
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8005cae:	f8c9 a184 	str.w	sl, [r9, #388]	; 0x184
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 8005cb2:	f8c9 a004 	str.w	sl, [r9, #4]
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8005cb6:	4c23      	ldr	r4, [pc, #140]	; (8005d44 <main+0x4d4>)

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8005cb8:	4a23      	ldr	r2, [pc, #140]	; (8005d48 <main+0x4d8>)
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8005cba:	6f63      	ldr	r3, [r4, #116]	; 0x74

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8005cbc:	4293      	cmp	r3, r2
 8005cbe:	f000 818f 	beq.w	8005fe0 <main+0x770>
 8005cc2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8005cc6:	4293      	cmp	r3, r2
 8005cc8:	f000 818a 	beq.w	8005fe0 <main+0x770>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;
 8005ccc:	f240 4245 	movw	r2, #1093	; 0x445
 8005cd0:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8005cd2:	f244 0240 	movw	r2, #16448	; 0x4040
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8005cd6:	2001      	movs	r0, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8005cd8:	f242 112c 	movw	r1, #8492	; 0x212c
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8005cdc:	2400      	movs	r4, #0

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8005cde:	4f19      	ldr	r7, [pc, #100]	; (8005d44 <main+0x4d4>)
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8005ce0:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8005ce2:	6158      	str	r0, [r3, #20]
 8005ce4:	2202      	movs	r2, #2
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8005ce6:	60d9      	str	r1, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8005ce8:	601c      	str	r4, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8005cea:	6819      	ldr	r1, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8005cec:	685b      	ldr	r3, [r3, #4]
 8005cee:	723a      	strb	r2, [r7, #8]
 8005cf0:	f384 8811 	msr	BASEPRI, r4
  /*
   * Activates the serial driver 2 using the driver default configuration.
   * PA2(TX) and PA3(RX) are routed to USART2.
   */
  sdStart(&SD2, NULL);
  palSetPadMode(GPIOA, 2, PAL_MODE_ALTERNATE(7));
 8005cf4:	2004      	movs	r0, #4
 8005cf6:	f7fa fec3 	bl	8000a80 <_pal_lld_setgroupmode.constprop.6>
  palSetPadMode(GPIOA, 3, PAL_MODE_ALTERNATE(7));
 8005cfa:	2008      	movs	r0, #8
 8005cfc:	f7fa fec0 	bl	8000a80 <_pal_lld_setgroupmode.constprop.6>

  /*
   * Creates the example thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8005d00:	9400      	str	r4, [sp, #0]
 8005d02:	4c12      	ldr	r4, [pc, #72]	; (8005d4c <main+0x4dc>)
 8005d04:	4812      	ldr	r0, [pc, #72]	; (8005d50 <main+0x4e0>)
 8005d06:	4b13      	ldr	r3, [pc, #76]	; (8005d54 <main+0x4e4>)
 8005d08:	4e13      	ldr	r6, [pc, #76]	; (8005d58 <main+0x4e8>)
 8005d0a:	f8df a054 	ldr.w	sl, [pc, #84]	; 8005d60 <main+0x4f0>
 8005d0e:	4f13      	ldr	r7, [pc, #76]	; (8005d5c <main+0x4ec>)
 8005d10:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8005d14:	2240      	movs	r2, #64	; 0x40
 8005d16:	f7fd ffd3 	bl	8003cc0 <chThdCreateStatic>
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005d1a:	46a3      	mov	fp, r4
 8005d1c:	e026      	b.n	8005d6c <main+0x4fc>
 8005d1e:	bf00      	nop
 8005d20:	20000fa0 	.word	0x20000fa0
 8005d24:	20001553 	.word	0x20001553
 8005d28:	20020000 	.word	0x20020000
 8005d2c:	20000f94 	.word	0x20000f94
 8005d30:	200011f0 	.word	0x200011f0
 8005d34:	08003691 	.word	0x08003691
 8005d38:	080069b0 	.word	0x080069b0
 8005d3c:	08003741 	.word	0x08003741
 8005d40:	08006c90 	.word	0x08006c90
 8005d44:	20001178 	.word	0x20001178
 8005d48:	40011000 	.word	0x40011000
 8005d4c:	200014b8 	.word	0x200014b8
 8005d50:	20001370 	.word	0x20001370
 8005d54:	08004b31 	.word	0x08004b31
 8005d58:	20000fc4 	.word	0x20000fc4
 8005d5c:	20001358 	.word	0x20001358
 8005d60:	20000f90 	.word	0x20000f90
   * sleeping in a loop and check the button state.
   */
  while (true) {
    if (palReadPad(GPIOA, GPIOA_BUTTON))
      TestThread(&SD2);
    chThdSleepMilliseconds(500);
 8005d64:	f241 3088 	movw	r0, #5000	; 0x1388
 8005d68:	f7fe fed2 	bl	8004b10 <chThdSleep>
  /*
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state.
   */
  while (true) {
    if (palReadPad(GPIOA, GPIOA_BUTTON))
 8005d6c:	4b9e      	ldr	r3, [pc, #632]	; (8005fe8 <main+0x778>)
 8005d6e:	691b      	ldr	r3, [r3, #16]
 8005d70:	07db      	lsls	r3, r3, #31
 8005d72:	d5f7      	bpl.n	8005d64 <main+0x4f4>
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
  int i, j;

  chp = p;
 8005d74:	4a9d      	ldr	r2, [pc, #628]	; (8005fec <main+0x77c>)
  test_println("");
 8005d76:	489e      	ldr	r0, [pc, #632]	; (8005ff0 <main+0x780>)
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
  int i, j;

  chp = p;
 8005d78:	6022      	str	r2, [r4, #0]
  test_println("");
 8005d7a:	f7fd fcf9 	bl	8003770 <test_println>
  test_println("*** ChibiOS/RT test suite");
 8005d7e:	489d      	ldr	r0, [pc, #628]	; (8005ff4 <main+0x784>)
 8005d80:	4d9d      	ldr	r5, [pc, #628]	; (8005ff8 <main+0x788>)
 8005d82:	f7fd fcf5 	bl	8003770 <test_println>
  test_println("***");
 8005d86:	489d      	ldr	r0, [pc, #628]	; (8005ffc <main+0x78c>)
 8005d88:	f7fd fcf2 	bl	8003770 <test_println>
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005d8c:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 8005d8e:	6820      	ldr	r0, [r4, #0]
 8005d90:	6803      	ldr	r3, [r0, #0]
 8005d92:	689b      	ldr	r3, [r3, #8]
 8005d94:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005d96:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005d9a:	2900      	cmp	r1, #0
 8005d9c:	d1f7      	bne.n	8005d8e <main+0x51e>
  chp = p;
  test_println("");
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
 8005d9e:	4898      	ldr	r0, [pc, #608]	; (8006000 <main+0x790>)
 8005da0:	4d98      	ldr	r5, [pc, #608]	; (8006004 <main+0x794>)
 8005da2:	f7fd fce5 	bl	8003770 <test_println>
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005da6:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 8005da8:	6820      	ldr	r0, [r4, #0]
 8005daa:	6803      	ldr	r3, [r0, #0]
 8005dac:	689b      	ldr	r3, [r3, #8]
 8005dae:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005db0:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005db4:	2900      	cmp	r1, #0
 8005db6:	d1f7      	bne.n	8005da8 <main+0x538>
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 8005db8:	4893      	ldr	r0, [pc, #588]	; (8006008 <main+0x798>)
 8005dba:	4d94      	ldr	r5, [pc, #592]	; (800600c <main+0x79c>)
 8005dbc:	f7fd fcd8 	bl	8003770 <test_println>
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005dc0:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 8005dc2:	6820      	ldr	r0, [r4, #0]
 8005dc4:	6803      	ldr	r3, [r0, #0]
 8005dc6:	689b      	ldr	r3, [r3, #8]
 8005dc8:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005dca:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005dce:	2900      	cmp	r1, #0
 8005dd0:	d1f7      	bne.n	8005dc2 <main+0x552>
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
 8005dd2:	488f      	ldr	r0, [pc, #572]	; (8006010 <main+0x7a0>)
 8005dd4:	4d8f      	ldr	r5, [pc, #572]	; (8006014 <main+0x7a4>)
 8005dd6:	f7fd fccb 	bl	8003770 <test_println>
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005dda:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 8005ddc:	6820      	ldr	r0, [r4, #0]
 8005dde:	6803      	ldr	r3, [r0, #0]
 8005de0:	689b      	ldr	r3, [r3, #8]
 8005de2:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005de4:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005de8:	2900      	cmp	r1, #0
 8005dea:	d1f7      	bne.n	8005ddc <main+0x56c>
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
 8005dec:	488a      	ldr	r0, [pc, #552]	; (8006018 <main+0x7a8>)
 8005dee:	4d8b      	ldr	r5, [pc, #556]	; (800601c <main+0x7ac>)
 8005df0:	f7fd fcbe 	bl	8003770 <test_println>
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005df4:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 8005df6:	6820      	ldr	r0, [r4, #0]
 8005df8:	6803      	ldr	r3, [r0, #0]
 8005dfa:	689b      	ldr	r3, [r3, #8]
 8005dfc:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005dfe:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005e02:	2900      	cmp	r1, #0
 8005e04:	d1f7      	bne.n	8005df6 <main+0x586>
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
 8005e06:	4886      	ldr	r0, [pc, #536]	; (8006020 <main+0x7b0>)
 8005e08:	4d86      	ldr	r5, [pc, #536]	; (8006024 <main+0x7b4>)
 8005e0a:	f7fd fcb1 	bl	8003770 <test_println>
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005e0e:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 8005e10:	6820      	ldr	r0, [r4, #0]
 8005e12:	6803      	ldr	r3, [r0, #0]
 8005e14:	689b      	ldr	r3, [r3, #8]
 8005e16:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005e18:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005e1c:	2900      	cmp	r1, #0
 8005e1e:	d1f7      	bne.n	8005e10 <main+0x5a0>
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
 8005e20:	4881      	ldr	r0, [pc, #516]	; (8006028 <main+0x7b8>)
 8005e22:	4d82      	ldr	r5, [pc, #520]	; (800602c <main+0x7bc>)
 8005e24:	f7fd fca4 	bl	8003770 <test_println>
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005e28:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 8005e2a:	6820      	ldr	r0, [r4, #0]
 8005e2c:	6803      	ldr	r3, [r0, #0]
 8005e2e:	689b      	ldr	r3, [r3, #8]
 8005e30:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005e32:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005e36:	2900      	cmp	r1, #0
 8005e38:	d1f7      	bne.n	8005e2a <main+0x5ba>
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 8005e3a:	487d      	ldr	r0, [pc, #500]	; (8006030 <main+0x7c0>)
 8005e3c:	4d7d      	ldr	r5, [pc, #500]	; (8006034 <main+0x7c4>)
 8005e3e:	f7fd fc97 	bl	8003770 <test_println>
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005e42:	212a      	movs	r1, #42	; 0x2a
    chSequentialStreamPut(chp, *msgp++);
 8005e44:	6820      	ldr	r0, [r4, #0]
 8005e46:	6803      	ldr	r3, [r0, #0]
 8005e48:	689b      	ldr	r3, [r3, #8]
 8005e4a:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005e4c:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005e50:	2900      	cmp	r1, #0
 8005e52:	d1f7      	bne.n	8005e44 <main+0x5d4>
 8005e54:	4a78      	ldr	r2, [pc, #480]	; (8006038 <main+0x7c8>)
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 8005e56:	4879      	ldr	r0, [pc, #484]	; (800603c <main+0x7cc>)
 8005e58:	9103      	str	r1, [sp, #12]
 8005e5a:	9205      	str	r2, [sp, #20]
 8005e5c:	f7fd fc88 	bl	8003770 <test_println>
#endif
  test_println("");
 8005e60:	4863      	ldr	r0, [pc, #396]	; (8005ff0 <main+0x780>)
 8005e62:	f7fd fc85 	bl	8003770 <test_println>

  test_global_fail = FALSE;
 8005e66:	4b76      	ldr	r3, [pc, #472]	; (8006040 <main+0x7d0>)
  i = 0;
 8005e68:	9903      	ldr	r1, [sp, #12]
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
#endif
  test_println("");

  test_global_fail = FALSE;
 8005e6a:	7019      	strb	r1, [r3, #0]
 8005e6c:	4b75      	ldr	r3, [pc, #468]	; (8006044 <main+0x7d4>)
  i = 0;
 8005e6e:	9104      	str	r1, [sp, #16]
 8005e70:	f8dd 9010 	ldr.w	r9, [sp, #16]
 8005e74:	f109 0901 	add.w	r9, r9, #1
 8005e78:	f8cd 9010 	str.w	r9, [sp, #16]
 8005e7c:	4698      	mov	r8, r3
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8005e7e:	f04f 0900 	mov.w	r9, #0

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 8005e82:	f858 3b04 	ldr.w	r3, [r8], #4
 8005e86:	2b00      	cmp	r3, #0
 8005e88:	f000 8083 	beq.w	8005f92 <main+0x722>
 8005e8c:	4d6e      	ldr	r5, [pc, #440]	; (8006048 <main+0x7d8>)
      print_line();
 8005e8e:	f7fd fccf 	bl	8003830 <print_line.9144>
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005e92:	212d      	movs	r1, #45	; 0x2d
    chSequentialStreamPut(chp, *msgp++);
 8005e94:	6820      	ldr	r0, [r4, #0]
 8005e96:	6803      	ldr	r3, [r0, #0]
 8005e98:	689b      	ldr	r3, [r3, #8]
 8005e9a:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005e9c:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005ea0:	2900      	cmp	r1, #0
 8005ea2:	d1f7      	bne.n	8005e94 <main+0x624>
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 8005ea4:	9804      	ldr	r0, [sp, #16]
 8005ea6:	4d69      	ldr	r5, [pc, #420]	; (800604c <main+0x7dc>)
 8005ea8:	f7fd fc8a 	bl	80037c0 <test_printn>
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005eac:	f8db 0000 	ldr.w	r0, [fp]
 8005eb0:	6803      	ldr	r3, [r0, #0]
 8005eb2:	212e      	movs	r1, #46	; 0x2e
 8005eb4:	689b      	ldr	r3, [r3, #8]
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8005eb6:	f109 0901 	add.w	r9, r9, #1
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005eba:	4798      	blx	r3
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8005ebc:	4648      	mov	r0, r9
 8005ebe:	f7fd fc7f 	bl	80037c0 <test_printn>
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005ec2:	2120      	movs	r1, #32
    chSequentialStreamPut(chp, *msgp++);
 8005ec4:	6820      	ldr	r0, [r4, #0]
 8005ec6:	6803      	ldr	r3, [r0, #0]
 8005ec8:	689b      	ldr	r3, [r3, #8]
 8005eca:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005ecc:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005ed0:	2900      	cmp	r1, #0
 8005ed2:	d1f7      	bne.n	8005ec4 <main+0x654>
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
 8005ed4:	f858 3c04 	ldr.w	r3, [r8, #-4]
 8005ed8:	681d      	ldr	r5, [r3, #0]
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005eda:	7829      	ldrb	r1, [r5, #0]
 8005edc:	b139      	cbz	r1, 8005eee <main+0x67e>
    chSequentialStreamPut(chp, *msgp++);
 8005ede:	6820      	ldr	r0, [r4, #0]
 8005ee0:	6803      	ldr	r3, [r0, #0]
 8005ee2:	689b      	ldr	r3, [r3, #8]
 8005ee4:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005ee6:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005eea:	2900      	cmp	r1, #0
 8005eec:	d1f7      	bne.n	8005ede <main+0x66e>
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
      test_println(")");
 8005eee:	4858      	ldr	r0, [pc, #352]	; (8006050 <main+0x7e0>)
 8005ef0:	f7fd fc3e 	bl	8003770 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
 8005ef4:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8005ef8:	f7fe fe0a 	bl	8004b10 <chThdSleep>
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8005efc:	4b55      	ldr	r3, [pc, #340]	; (8006054 <main+0x7e4>)
      test_print(patterns[i][j]->name);
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
 8005efe:	f858 5c04 	ldr.w	r5, [r8, #-4]
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8005f02:	6033      	str	r3, [r6, #0]
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 8005f04:	2300      	movs	r3, #0
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;
 8005f06:	603b      	str	r3, [r7, #0]
 8005f08:	607b      	str	r3, [r7, #4]
 8005f0a:	60bb      	str	r3, [r7, #8]
 8005f0c:	60fb      	str	r3, [r7, #12]
 8005f0e:	613b      	str	r3, [r7, #16]

  if (tcp->setup != NULL)
 8005f10:	686a      	ldr	r2, [r5, #4]
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 8005f12:	f88a 3000 	strb.w	r3, [sl]
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;

  if (tcp->setup != NULL)
 8005f16:	b102      	cbz	r2, 8005f1a <main+0x6aa>
    tcp->setup();
 8005f18:	4790      	blx	r2
  tcp->execute();
 8005f1a:	68eb      	ldr	r3, [r5, #12]
 8005f1c:	4798      	blx	r3
  if (tcp->teardown != NULL)
 8005f1e:	68ab      	ldr	r3, [r5, #8]
 8005f20:	b103      	cbz	r3, 8005f24 <main+0x6b4>
    tcp->teardown();
 8005f22:	4798      	blx	r3

  test_wait_threads();
 8005f24:	f7fb ff74 	bl	8001e10 <test_wait_threads>
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
 8005f28:	f89a 3000 	ldrb.w	r3, [sl]
 8005f2c:	2b00      	cmp	r3, #0
 8005f2e:	d04f      	beq.n	8005fd0 <main+0x760>
 8005f30:	4d49      	ldr	r5, [pc, #292]	; (8006058 <main+0x7e8>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005f32:	212d      	movs	r1, #45	; 0x2d
    chSequentialStreamPut(chp, *msgp++);
 8005f34:	6820      	ldr	r0, [r4, #0]
 8005f36:	6803      	ldr	r3, [r0, #0]
 8005f38:	689b      	ldr	r3, [r3, #8]
 8005f3a:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005f3c:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005f40:	2900      	cmp	r1, #0
 8005f42:	d1f7      	bne.n	8005f34 <main+0x6c4>
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
 8005f44:	f8df e12c 	ldr.w	lr, [pc, #300]	; 8006074 <main+0x804>
 8005f48:	4d44      	ldr	r5, [pc, #272]	; (800605c <main+0x7ec>)
 8005f4a:	f8de 0000 	ldr.w	r0, [lr]
 8005f4e:	f7fd fc37 	bl	80037c0 <test_printn>
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005f52:	2120      	movs	r1, #32
    chSequentialStreamPut(chp, *msgp++);
 8005f54:	6820      	ldr	r0, [r4, #0]
 8005f56:	6803      	ldr	r3, [r0, #0]
 8005f58:	689b      	ldr	r3, [r3, #8]
 8005f5a:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005f5c:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005f60:	2900      	cmp	r1, #0
 8005f62:	d1f7      	bne.n	8005f54 <main+0x6e4>
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8005f64:	6833      	ldr	r3, [r6, #0]
 8005f66:	f8df e0ec 	ldr.w	lr, [pc, #236]	; 8006054 <main+0x7e4>
 8005f6a:	4573      	cmp	r3, lr
 8005f6c:	d909      	bls.n	8005f82 <main+0x712>
 8005f6e:	4d39      	ldr	r5, [pc, #228]	; (8006054 <main+0x7e4>)
    chSequentialStreamPut(chp, *cp++);
 8005f70:	6820      	ldr	r0, [r4, #0]
 8005f72:	f815 1b01 	ldrb.w	r1, [r5], #1
 8005f76:	6803      	ldr	r3, [r0, #0]
 8005f78:	689b      	ldr	r3, [r3, #8]
 8005f7a:	4798      	blx	r3
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8005f7c:	6833      	ldr	r3, [r6, #0]
 8005f7e:	429d      	cmp	r5, r3
 8005f80:	d3f6      	bcc.n	8005f70 <main+0x700>
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
        test_print(" [");
        print_tokens();
        test_println("])");
 8005f82:	4837      	ldr	r0, [pc, #220]	; (8006060 <main+0x7f0>)
 8005f84:	f7fd fbf4 	bl	8003770 <test_println>

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 8005f88:	f858 3b04 	ldr.w	r3, [r8], #4
 8005f8c:	2b00      	cmp	r3, #0
 8005f8e:	f47f af7d 	bne.w	8005e8c <main+0x61c>
#endif
  test_println("");

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
 8005f92:	9a05      	ldr	r2, [sp, #20]
 8005f94:	f852 3f04 	ldr.w	r3, [r2, #4]!
 8005f98:	9205      	str	r2, [sp, #20]
 8005f9a:	2b00      	cmp	r3, #0
 8005f9c:	f47f af68 	bne.w	8005e70 <main+0x600>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 8005fa0:	f7fd fc46 	bl	8003830 <print_line.9144>
 8005fa4:	4d2f      	ldr	r5, [pc, #188]	; (8006064 <main+0x7f4>)
  test_println("");
 8005fa6:	4812      	ldr	r0, [pc, #72]	; (8005ff0 <main+0x780>)
 8005fa8:	f7fd fbe2 	bl	8003770 <test_println>
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005fac:	2146      	movs	r1, #70	; 0x46
    chSequentialStreamPut(chp, *msgp++);
 8005fae:	6820      	ldr	r0, [r4, #0]
 8005fb0:	6803      	ldr	r3, [r0, #0]
 8005fb2:	689b      	ldr	r3, [r3, #8]
 8005fb4:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005fb6:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005fba:	2900      	cmp	r1, #0
 8005fbc:	d1f7      	bne.n	8005fae <main+0x73e>
    i++;
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
 8005fbe:	f8df e080 	ldr.w	lr, [pc, #128]	; 8006040 <main+0x7d0>
 8005fc2:	f89e 3000 	ldrb.w	r3, [lr]
 8005fc6:	b93b      	cbnz	r3, 8005fd8 <main+0x768>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 8005fc8:	4827      	ldr	r0, [pc, #156]	; (8006068 <main+0x7f8>)
 8005fca:	f7fd fbd1 	bl	8003770 <test_println>
 8005fce:	e6c9      	b.n	8005d64 <main+0x4f4>
        test_print(" [");
        print_tokens();
        test_println("])");
      }
      else
        test_println("--- Result: SUCCESS");
 8005fd0:	4826      	ldr	r0, [pc, #152]	; (800606c <main+0x7fc>)
 8005fd2:	f7fd fbcd 	bl	8003770 <test_println>
 8005fd6:	e754      	b.n	8005e82 <main+0x612>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
 8005fd8:	4825      	ldr	r0, [pc, #148]	; (8006070 <main+0x800>)
 8005fda:	f7fd fbc9 	bl	8003770 <test_println>
 8005fde:	e6c1      	b.n	8005d64 <main+0x4f4>
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8005fe0:	f640 028b 	movw	r2, #2187	; 0x88b
 8005fe4:	609a      	str	r2, [r3, #8]
 8005fe6:	e674      	b.n	8005cd2 <main+0x462>
 8005fe8:	40020000 	.word	0x40020000
 8005fec:	20001178 	.word	0x20001178
 8005ff0:	08006840 	.word	0x08006840
 8005ff4:	08006c98 	.word	0x08006c98
 8005ff8:	08006cb8 	.word	0x08006cb8
 8005ffc:	08006cb4 	.word	0x08006cb4
 8006000:	08006d18 	.word	0x08006d18
 8006004:	08006d20 	.word	0x08006d20
 8006008:	08006d34 	.word	0x08006d34
 800600c:	08006d4c 	.word	0x08006d4c
 8006010:	08006d60 	.word	0x08006d60
 8006014:	08006da8 	.word	0x08006da8
 8006018:	08006dbc 	.word	0x08006dbc
 800601c:	08006dc8 	.word	0x08006dc8
 8006020:	08006ddc 	.word	0x08006ddc
 8006024:	08006de8 	.word	0x08006de8
 8006028:	08006dfc 	.word	0x08006dfc
 800602c:	08006e14 	.word	0x08006e14
 8006030:	08006e28 	.word	0x08006e28
 8006034:	08006e54 	.word	0x08006e54
 8006038:	08006af0 	.word	0x08006af0
 800603c:	08006e68 	.word	0x08006e68
 8006040:	20000fc0 	.word	0x20000fc0
 8006044:	08006a60 	.word	0x08006a60
 8006048:	08006ccc 	.word	0x08006ccc
 800604c:	08006e90 	.word	0x08006e90
 8006050:	08006cdc 	.word	0x08006cdc
 8006054:	200011f4 	.word	0x200011f4
 8006058:	08006ce0 	.word	0x08006ce0
 800605c:	08006e94 	.word	0x08006e94
 8006060:	08006cf8 	.word	0x08006cf8
 8006064:	08006e98 	.word	0x08006e98
 8006068:	08006d08 	.word	0x08006d08
 800606c:	08006cfc 	.word	0x08006cfc
 8006070:	08006d10 	.word	0x08006d10
 8006074:	20000f98 	.word	0x20000f98
 8006078:	f3af 8000 	nop.w
 800607c:	f3af 8000 	nop.w

08006080 <mtx6_setup.9933>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8006080:	4b04      	ldr	r3, [pc, #16]	; (8006094 <mtx6_setup.9933+0x14>)
 8006082:	4a05      	ldr	r2, [pc, #20]	; (8006098 <mtx6_setup.9933+0x18>)
 8006084:	601b      	str	r3, [r3, #0]
 8006086:	2100      	movs	r1, #0
 8006088:	6012      	str	r2, [r2, #0]
  tqp->p_prev = (thread_t *)tqp;
 800608a:	6052      	str	r2, [r2, #4]
 800608c:	605b      	str	r3, [r3, #4]
 800608e:	6099      	str	r1, [r3, #8]
 8006090:	4770      	bx	lr
 8006092:	bf00      	nop
 8006094:	20000830 	.word	0x20000830
 8006098:	20000818 	.word	0x20000818
 800609c:	f3af 8000 	nop.w

080060a0 <mtx7_setup.9935>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80060a0:	4b04      	ldr	r3, [pc, #16]	; (80060b4 <mtx7_setup.9935+0x14>)
 80060a2:	4a05      	ldr	r2, [pc, #20]	; (80060b8 <mtx7_setup.9935+0x18>)
 80060a4:	601b      	str	r3, [r3, #0]
 80060a6:	2100      	movs	r1, #0
 80060a8:	6012      	str	r2, [r2, #0]
  tqp->p_prev = (thread_t *)tqp;
 80060aa:	6052      	str	r2, [r2, #4]
 80060ac:	605b      	str	r3, [r3, #4]
 80060ae:	6099      	str	r1, [r3, #8]
 80060b0:	4770      	bx	lr
 80060b2:	bf00      	nop
 80060b4:	20000830 	.word	0x20000830
 80060b8:	20000818 	.word	0x20000818
 80060bc:	f3af 8000 	nop.w

080060c0 <mtx8_setup.9937>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80060c0:	4a06      	ldr	r2, [pc, #24]	; (80060dc <mtx8_setup.9937+0x1c>)
 80060c2:	4b07      	ldr	r3, [pc, #28]	; (80060e0 <mtx8_setup.9937+0x20>)
 80060c4:	4907      	ldr	r1, [pc, #28]	; (80060e4 <mtx8_setup.9937+0x24>)
 80060c6:	6012      	str	r2, [r2, #0]
 80060c8:	2000      	movs	r0, #0
 80060ca:	6009      	str	r1, [r1, #0]
  tqp->p_prev = (thread_t *)tqp;
 80060cc:	6049      	str	r1, [r1, #4]
 80060ce:	6052      	str	r2, [r2, #4]
 80060d0:	6090      	str	r0, [r2, #8]
 80060d2:	6098      	str	r0, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80060d4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80060d6:	605b      	str	r3, [r3, #4]
 80060d8:	4770      	bx	lr
 80060da:	bf00      	nop
 80060dc:	20000830 	.word	0x20000830
 80060e0:	20000820 	.word	0x20000820
 80060e4:	20000818 	.word	0x20000818
 80060e8:	f3af 8000 	nop.w
 80060ec:	f3af 8000 	nop.w

080060f0 <heap1_setup.10674>:
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
 80060f0:	4909      	ldr	r1, [pc, #36]	; (8006118 <heap1_setup.10674+0x28>)
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 80060f2:	4b0a      	ldr	r3, [pc, #40]	; (800611c <heap1_setup.10674+0x2c>)
 * allocator.<br>
 * The test expects to find the heap back to the initial status after each
 * sequence.
 */

static void heap1_setup(void) {
 80060f4:	b410      	push	{r4}
 80060f6:	2200      	movs	r2, #0
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 80060f8:	f44f 64cc 	mov.w	r4, #1632	; 0x660
 80060fc:	e881 0014 	stmia.w	r1, {r2, r4}
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8006100:	f103 0010 	add.w	r0, r3, #16
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
 8006104:	6099      	str	r1, [r3, #8]
  heapp->h_free.h.size = 0;
 8006106:	60da      	str	r2, [r3, #12]
 8006108:	6118      	str	r0, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
 800610a:	6158      	str	r0, [r3, #20]
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 800610c:	601a      	str	r2, [r3, #0]
 800610e:	619a      	str	r2, [r3, #24]

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
}
 8006110:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006114:	4770      	bx	lr
 8006116:	bf00      	nop
 8006118:	20000928 	.word	0x20000928
 800611c:	20001508 	.word	0x20001508

08006120 <dyn1_setup.10839>:
  heapp->h_free.h.u.next = hp;
 8006120:	4909      	ldr	r1, [pc, #36]	; (8006148 <dyn1_setup.10839+0x28>)
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8006122:	4b0a      	ldr	r3, [pc, #40]	; (800614c <dyn1_setup.10839+0x2c>)

  test_emit_token(*(char *)p);
}

#if CH_CFG_USE_HEAP || defined(__DOXYGEN__)
static void dyn1_setup(void) {
 8006124:	b410      	push	{r4}
 8006126:	2200      	movs	r2, #0
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8006128:	f44f 64cc 	mov.w	r4, #1632	; 0x660
 800612c:	e881 0014 	stmia.w	r1, {r2, r4}
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8006130:	f103 0010 	add.w	r0, r3, #16
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
 8006134:	6099      	str	r1, [r3, #8]
  heapp->h_free.h.size = 0;
 8006136:	60da      	str	r2, [r3, #12]
 8006138:	6118      	str	r0, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
 800613a:	6158      	str	r0, [r3, #20]
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 800613c:	601a      	str	r2, [r3, #0]
 800613e:	619a      	str	r2, [r3, #24]

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}
 8006140:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006144:	4770      	bx	lr
 8006146:	bf00      	nop
 8006148:	20000928 	.word	0x20000928
 800614c:	200008d8 	.word	0x200008d8

08006150 <dyn3_setup.10841>:
  heapp->h_free.h.u.next = hp;
 8006150:	4909      	ldr	r1, [pc, #36]	; (8006178 <dyn3_setup.10841+0x28>)
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8006152:	4b0a      	ldr	r3, [pc, #40]	; (800617c <dyn3_setup.10841+0x2c>)
    ftp = chRegNextThread(ftp);
  } while (ftp != NULL);
  return found;
}

static void dyn3_setup(void) {
 8006154:	b410      	push	{r4}
 8006156:	2200      	movs	r2, #0
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8006158:	f44f 64cc 	mov.w	r4, #1632	; 0x660
 800615c:	e881 0014 	stmia.w	r1, {r2, r4}
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8006160:	f103 0010 	add.w	r0, r3, #16
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
 8006164:	6099      	str	r1, [r3, #8]
  heapp->h_free.h.size = 0;
 8006166:	60da      	str	r2, [r3, #12]
 8006168:	6118      	str	r0, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
 800616a:	6158      	str	r0, [r3, #20]
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 800616c:	601a      	str	r2, [r3, #0]
 800616e:	619a      	str	r2, [r3, #24]

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}
 8006170:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006174:	4770      	bx	lr
 8006176:	bf00      	nop
 8006178:	20000928 	.word	0x20000928
 800617c:	200008d8 	.word	0x200008d8

08006180 <bmk12_setup.11412>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8006180:	4b02      	ldr	r3, [pc, #8]	; (800618c <bmk12_setup.11412+0xc>)
 8006182:	2200      	movs	r2, #0
 8006184:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8006186:	605b      	str	r3, [r3, #4]
 8006188:	609a      	str	r2, [r3, #8]
 800618a:	4770      	bx	lr
 800618c:	200014d0 	.word	0x200014d0

08006190 <mtx1_setup.9921>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8006190:	4b02      	ldr	r3, [pc, #8]	; (800619c <mtx1_setup.9921+0xc>)
 8006192:	2200      	movs	r2, #0
 8006194:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8006196:	605b      	str	r3, [r3, #4]
 8006198:	609a      	str	r2, [r3, #8]
 800619a:	4770      	bx	lr
 800619c:	20000830 	.word	0x20000830

080061a0 <mtx4_setup.9923>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80061a0:	4a04      	ldr	r2, [pc, #16]	; (80061b4 <mtx4_setup.9923+0x14>)
 80061a2:	4b05      	ldr	r3, [pc, #20]	; (80061b8 <mtx4_setup.9923+0x18>)
 80061a4:	6012      	str	r2, [r2, #0]
 80061a6:	2100      	movs	r1, #0
  tqp->p_prev = (thread_t *)tqp;
 80061a8:	6052      	str	r2, [r2, #4]
 80061aa:	6091      	str	r1, [r2, #8]
 80061ac:	6099      	str	r1, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80061ae:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80061b0:	605b      	str	r3, [r3, #4]
 80061b2:	4770      	bx	lr
 80061b4:	20000830 	.word	0x20000830
 80061b8:	20000820 	.word	0x20000820
 80061bc:	f3af 8000 	nop.w

080061c0 <queues2_setup.11027>:
 * This test case tests synchronous and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
 80061c0:	b430      	push	{r4, r5}
  oqp->q_buffer  = bp;
 80061c2:	4a08      	ldr	r2, [pc, #32]	; (80061e4 <queues2_setup.11027+0x24>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80061c4:	4b08      	ldr	r3, [pc, #32]	; (80061e8 <queues2_setup.11027+0x28>)
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 80061c6:	4809      	ldr	r0, [pc, #36]	; (80061ec <queues2_setup.11027+0x2c>)
 80061c8:	601b      	str	r3, [r3, #0]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 80061ca:	1d15      	adds	r5, r2, #4
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 80061cc:	2404      	movs	r4, #4
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 80061ce:	2100      	movs	r1, #0
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 80061d0:	611d      	str	r5, [r3, #16]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 80061d2:	609c      	str	r4, [r3, #8]
  tqp->p_prev = (thread_t *)tqp;
 80061d4:	605b      	str	r3, [r3, #4]
  oqp->q_buffer  = bp;
 80061d6:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 80061d8:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 80061da:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 80061dc:	61d8      	str	r0, [r3, #28]
  oqp->q_link    = link;
 80061de:	6219      	str	r1, [r3, #32]

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}
 80061e0:	bc30      	pop	{r4, r5}
 80061e2:	4770      	bx	lr
 80061e4:	20000928 	.word	0x20000928
 80061e8:	20000890 	.word	0x20000890
 80061ec:	08000311 	.word	0x08000311

080061f0 <queues1_setup.11025>:
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 80061f0:	4a08      	ldr	r2, [pc, #32]	; (8006214 <queues1_setup.11025+0x24>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80061f2:	4b09      	ldr	r3, [pc, #36]	; (8006218 <queues1_setup.11025+0x28>)
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 80061f4:	4809      	ldr	r0, [pc, #36]	; (800621c <queues1_setup.11025+0x2c>)
 * This test case tests synchronous and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
 80061f6:	b410      	push	{r4}
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80061f8:	2100      	movs	r1, #0
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 80061fa:	1d14      	adds	r4, r2, #4
 80061fc:	611c      	str	r4, [r3, #16]
 80061fe:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8006200:	605b      	str	r3, [r3, #4]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8006202:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8006204:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8006206:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8006208:	61d8      	str	r0, [r3, #28]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800620a:	6099      	str	r1, [r3, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 800620c:	6219      	str	r1, [r3, #32]

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}
 800620e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006212:	4770      	bx	lr
 8006214:	20000928 	.word	0x20000928
 8006218:	2000086c 	.word	0x2000086c
 800621c:	08000311 	.word	0x08000311

08006220 <mbox1_setup.10279>:
 * Messages are posted/fetched from a mailbox in carefully designed sequences
 * in order to stimulate all the possible code paths inside the mailbox.<br>
 * The test expects to find a consistent mailbox status after each operation.
 */

static void mbox1_setup(void) {
 8006220:	b470      	push	{r4, r5, r6}
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
 8006222:	4b0b      	ldr	r3, [pc, #44]	; (8006250 <mbox1_setup.10279+0x30>)
 8006224:	4a0b      	ldr	r2, [pc, #44]	; (8006254 <mbox1_setup.10279+0x34>)
 8006226:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
  mbp->mb_wrptr = buf;
  mbp->mb_top = &buf[n];
 8006228:	f102 0614 	add.w	r6, r2, #20
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
  sp->s_cnt = n;
 800622c:	2505      	movs	r5, #5
 800622e:	2400      	movs	r4, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8006230:	f103 001c 	add.w	r0, r3, #28
 8006234:	f103 0110 	add.w	r1, r3, #16
 8006238:	605e      	str	r6, [r3, #4]
 800623a:	625d      	str	r5, [r3, #36]	; 0x24
 800623c:	619c      	str	r4, [r3, #24]
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
  mbp->mb_rdptr = buf;
 800623e:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
 8006240:	609a      	str	r2, [r3, #8]
 8006242:	61d8      	str	r0, [r3, #28]
  tqp->p_prev = (thread_t *)tqp;
 8006244:	6218      	str	r0, [r3, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8006246:	6119      	str	r1, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
 8006248:	6159      	str	r1, [r3, #20]

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
}
 800624a:	bc70      	pop	{r4, r5, r6}
 800624c:	4770      	bx	lr
 800624e:	bf00      	nop
 8006250:	20000840 	.word	0x20000840
 8006254:	20000928 	.word	0x20000928
 8006258:	f3af 8000 	nop.w
 800625c:	f3af 8000 	nop.w

08006260 <bmk7_setup.11398>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8006260:	4b02      	ldr	r3, [pc, #8]	; (800626c <bmk7_setup.11398+0xc>)
 8006262:	2200      	movs	r2, #0
 8006264:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8006266:	605b      	str	r3, [r3, #4]
 8006268:	609a      	str	r2, [r3, #8]
 800626a:	4770      	bx	lr
 800626c:	200008b8 	.word	0x200008b8

08006270 <bmk11_setup.11400>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8006270:	4b02      	ldr	r3, [pc, #8]	; (800627c <bmk11_setup.11400+0xc>)
 8006272:	2201      	movs	r2, #1
 8006274:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8006276:	605b      	str	r3, [r3, #4]
 8006278:	609a      	str	r2, [r3, #8]
 800627a:	4770      	bx	lr
 800627c:	200008b8 	.word	0x200008b8

08006280 <sem1_setup.9664>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8006280:	4b02      	ldr	r3, [pc, #8]	; (800628c <sem1_setup.9664+0xc>)
 8006282:	2200      	movs	r2, #0
 8006284:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8006286:	605b      	str	r3, [r3, #4]
 8006288:	609a      	str	r2, [r3, #8]
 800628a:	4770      	bx	lr
 800628c:	20000800 	.word	0x20000800

08006290 <sem2_setup.9666>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8006290:	4b02      	ldr	r3, [pc, #8]	; (800629c <sem2_setup.9666+0xc>)
 8006292:	2200      	movs	r2, #0
 8006294:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8006296:	605b      	str	r3, [r3, #4]
 8006298:	609a      	str	r2, [r3, #8]
 800629a:	4770      	bx	lr
 800629c:	20000800 	.word	0x20000800

080062a0 <sem3_setup.9668>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80062a0:	4b02      	ldr	r3, [pc, #8]	; (80062ac <sem3_setup.9668+0xc>)
 80062a2:	2200      	movs	r2, #0
 80062a4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80062a6:	605b      	str	r3, [r3, #4]
 80062a8:	609a      	str	r2, [r3, #8]
 80062aa:	4770      	bx	lr
 80062ac:	20000800 	.word	0x20000800

080062b0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80062b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80062b4:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 80062b8:	692b      	ldr	r3, [r5, #16]
 80062ba:	079b      	lsls	r3, r3, #30
 80062bc:	d403      	bmi.n	80062c6 <VectorB0+0x16>
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 80062be:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 80062c2:	f7fd bb9d 	b.w	8003a00 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 80062c6:	2700      	movs	r7, #0
 80062c8:	612f      	str	r7, [r5, #16]
 80062ca:	2620      	movs	r6, #32
 80062cc:	f386 8811 	msr	BASEPRI, r6
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 80062d0:	4c1d      	ldr	r4, [pc, #116]	; (8006348 <VectorB0+0x98>)
 80062d2:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80062d4:	69e3      	ldr	r3, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 80062d6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80062d8:	6899      	ldr	r1, [r3, #8]
 80062da:	ebc0 0c02 	rsb	ip, r0, r2
 80062de:	458c      	cmp	ip, r1
 80062e0:	bf38      	it	cc
 80062e2:	f104 071c 	addcc.w	r7, r4, #28
 80062e6:	d31d      	bcc.n	8006324 <VectorB0+0x74>
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 80062e8:	46b8      	mov	r8, r7
 80062ea:	f104 071c 	add.w	r7, r4, #28
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80062ee:	681a      	ldr	r2, [r3, #0]
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 80062f0:	f8d3 c00c 	ldr.w	ip, [r3, #12]
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 80062f4:	4401      	add	r1, r0
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 80062f6:	42ba      	cmp	r2, r7
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 80062f8:	62a1      	str	r1, [r4, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80062fa:	6057      	str	r7, [r2, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 80062fc:	61e2      	str	r2, [r4, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 80062fe:	f8c3 800c 	str.w	r8, [r3, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8006302:	bf08      	it	eq
 8006304:	f8c5 800c 	streq.w	r8, [r5, #12]
 8006308:	f388 8811 	msr	BASEPRI, r8
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 800630c:	6918      	ldr	r0, [r3, #16]
 800630e:	47e0      	blx	ip
 8006310:	f386 8811 	msr	BASEPRI, r6
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 8006314:	69e3      	ldr	r3, [r4, #28]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8006316:	6a6a      	ldr	r2, [r5, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8006318:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800631a:	6899      	ldr	r1, [r3, #8]
 800631c:	ebc0 0c02 	rsb	ip, r0, r2
 8006320:	4561      	cmp	r1, ip
 8006322:	d9e4      	bls.n	80062ee <VectorB0+0x3e>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8006324:	42bb      	cmp	r3, r7
 8006326:	d008      	beq.n	800633a <VectorB0+0x8a>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8006328:	4401      	add	r1, r0
 800632a:	1a89      	subs	r1, r1, r2
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800632c:	2901      	cmp	r1, #1
 800632e:	bf98      	it	ls
 8006330:	2102      	movls	r1, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8006332:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  }
  port_timer_set_alarm(now + delta);
 8006336:	440a      	add	r2, r1
 8006338:	635a      	str	r2, [r3, #52]	; 0x34
 800633a:	2300      	movs	r3, #0
 800633c:	f383 8811 	msr	BASEPRI, r3
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8006340:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8006344:	f7fd bb5c 	b.w	8003a00 <_port_irq_epilogue>
 8006348:	20001208 	.word	0x20001208
 800634c:	f3af 8000 	nop.w

08006350 <thread11.9916>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread11, p) {
 8006350:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006354:	4680      	mov	r8, r0

  chMtxLock(&m2);
 8006356:	481c      	ldr	r0, [pc, #112]	; (80063c8 <thread11.9916+0x78>)
 8006358:	f7fd feb2 	bl	80040c0 <chMtxLock>
  chMtxLock(&m1);
 800635c:	481b      	ldr	r0, [pc, #108]	; (80063cc <thread11.9916+0x7c>)
 800635e:	f7fd feaf 	bl	80040c0 <chMtxLock>
 8006362:	2320      	movs	r3, #32
 8006364:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006368:	4e19      	ldr	r6, [pc, #100]	; (80063d0 <thread11.9916+0x80>)
 800636a:	69b3      	ldr	r3, [r6, #24]
 800636c:	6b9f      	ldr	r7, [r3, #56]	; 0x38
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 800636e:	4638      	mov	r0, r7
 8006370:	f7fd fdde 	bl	8003f30 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
 8006374:	4b17      	ldr	r3, [pc, #92]	; (80063d4 <thread11.9916+0x84>)
 8006376:	69b4      	ldr	r4, [r6, #24]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8006378:	461d      	mov	r5, r3
 800637a:	6223      	str	r3, [r4, #32]
 800637c:	e003      	b.n	8006386 <thread11.9916+0x36>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800637e:	6899      	ldr	r1, [r3, #8]
 8006380:	68a2      	ldr	r2, [r4, #8]
 8006382:	4291      	cmp	r1, r2
 8006384:	d302      	bcc.n	800638c <thread11.9916+0x3c>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8006386:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8006388:	42ab      	cmp	r3, r5
 800638a:	d1f8      	bne.n	800637e <thread11.9916+0x2e>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800638c:	685a      	ldr	r2, [r3, #4]
 800638e:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8006390:	6023      	str	r3, [r4, #0]
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8006392:	2007      	movs	r0, #7
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8006394:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8006396:	605c      	str	r4, [r3, #4]
 8006398:	f7fd fcd2 	bl	8003d40 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 800639c:	69b3      	ldr	r3, [r6, #24]
  queue_prio_insert(currp, &cp->c_queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
  if (msg != MSG_TIMEOUT) {
 800639e:	6a1b      	ldr	r3, [r3, #32]
 80063a0:	3301      	adds	r3, #1
 80063a2:	d002      	beq.n	80063aa <thread11.9916+0x5a>
    chMtxLockS(mp);
 80063a4:	4638      	mov	r0, r7
 80063a6:	f7fd fe23 	bl	8003ff0 <chMtxLockS>
 80063aa:	2300      	movs	r3, #0
 80063ac:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 80063b0:	f898 0000 	ldrb.w	r0, [r8]
 80063b4:	f7fd f9cc 	bl	8003750 <test_emit_token>
  chMtxUnlock(&m1);
 80063b8:	4804      	ldr	r0, [pc, #16]	; (80063cc <thread11.9916+0x7c>)
 80063ba:	f7fd fde1 	bl	8003f80 <chMtxUnlock>
  chMtxUnlock(&m2);
 80063be:	4802      	ldr	r0, [pc, #8]	; (80063c8 <thread11.9916+0x78>)
}
 80063c0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
 80063c4:	f7fd bddc 	b.w	8003f80 <chMtxUnlock>
 80063c8:	20000820 	.word	0x20000820
 80063cc:	20000830 	.word	0x20000830
 80063d0:	20001208 	.word	0x20001208
 80063d4:	20000818 	.word	0x20000818
 80063d8:	f3af 8000 	nop.w
 80063dc:	f3af 8000 	nop.w

080063e0 <bmk9_execute.11404>:
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
 80063e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 80063e2:	4a26      	ldr	r2, [pc, #152]	; (800647c <bmk9_execute.11404+0x9c>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80063e4:	4b26      	ldr	r3, [pc, #152]	; (8006480 <bmk9_execute.11404+0xa0>)
 80063e6:	4f27      	ldr	r7, [pc, #156]	; (8006484 <bmk9_execute.11404+0xa4>)
 80063e8:	601b      	str	r3, [r3, #0]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80063ea:	2400      	movs	r4, #0
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 80063ec:	f102 0110 	add.w	r1, r2, #16
  tqp->p_prev = (thread_t *)tqp;
 80063f0:	605b      	str	r3, [r3, #4]
 80063f2:	6119      	str	r1, [r3, #16]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 80063f4:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 80063f6:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 80063f8:	615a      	str	r2, [r3, #20]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80063fa:	609c      	str	r4, [r3, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 80063fc:	61dc      	str	r4, [r3, #28]
  iqp->q_link    = link;
 80063fe:	621c      	str	r4, [r3, #32]
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
  n = 0;
  test_wait_tick();
 8006400:	f7fe fc06 	bl	8004c10 <test_wait_tick>
  test_start_timer(1000);
 8006404:	f7fd ffbc 	bl	8004380 <test_start_timer.constprop.2>
  do {
    chSysLock();
    chIQPutI(&iq, 0);
 8006408:	4626      	mov	r6, r4
 800640a:	2520      	movs	r5, #32
 800640c:	f385 8811 	msr	BASEPRI, r5
 8006410:	2100      	movs	r1, #0
 8006412:	481b      	ldr	r0, [pc, #108]	; (8006480 <bmk9_execute.11404+0xa0>)
 8006414:	f7fa f9d4 	bl	80007c0 <chIQPutI>
    chIQPutI(&iq, 1);
 8006418:	2101      	movs	r1, #1
 800641a:	4819      	ldr	r0, [pc, #100]	; (8006480 <bmk9_execute.11404+0xa0>)
 800641c:	f7fa f9d0 	bl	80007c0 <chIQPutI>
    chIQPutI(&iq, 2);
 8006420:	2102      	movs	r1, #2
 8006422:	4817      	ldr	r0, [pc, #92]	; (8006480 <bmk9_execute.11404+0xa0>)
 8006424:	f7fa f9cc 	bl	80007c0 <chIQPutI>
    chIQPutI(&iq, 3);
 8006428:	2103      	movs	r1, #3
 800642a:	4815      	ldr	r0, [pc, #84]	; (8006480 <bmk9_execute.11404+0xa0>)
 800642c:	f7fa f9c8 	bl	80007c0 <chIQPutI>
 8006430:	f386 8811 	msr	BASEPRI, r6
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8006434:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8006438:	4811      	ldr	r0, [pc, #68]	; (8006480 <bmk9_execute.11404+0xa0>)
 800643a:	f7fe fc59 	bl	8004cf0 <chIQGetTimeout>
 800643e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8006442:	480f      	ldr	r0, [pc, #60]	; (8006480 <bmk9_execute.11404+0xa0>)
 8006444:	f7fe fc54 	bl	8004cf0 <chIQGetTimeout>
 8006448:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800644c:	480c      	ldr	r0, [pc, #48]	; (8006480 <bmk9_execute.11404+0xa0>)
 800644e:	f7fe fc4f 	bl	8004cf0 <chIQGetTimeout>
 8006452:	480b      	ldr	r0, [pc, #44]	; (8006480 <bmk9_execute.11404+0xa0>)
 8006454:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8006458:	f7fe fc4a 	bl	8004cf0 <chIQGetTimeout>
    (void)chIQGet(&iq);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800645c:	783b      	ldrb	r3, [r7, #0]
    chSysUnlock();
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    n++;
 800645e:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8006460:	2b00      	cmp	r3, #0
 8006462:	d0d3      	beq.n	800640c <bmk9_execute.11404+0x2c>
  test_print("--- Score : ");
 8006464:	4808      	ldr	r0, [pc, #32]	; (8006488 <bmk9_execute.11404+0xa8>)
 8006466:	f7fd f99b 	bl	80037a0 <test_print>
  test_printn(n * 4);
 800646a:	00a0      	lsls	r0, r4, #2
 800646c:	f7fd f9a8 	bl	80037c0 <test_printn>
  test_println(" bytes/S");
 8006470:	4806      	ldr	r0, [pc, #24]	; (800648c <bmk9_execute.11404+0xac>)
}
 8006472:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" bytes/S");
 8006476:	f7fd b97b 	b.w	8003770 <test_println>
 800647a:	bf00      	nop
 800647c:	20001528 	.word	0x20001528
 8006480:	200014e0 	.word	0x200014e0
 8006484:	200008c4 	.word	0x200008c4
 8006488:	08006820 	.word	0x08006820
 800648c:	08007460 	.word	0x08007460

08006490 <bmk12_execute.11410>:
static void bmk12_setup(void) {

  chMtxObjectInit(&mtx1);
}

static void bmk12_execute(void) {
 8006490:	b538      	push	{r3, r4, r5, lr}
  uint32_t n = 0;

  test_wait_tick();
 8006492:	f7fe fbbd 	bl	8004c10 <test_wait_tick>
  test_start_timer(1000);
 8006496:	f7fd ff73 	bl	8004380 <test_start_timer.constprop.2>
 800649a:	4d14      	ldr	r5, [pc, #80]	; (80064ec <bmk12_execute.11410+0x5c>)

  chMtxObjectInit(&mtx1);
}

static void bmk12_execute(void) {
  uint32_t n = 0;
 800649c:	2400      	movs	r4, #0

  test_wait_tick();
  test_start_timer(1000);
  do {
    chMtxLock(&mtx1);
 800649e:	4814      	ldr	r0, [pc, #80]	; (80064f0 <bmk12_execute.11410+0x60>)
 80064a0:	f7fd fe0e 	bl	80040c0 <chMtxLock>
    chMtxUnlock(&mtx1);
 80064a4:	4812      	ldr	r0, [pc, #72]	; (80064f0 <bmk12_execute.11410+0x60>)
 80064a6:	f7fd fd6b 	bl	8003f80 <chMtxUnlock>
    chMtxLock(&mtx1);
 80064aa:	4811      	ldr	r0, [pc, #68]	; (80064f0 <bmk12_execute.11410+0x60>)
 80064ac:	f7fd fe08 	bl	80040c0 <chMtxLock>
    chMtxUnlock(&mtx1);
 80064b0:	480f      	ldr	r0, [pc, #60]	; (80064f0 <bmk12_execute.11410+0x60>)
 80064b2:	f7fd fd65 	bl	8003f80 <chMtxUnlock>
    chMtxLock(&mtx1);
 80064b6:	480e      	ldr	r0, [pc, #56]	; (80064f0 <bmk12_execute.11410+0x60>)
 80064b8:	f7fd fe02 	bl	80040c0 <chMtxLock>
    chMtxUnlock(&mtx1);
 80064bc:	480c      	ldr	r0, [pc, #48]	; (80064f0 <bmk12_execute.11410+0x60>)
 80064be:	f7fd fd5f 	bl	8003f80 <chMtxUnlock>
    chMtxLock(&mtx1);
 80064c2:	480b      	ldr	r0, [pc, #44]	; (80064f0 <bmk12_execute.11410+0x60>)
 80064c4:	f7fd fdfc 	bl	80040c0 <chMtxLock>
    chMtxUnlock(&mtx1);
 80064c8:	4809      	ldr	r0, [pc, #36]	; (80064f0 <bmk12_execute.11410+0x60>)
 80064ca:	f7fd fd59 	bl	8003f80 <chMtxUnlock>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80064ce:	782b      	ldrb	r3, [r5, #0]
    chMtxUnlock(&mtx1);
    chMtxLock(&mtx1);
    chMtxUnlock(&mtx1);
    chMtxLock(&mtx1);
    chMtxUnlock(&mtx1);
    n++;
 80064d0:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80064d2:	2b00      	cmp	r3, #0
 80064d4:	d0e3      	beq.n	800649e <bmk12_execute.11410+0xe>
  test_print("--- Score : ");
 80064d6:	4807      	ldr	r0, [pc, #28]	; (80064f4 <bmk12_execute.11410+0x64>)
 80064d8:	f7fd f962 	bl	80037a0 <test_print>
  test_printn(n * 4);
 80064dc:	00a0      	lsls	r0, r4, #2
 80064de:	f7fd f96f 	bl	80037c0 <test_printn>
  test_println(" lock+unlock/S");
 80064e2:	4805      	ldr	r0, [pc, #20]	; (80064f8 <bmk12_execute.11410+0x68>)
}
 80064e4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" lock+unlock/S");
 80064e8:	f7fd b942 	b.w	8003770 <test_println>
 80064ec:	200008c4 	.word	0x200008c4
 80064f0:	200014d0 	.word	0x200014d0
 80064f4:	08006820 	.word	0x08006820
 80064f8:	0800746c 	.word	0x0800746c
 80064fc:	f3af 8000 	nop.w

08006500 <bmk10_execute.11406>:
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
 8006500:	b538      	push	{r3, r4, r5, lr}
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;

  test_wait_tick();
 8006502:	f7fe fb85 	bl	8004c10 <test_wait_tick>
  test_start_timer(1000);
 8006506:	f7fd ff3b 	bl	8004380 <test_start_timer.constprop.2>
 800650a:	4d15      	ldr	r5, [pc, #84]	; (8006560 <bmk10_execute.11406+0x60>)

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;
 800650c:	2400      	movs	r4, #0
 800650e:	2320      	movs	r3, #32
 8006510:	f383 8811 	msr	BASEPRI, r3

  test_wait_tick();
  test_start_timer(1000);
  do {
    chSysLock();
    chVTDoSetI(&vt1, 1, tmo, NULL);
 8006514:	4813      	ldr	r0, [pc, #76]	; (8006564 <bmk10_execute.11406+0x64>)
 8006516:	4a14      	ldr	r2, [pc, #80]	; (8006568 <bmk10_execute.11406+0x68>)
 8006518:	2101      	movs	r1, #1
 800651a:	2300      	movs	r3, #0
 800651c:	f7fa f8c8 	bl	80006b0 <chVTDoSetI>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
 8006520:	4a11      	ldr	r2, [pc, #68]	; (8006568 <bmk10_execute.11406+0x68>)
 8006522:	4812      	ldr	r0, [pc, #72]	; (800656c <bmk10_execute.11406+0x6c>)
 8006524:	f242 7110 	movw	r1, #10000	; 0x2710
 8006528:	2300      	movs	r3, #0
 800652a:	f7fa f8c1 	bl	80006b0 <chVTDoSetI>
    chVTDoResetI(&vt1);
 800652e:	480d      	ldr	r0, [pc, #52]	; (8006564 <bmk10_execute.11406+0x64>)
 8006530:	f7fd fa2e 	bl	8003990 <chVTDoResetI>
    chVTDoResetI(&vt2);
 8006534:	480d      	ldr	r0, [pc, #52]	; (800656c <bmk10_execute.11406+0x6c>)
 8006536:	f7fd fa2b 	bl	8003990 <chVTDoResetI>
 800653a:	2300      	movs	r3, #0
 800653c:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8006540:	782b      	ldrb	r3, [r5, #0]
    chVTDoSetI(&vt1, 1, tmo, NULL);
    chVTDoSetI(&vt2, 10000, tmo, NULL);
    chVTDoResetI(&vt1);
    chVTDoResetI(&vt2);
    chSysUnlock();
    n++;
 8006542:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8006544:	2b00      	cmp	r3, #0
 8006546:	d0e2      	beq.n	800650e <bmk10_execute.11406+0xe>
  test_print("--- Score : ");
 8006548:	4809      	ldr	r0, [pc, #36]	; (8006570 <bmk10_execute.11406+0x70>)
 800654a:	f7fd f929 	bl	80037a0 <test_print>
  test_printn(n * 2);
 800654e:	0060      	lsls	r0, r4, #1
 8006550:	f7fd f936 	bl	80037c0 <test_printn>
  test_println(" timers/S");
 8006554:	4807      	ldr	r0, [pc, #28]	; (8006574 <bmk10_execute.11406+0x74>)
}
 8006556:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 2);
  test_println(" timers/S");
 800655a:	f7fd b909 	b.w	8003770 <test_println>
 800655e:	bf00      	nop
 8006560:	200008c4 	.word	0x200008c4
 8006564:	200014bc 	.word	0x200014bc
 8006568:	080002e1 	.word	0x080002e1
 800656c:	20001538 	.word	0x20001538
 8006570:	08006820 	.word	0x08006820
 8006574:	0800747c 	.word	0x0800747c
 8006578:	f3af 8000 	nop.w
 800657c:	f3af 8000 	nop.w

08006580 <bmk11_execute.11408>:
static void bmk11_setup(void) {

  chSemObjectInit(&sem1, 1);
}

static void bmk11_execute(void) {
 8006580:	b538      	push	{r3, r4, r5, lr}
  uint32_t n = 0;

  test_wait_tick();
 8006582:	f7fe fb45 	bl	8004c10 <test_wait_tick>
  test_start_timer(1000);
 8006586:	f7fd fefb 	bl	8004380 <test_start_timer.constprop.2>
 800658a:	4d14      	ldr	r5, [pc, #80]	; (80065dc <bmk11_execute.11408+0x5c>)

  chSemObjectInit(&sem1, 1);
}

static void bmk11_execute(void) {
  uint32_t n = 0;
 800658c:	2400      	movs	r4, #0

  test_wait_tick();
  test_start_timer(1000);
  do {
    chSemWait(&sem1);
 800658e:	4814      	ldr	r0, [pc, #80]	; (80065e0 <bmk11_execute.11408+0x60>)
 8006590:	f7fd fc0e 	bl	8003db0 <chSemWait>
    chSemSignal(&sem1);
 8006594:	4812      	ldr	r0, [pc, #72]	; (80065e0 <bmk11_execute.11408+0x60>)
 8006596:	f7fd fb73 	bl	8003c80 <chSemSignal>
    chSemWait(&sem1);
 800659a:	4811      	ldr	r0, [pc, #68]	; (80065e0 <bmk11_execute.11408+0x60>)
 800659c:	f7fd fc08 	bl	8003db0 <chSemWait>
    chSemSignal(&sem1);
 80065a0:	480f      	ldr	r0, [pc, #60]	; (80065e0 <bmk11_execute.11408+0x60>)
 80065a2:	f7fd fb6d 	bl	8003c80 <chSemSignal>
    chSemWait(&sem1);
 80065a6:	480e      	ldr	r0, [pc, #56]	; (80065e0 <bmk11_execute.11408+0x60>)
 80065a8:	f7fd fc02 	bl	8003db0 <chSemWait>
    chSemSignal(&sem1);
 80065ac:	480c      	ldr	r0, [pc, #48]	; (80065e0 <bmk11_execute.11408+0x60>)
 80065ae:	f7fd fb67 	bl	8003c80 <chSemSignal>
    chSemWait(&sem1);
 80065b2:	480b      	ldr	r0, [pc, #44]	; (80065e0 <bmk11_execute.11408+0x60>)
 80065b4:	f7fd fbfc 	bl	8003db0 <chSemWait>
    chSemSignal(&sem1);
 80065b8:	4809      	ldr	r0, [pc, #36]	; (80065e0 <bmk11_execute.11408+0x60>)
 80065ba:	f7fd fb61 	bl	8003c80 <chSemSignal>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80065be:	782b      	ldrb	r3, [r5, #0]
    chSemSignal(&sem1);
    chSemWait(&sem1);
    chSemSignal(&sem1);
    chSemWait(&sem1);
    chSemSignal(&sem1);
    n++;
 80065c0:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80065c2:	2b00      	cmp	r3, #0
 80065c4:	d0e3      	beq.n	800658e <bmk11_execute.11408+0xe>
  test_print("--- Score : ");
 80065c6:	4807      	ldr	r0, [pc, #28]	; (80065e4 <bmk11_execute.11408+0x64>)
 80065c8:	f7fd f8ea 	bl	80037a0 <test_print>
  test_printn(n * 4);
 80065cc:	00a0      	lsls	r0, r4, #2
 80065ce:	f7fd f8f7 	bl	80037c0 <test_printn>
  test_println(" wait+signal/S");
 80065d2:	4805      	ldr	r0, [pc, #20]	; (80065e8 <bmk11_execute.11408+0x68>)
}
 80065d4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" wait+signal/S");
 80065d8:	f7fd b8ca 	b.w	8003770 <test_println>
 80065dc:	200008c4 	.word	0x200008c4
 80065e0:	200008b8 	.word	0x200008b8
 80065e4:	08006820 	.word	0x08006820
 80065e8:	08007488 	.word	0x08007488
 80065ec:	f3af 8000 	nop.w

080065f0 <bmk6_execute.11381>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 80065f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80065f2:	4b12      	ldr	r3, [pc, #72]	; (800663c <bmk6_execute.11381+0x4c>)
 80065f4:	4f12      	ldr	r7, [pc, #72]	; (8006640 <bmk6_execute.11381+0x50>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80065f6:	699b      	ldr	r3, [r3, #24]
 80065f8:	b083      	sub	sp, #12

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
 80065fa:	689e      	ldr	r6, [r3, #8]
  test_wait_tick();
 80065fc:	f7fe fb08 	bl	8004c10 <test_wait_tick>
  test_start_timer(1000);
 8006600:	f7fd febe 	bl	8004380 <test_start_timer.constprop.2>
 * a second of continuous operations.
 */

static void bmk6_execute(void) {

  uint32_t n = 0;
 8006604:	2400      	movs	r4, #0
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
 8006606:	3601      	adds	r6, #1
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 8006608:	4625      	mov	r5, r4
 800660a:	4b0e      	ldr	r3, [pc, #56]	; (8006644 <bmk6_execute.11381+0x54>)
 800660c:	9500      	str	r5, [sp, #0]
 800660e:	480e      	ldr	r0, [pc, #56]	; (8006648 <bmk6_execute.11381+0x58>)
 8006610:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8006614:	4632      	mov	r2, r6
 8006616:	f7fd fb53 	bl	8003cc0 <chThdCreateStatic>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800661a:	783b      	ldrb	r3, [r7, #0]
  tprio_t prio = chThdGetPriorityX() + 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
    n++;
 800661c:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800661e:	2b00      	cmp	r3, #0
 8006620:	d0f3      	beq.n	800660a <bmk6_execute.11381+0x1a>
  test_print("--- Score : ");
 8006622:	480a      	ldr	r0, [pc, #40]	; (800664c <bmk6_execute.11381+0x5c>)
 8006624:	f7fd f8bc 	bl	80037a0 <test_print>
  test_printn(n);
 8006628:	4620      	mov	r0, r4
 800662a:	f7fd f8c9 	bl	80037c0 <test_printn>
  test_println(" threads/S");
 800662e:	4808      	ldr	r0, [pc, #32]	; (8006650 <bmk6_execute.11381+0x60>)
}
 8006630:	b003      	add	sp, #12
 8006632:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n);
  test_println(" threads/S");
 8006636:	f7fd b89b 	b.w	8003770 <test_println>
 800663a:	bf00      	nop
 800663c:	20001208 	.word	0x20001208
 8006640:	200008c4 	.word	0x200008c4
 8006644:	08005821 	.word	0x08005821
 8006648:	20000928 	.word	0x20000928
 800664c:	08006820 	.word	0x08006820
 8006650:	08006870 	.word	0x08006870
 8006654:	f3af 8000 	nop.w
 8006658:	f3af 8000 	nop.w
 800665c:	f3af 8000 	nop.w

08006660 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8006660:	b430      	push	{r4, r5}
 8006662:	4603      	mov	r3, r0
 8006664:	2120      	movs	r1, #32
 8006666:	f381 8811 	msr	BASEPRI, r1
  trefs_t refs;

  chSysLock();
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
  tp->p_refs--;
 800666a:	7f82      	ldrb	r2, [r0, #30]
 800666c:	3a01      	subs	r2, #1
 800666e:	b2d2      	uxtb	r2, r2
 8006670:	7782      	strb	r2, [r0, #30]
 8006672:	2400      	movs	r4, #0
 8006674:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 8006678:	b912      	cbnz	r2, 8006680 <chThdRelease+0x20>
 800667a:	7f04      	ldrb	r4, [r0, #28]
 800667c:	2c0f      	cmp	r4, #15
 800667e:	d001      	beq.n	8006684 <chThdRelease+0x24>
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    }
  }
}
 8006680:	bc30      	pop	{r4, r5}
 8006682:	4770      	bx	lr

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 8006684:	7f44      	ldrb	r4, [r0, #29]
 8006686:	f004 0403 	and.w	r4, r4, #3
 800668a:	2c01      	cmp	r4, #1
 800668c:	d00f      	beq.n	80066ae <chThdRelease+0x4e>
 800668e:	2c02      	cmp	r4, #2
 8006690:	d1f6      	bne.n	8006680 <chThdRelease+0x20>
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8006692:	6944      	ldr	r4, [r0, #20]
 8006694:	6900      	ldr	r0, [r0, #16]
 8006696:	6120      	str	r0, [r4, #16]
 8006698:	691d      	ldr	r5, [r3, #16]
#endif
      chPoolFree(tp->p_mpool, tp);
 800669a:	6c18      	ldr	r0, [r3, #64]	; 0x40
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 800669c:	616c      	str	r4, [r5, #20]
 800669e:	f381 8811 	msr	BASEPRI, r1
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 80066a2:	6801      	ldr	r1, [r0, #0]
 80066a4:	6019      	str	r1, [r3, #0]
  mp->mp_next = php;
 80066a6:	6003      	str	r3, [r0, #0]
 80066a8:	f382 8811 	msr	BASEPRI, r2
 80066ac:	e7e8      	b.n	8006680 <chThdRelease+0x20>
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 80066ae:	6942      	ldr	r2, [r0, #20]
 80066b0:	6901      	ldr	r1, [r0, #16]
 80066b2:	6111      	str	r1, [r2, #16]
 80066b4:	6903      	ldr	r3, [r0, #16]
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    }
  }
}
 80066b6:	bc30      	pop	{r4, r5}
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 80066b8:	615a      	str	r2, [r3, #20]
#endif
      chHeapFree(tp);
 80066ba:	f7fd bd31 	b.w	8004120 <chHeapFree>
 80066be:	bf00      	nop

080066c0 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 80066c0:	b538      	push	{r3, r4, r5, lr}
 80066c2:	4604      	mov	r4, r0
 80066c4:	2320      	movs	r3, #32
 80066c6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 80066ca:	7f03      	ldrb	r3, [r0, #28]
 80066cc:	2b0f      	cmp	r3, #15
 80066ce:	d007      	beq.n	80066e0 <chThdWait+0x20>
    list_insert(currp, &tp->p_waiting);
 80066d0:	4b08      	ldr	r3, [pc, #32]	; (80066f4 <chThdWait+0x34>)
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {

  tp->p_next = tlp->p_next;
 80066d2:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80066d4:	699b      	ldr	r3, [r3, #24]
    chSchGoSleepS(CH_STATE_WTEXIT);
 80066d6:	2009      	movs	r0, #9
 80066d8:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 80066da:	6263      	str	r3, [r4, #36]	; 0x24
 80066dc:	f7fd fb30 	bl	8003d40 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 80066e0:	6a25      	ldr	r5, [r4, #32]
 80066e2:	2300      	movs	r3, #0
 80066e4:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
 80066e8:	4620      	mov	r0, r4
 80066ea:	f7ff ffb9 	bl	8006660 <chThdRelease>
#endif

  return msg;
}
 80066ee:	4628      	mov	r0, r5
 80066f0:	bd38      	pop	{r3, r4, r5, pc}
 80066f2:	bf00      	nop
 80066f4:	20001208 	.word	0x20001208
 80066f8:	f3af 8000 	nop.w
 80066fc:	f3af 8000 	nop.w

08006700 <msg_loop_test.11383>:
}

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 8006700:	b570      	push	{r4, r5, r6, lr}
 8006702:	4605      	mov	r5, r0

  uint32_t n = 0;
  test_wait_tick();
 8006704:	f7fe fa84 	bl	8004c10 <test_wait_tick>
  test_start_timer(1000);
 8006708:	f7fd fe3a 	bl	8004380 <test_start_timer.constprop.2>
 800670c:	4e07      	ldr	r6, [pc, #28]	; (800672c <msg_loop_test.11383+0x2c>)
#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {

  uint32_t n = 0;
 800670e:	2400      	movs	r4, #0
  test_wait_tick();
  test_start_timer(1000);
  do {
    (void)chMsgSend(tp, 1);
 8006710:	4628      	mov	r0, r5
 8006712:	2101      	movs	r1, #1
 8006714:	f7fd fb8c 	bl	8003e30 <chMsgSend>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8006718:	7833      	ldrb	r3, [r6, #0]
  uint32_t n = 0;
  test_wait_tick();
  test_start_timer(1000);
  do {
    (void)chMsgSend(tp, 1);
    n++;
 800671a:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800671c:	2b00      	cmp	r3, #0
 800671e:	d0f7      	beq.n	8006710 <msg_loop_test.11383+0x10>
  (void)chMsgSend(tp, 0);
 8006720:	4628      	mov	r0, r5
 8006722:	2100      	movs	r1, #0
 8006724:	f7fd fb84 	bl	8003e30 <chMsgSend>
  return n;
}
 8006728:	4620      	mov	r0, r4
 800672a:	bd70      	pop	{r4, r5, r6, pc}
 800672c:	200008c4 	.word	0x200008c4
 8006730:	202d2d2d 	.word	0x202d2d2d
 8006734:	74737953 	.word	0x74737953
 8006738:	203a6d65 	.word	0x203a6d65
 800673c:	00000000 	.word	0x00000000
 8006740:	74796220 	.word	0x74796220
 8006744:	00007365 	.word	0x00007365
 8006748:	202d2d2d 	.word	0x202d2d2d
 800674c:	65726854 	.word	0x65726854
 8006750:	203a6461 	.word	0x203a6461
 8006754:	00000000 	.word	0x00000000
 8006758:	202d2d2d 	.word	0x202d2d2d
 800675c:	656d6954 	.word	0x656d6954
 8006760:	203a2072 	.word	0x203a2072
 8006764:	00000000 	.word	0x00000000
 8006768:	202d2d2d 	.word	0x202d2d2d
 800676c:	616d6553 	.word	0x616d6553
 8006770:	203a6870 	.word	0x203a6870
 8006774:	00000000 	.word	0x00000000
 8006778:	202d2d2d 	.word	0x202d2d2d
 800677c:	6e657645 	.word	0x6e657645
 8006780:	203a5374 	.word	0x203a5374
 8006784:	00000000 	.word	0x00000000
 8006788:	202d2d2d 	.word	0x202d2d2d
 800678c:	6e657645 	.word	0x6e657645
 8006790:	203a4c74 	.word	0x203a4c74
 8006794:	00000000 	.word	0x00000000
 8006798:	202d2d2d 	.word	0x202d2d2d
 800679c:	6574754d 	.word	0x6574754d
 80067a0:	203a2078 	.word	0x203a2078
 80067a4:	00000000 	.word	0x00000000
 80067a8:	202d2d2d 	.word	0x202d2d2d
 80067ac:	646e6f43 	.word	0x646e6f43
 80067b0:	203a2e56 	.word	0x203a2e56
 80067b4:	00000000 	.word	0x00000000
 80067b8:	202d2d2d 	.word	0x202d2d2d
 80067bc:	75657551 	.word	0x75657551
 80067c0:	203a2065 	.word	0x203a2065
 80067c4:	00000000 	.word	0x00000000
 80067c8:	202d2d2d 	.word	0x202d2d2d
 80067cc:	6c69614d 	.word	0x6c69614d
 80067d0:	203a2e42 	.word	0x203a2e42
	...

080067e0 <active_status.7928.4674>:
	...

080067f0 <evhndl.10458.4622>:
 80067f0:	08000461 08000471 08000481 00000000     a...q...........

08006800 <halted_status.7927.4673>:
 8006800:	00000001 00000000 00000000 00000000     ................
 8006810:	44434241 00000000 44434241 00000045     ABCD....ABCDE...
 8006820:	202d2d2d 726f6353 203a2065 00000000     --- Score : ....
 8006830:	73657220 64656863 73656c75 202c532f      reschedules/S, 
 8006840:	00000000 78746320 2f637773 00000053     .... ctxswc/S...
 8006850:	00434241 00000000 00000000 00000000     ABC.............

08006860 <zero_status.7926.4672>:
	...
 8006870:	72687420 73646165 0000532f 67736d20      threads/S.. msg
 8006880:	2c532f73 00000020 00000044 00000043     s/S, ...D...C...
 8006890:	00000042 00000041 00000000 00000000     B...A...........
 80068a0:	00004241 00000000 00000000 00000000     AB..............
 80068b0:	00000a0d 00000000 00000000 00000000     ................
 80068c0:	6e696c62 0072656b 00000000 00000000     blinker.........

080068d0 <wa>:
 80068d0:	20000928 20000a70 20000bb8 20000d00     (.. p.. ... ... 
 80068e0:	20000e48 00000000 00000000 00000000     H.. ............

080068f0 <ep0config.8732.4679>:
 80068f0:	00000000 080014c1 080034a1 08003011     .........4...0..
 8006900:	00400040 2000090c 2000090c 00000001     @.@.... ... ....
 8006910:	20000920 00000000 00000000 00000000      .. ............

08006920 <testbmk4.4906>:
 8006920:	08006fe4 00000000 00000000 08002001     .o........... ..

08006930 <testbmk9.4911>:
 8006930:	08006f2c 00000000 00000000 080063e1     ,o...........c..

08006940 <patternmbox.4857>:
 8006940:	08006bd0 00000000 00000000 00000000     .k..............

08006950 <testdyn2.4889>:
 8006950:	080070a0 080002c1 00000000 08002df1     .p...........-..

08006960 <testsys2.4820>:
 8006960:	08007340 00000000 00000000 080002f1     @s..............

08006970 <testbmk11.4913>:
 8006970:	08006ee4 08006271 00000000 08006581     .n..qb.......e..

08006980 <testmtx7.4849>:
 8006980:	080071d8 080060a1 00000000 080025c1     .q...`.......%..

08006990 <testqueues2.4897>:
 8006990:	08007048 080061c1 00000000 08001241     Hp...a......A...

080069a0 <testbmk7.4909>:
 80069a0:	08006f7c 08006261 00000000 08001a01     |o..ab..........

080069b0 <ch_debug.4918>:
 80069b0:	6e69616d 18011600 08440404 1814100c     main......D.....
 80069c0:	1e1d1c00 00000000 00000000 00000000     ................

080069d0 <testmtx5.4847>:
 80069d0:	08007208 08000351 00000000 08002f11     .r..Q......../..

080069e0 <patternmsg.4851>:
 80069e0:	08006c70 00000000 00000000 00000000     pl..............

080069f0 <testsem3.4838>:
 80069f0:	0800727c 080062a1 00000000 08000c01     |r...b..........

08006a00 <patternmtx.4840>:
 8006a00:	08007450 08007430 080069d0 08006bb0     Pt..0t...i...k..
 8006a10:	08006980 08007420 00000000 00000000     .i.. t..........

08006a20 <patternbmk.4898>:
 8006a20:	08006ad0 08006b50 08006c50 08006920     .j..Pk..Pl.. i..
 8006a30:	08006ae0 08006c10 080069a0 080073c0     .j...l...i...s..
 8006a40:	08006930 08007390 08006970 08006b80     0i...s..pi...k..
 8006a50:	080073e0 00000000 00000000 00000000     .s..............

08006a60 <patternsys.4814>:
 8006a60:	08006ac0 08006960 08006aa0 00000000     .j..`i...j......

08006a70 <patterndyn.4883>:
 8006a70:	08006bc0 08006950 080073f0 00000000     .k..Pi...s......

08006a80 <testsem1.4832>:
 8006a80:	080072b0 08006281 00000000 08002741     .r...b......A'..

08006a90 <testevt3.4870>:
 8006a90:	08007140 080008a1 00000000 08005391     @q...........S..

08006aa0 <testsys3.4821>:
 8006aa0:	0800732c 00000000 00000000 08000c91     ,s..............

08006ab0 <patternpools.4877>:
 8006ab0:	08006b60 00000000 00000000 00000000     `k..............

08006ac0 <testsys1.4815>:
 8006ac0:	0800735c 00000000 00000000 080033e1     \s...........3..

08006ad0 <testbmk1.4899>:
 8006ad0:	08007030 00000000 00000000 08001e41     0p..........A...

08006ae0 <testbmk5.4907>:
 8006ae0:	08006fc4 00000000 00000000 08001d41     .o..........A...

08006af0 <patterns.9290.4813>:
 8006af0:	08006a60 08006b30 08006c20 08006a00     `j..0k.. l...j..
 8006b00:	080069e0 08006940 08006c80 08007440     .i..@i...l..@t..
 8006b10:	08006ab0 08006a70 08006ba0 08006a20     .j..pj...k.. j..
	...

08006b30 <patternthd.4822>:
 8006b30:	080073b0 08006b70 08006c60 08006c00     .s..pk..`l...l..
	...

08006b50 <testbmk2.4904>:
 8006b50:	08007018 00000000 00000000 08001eb1     .p..............

08006b60 <testpools1.4878>:
 8006b60:	080070fc 08000321 00000000 08001c61     .p..!.......a...

08006b70 <testthd2.4828>:
 8006b70:	080072f4 00000000 00000000 08002971     .r..........q)..

08006b80 <testbmk12.4914>:
 8006b80:	08006ec4 08006181 00000000 08006491     .n...a.......d..

08006b90 <testevt2.4869>:
 8006b90:	08007154 080008b1 00000000 08004f51     Tq..........QO..

08006ba0 <patternqueues.4891>:
 8006ba0:	08007380 08006990 00000000 00000000     .s...i..........

08006bb0 <testmtx6.4848>:
 8006bb0:	080071f0 08006081 00000000 080024e1     .q...`.......$..

08006bc0 <testdyn1.4884>:
 8006bc0:	080070d0 08006121 00000000 08003271     .p..!a......q2..

08006bd0 <testmbox1.4858>:
 8006bd0:	08007194 08006221 00000000 08004511     .q..!b.......E..

08006be0 <vmt.7516.4978>:
 8006be0:	08004f41 08004e01 08004e91 08004d61     AO...N...N..aM..
 8006bf0:	08004e81 08004d51 08004f31 08004df1     .N..QM..1O...M..

08006c00 <testthd4.4830>:
 8006c00:	080072c8 00000000 00000000 08004c31     .r..........1L..

08006c10 <testbmk6.4908>:
 8006c10:	08006fa4 00000000 00000000 080065f1     .o...........e..

08006c20 <patternsem.4831>:
 8006c20:	08006a80 080073d0 080069f0 080073a0     .j...s...i...s..
	...

08006c40 <fsparams.8731.4977>:
 8006c40:	00000080 00000140 00000003 00000000     ....@...........

08006c50 <testbmk3.4905>:
 8006c50:	08007000 00000000 00000000 08001f21     .p..........!...

08006c60 <testthd3.4829>:
 8006c60:	080072d8 00000000 00000000 08000f61     .r..........a...

08006c70 <testmsg1.4852>:
 8006c70:	080071b4 00000000 00000000 08003341     .q..........A3..

08006c80 <patternevt.4863>:
 8006c80:	08007400 08006b90 08006a90 00000000     .t...k...j......
 8006c90:	656c6469 00000000 202a2a2a 62696843     idle....*** Chib
 8006ca0:	2f534f69 74205452 20747365 74697573     iOS/RT test suit
 8006cb0:	00000065 002a2a2a 202a2a2a 6e72654b     e...***.*** Kern
 8006cc0:	203a6c65 20202020 00002020 202d2d2d     el:       ..--- 
 8006cd0:	74736554 73614320 00002065 00000029     Test Case ..)...
 8006ce0:	202d2d2d 75736552 203a746c 4c494146     --- Result: FAIL
 8006cf0:	20455255 00002328 0000295d 202d2d2d     URE (#..])..--- 
 8006d00:	75736552 203a746c 43435553 00535345     Result: SUCCESS.
 8006d10:	4c494146 00455255 2e302e33 00000031     FAILURE.3.0.1...
 8006d20:	202a2a2a 706d6f43 64656c69 2020203a     *** Compiled:   
 8006d30:	00002020 2074634f 32203320 20353130       ..Oct  3 2015 
 8006d40:	3831202d 3a39333a 00003634 202a2a2a     - 18:39:46..*** 
 8006d50:	706d6f43 72656c69 2020203a 00002020     Compiler:     ..
 8006d60:	20434347 2e382e34 30322034 37303431     GCC 4.8.4 201407
 8006d70:	28203532 656c6572 29657361 52415b20     25 (release) [AR
 8006d80:	6d652f4d 64646562 342d6465 622d385f     M/embedded-4_8-b
 8006d90:	636e6172 65722068 69736976 32206e6f     ranch revision 2
 8006da0:	34313331 00005d37 202a2a2a 68637241     13147]..*** Arch
 8006db0:	63657469 65727574 0000203a 764d5241     itecture: ..ARMv
 8006dc0:	454d2d37 00000000 202a2a2a 65726f43     7-ME....*** Core
 8006dd0:	72615620 746e6169 0000203a 74726f43      Variant: ..Cort
 8006de0:	4d2d7865 00000034 202a2a2a 74726f50     ex-M4...*** Port
 8006df0:	666e4920 20203a6f 00002020 61766441      Info:    ..Adva
 8006e00:	6465636e 72656b20 206c656e 65646f6d     nced kernel mode
 8006e10:	00000000 202a2a2a 74616c50 6d726f66     ....*** Platform
 8006e20:	2020203a 00002020 334d5453 30344632     :     ..STM32F40
 8006e30:	69482037 50206867 6f667265 6e616d72     7 High Performan
 8006e40:	77206563 20687469 20505344 20646e61     ce with DSP and 
 8006e50:	00555046 202a2a2a 74736554 616f4220     FPU.*** Test Boa
 8006e60:	203a6472 00002020 694d5453 656f7263     rd:   ..STMicroe
 8006e70:	7463656c 696e6f72 53207363 32334d54     lectronics STM32
 8006e80:	442d3446 6f637369 79726576 00000000     F4-Discovery....
 8006e90:	00002820 00005b20 616e6946 6572206c      (.. [..Final re
 8006ea0:	746c7573 0000203a 636e6542 72616d68     sult: ..Benchmar
 8006eb0:	52202c6b 66204d41 70746f6f 746e6972     k, RAM footprint
 8006ec0:	00000000 636e6542 72616d68 6d202c6b     ....Benchmark, m
 8006ed0:	78657475 6c207365 2f6b636f 6f6c6e75     utexes lock/unlo
 8006ee0:	00006b63 636e6542 72616d68 73202c6b     ck..Benchmark, s
 8006ef0:	70616d65 65726f68 61772073 732f7469     emaphores wait/s
 8006f00:	616e6769 0000006c 636e6542 72616d68     ignal...Benchmar
 8006f10:	76202c6b 75747269 74206c61 72656d69     k, virtual timer
 8006f20:	65732073 65722f74 00746573 636e6542     s set/reset.Benc
 8006f30:	72616d68 49202c6b 51204f2f 65756575     hmark, I/O Queue
 8006f40:	68742073 67756f72 74757068 00000000     s throughput....
 8006f50:	636e6542 72616d68 72202c6b 646e756f     Benchmark, round
 8006f60:	626f7220 63206e69 65746e6f 73207478      robin context s
 8006f70:	63746977 676e6968 00000000 636e6542     witching....Benc
 8006f80:	72616d68 6d202c6b 20737361 63736572     hmark, mass resc
 8006f90:	75646568 202c656c 68742035 64616572     hedule, 5 thread
 8006fa0:	00000073 636e6542 72616d68 74202c6b     s...Benchmark, t
 8006fb0:	61657268 202c7364 61657263 6f206574     hreads, create o
 8006fc0:	00796c6e 636e6542 72616d68 74202c6b     nly.Benchmark, t
 8006fd0:	61657268 202c7364 6c6c7566 63796320     hreads, full cyc
 8006fe0:	0000656c 636e6542 72616d68 63202c6b     le..Benchmark, c
 8006ff0:	65746e6f 73207478 63746977 00000068     ontext switch...
 8007000:	636e6542 72616d68 6d202c6b 61737365     Benchmark, messa
 8007010:	20736567 00003323 636e6542 72616d68     ges #3..Benchmar
 8007020:	6d202c6b 61737365 20736567 00003223     k, messages #2..
 8007030:	636e6542 72616d68 6d202c6b 61737365     Benchmark, messa
 8007040:	20736567 00003123 75657551 202c7365     ges #1..Queues, 
 8007050:	7074756f 71207475 65756575 00000073     output queues...
 8007060:	75657551 202c7365 75706e69 75712074     Queues, input qu
 8007070:	73657565 00000000 616e7944 2063696d     eues....Dynamic 
 8007080:	73495041 6572202c 74736967 61207972     APIs, registry a
 8007090:	7220646e 72656665 65636e65 00000073     nd references...
 80070a0:	616e7944 2063696d 73495041 6874202c     Dynamic APIs, th
 80070b0:	64616572 72632073 69746165 66206e6f     reads creation f
 80070c0:	206d6f72 6f6d656d 70207972 006c6f6f     rom memory pool.
 80070d0:	616e7944 2063696d 73495041 6874202c     Dynamic APIs, th
 80070e0:	64616572 72632073 69746165 66206e6f     reads creation f
 80070f0:	206d6f72 70616568 00000000 6f6d654d     rom heap....Memo
 8007100:	50207972 736c6f6f 7571202c 2f657565     ry Pools, queue/
 8007110:	75716564 00657565 70616548 6c61202c     dequeue.Heap, al
 8007120:	61636f6c 6e6f6974 646e6120 61726620     location and fra
 8007130:	6e656d67 69746174 74206e6f 00747365     gmentation test.
 8007140:	6e657645 202c7374 656d6974 7374756f     Events, timeouts
 8007150:	00000000 6e657645 202c7374 74696177     ....Events, wait
 8007160:	646e6120 6f726220 61636461 00007473      and broadcast..
 8007170:	6e657645 202c7374 69676572 61727473     Events, registra
 8007180:	6e6f6974 646e6120 73696420 63746170     tion and dispatc
 8007190:	00000068 6c69614d 65786f62 71202c73     h...Mailboxes, q
 80071a0:	69756575 6120676e 7420646e 6f656d69     ueuing and timeo
 80071b0:	00737475 7373654d 73656761 6f6c202c     uts.Messages, lo
 80071c0:	0000706f 646e6f43 2c726156 6f6f6220     op..CondVar, boo
 80071d0:	74207473 00747365 646e6f43 2c726156     st test.CondVar,
 80071e0:	6f726220 61636461 74207473 00747365      broadcast test.
 80071f0:	646e6f43 2c726156 67697320 206c616e     CondVar, signal 
 8007200:	74736574 00000000 6574754d 2c736578     test....Mutexes,
 8007210:	61747320 00737574 6574754d 2c736578      status.Mutexes,
 8007220:	69727020 7469726f 65722079 6e727574      priority return
 8007230:	00000000 6574754d 2c736578 69727020     ....Mutexes, pri
 8007240:	7469726f 6e652079 75657571 20676e69     ority enqueuing 
 8007250:	74736574 00000000 616e6942 53207972     test....Binary S
 8007260:	70616d65 65726f68 66202c73 74636e75     emaphores, funct
 8007270:	616e6f69 7974696c 00000000 616d6553     ionality....Sema
 8007280:	726f6870 202c7365 6d6f7461 73206369     phores, atomic s
 8007290:	616e6769 61772d6c 00007469 616d6553     ignal-wait..Sema
 80072a0:	726f6870 202c7365 656d6974 0074756f     phores, timeout.
 80072b0:	616d6553 726f6870 202c7365 75716e65     Semaphores, enqu
 80072c0:	6e697565 00000067 65726854 2c736461     euing...Threads,
 80072d0:	6c656420 00737961 65726854 2c736461      delays.Threads,
 80072e0:	69727020 7469726f 68632079 65676e61      priority change
 80072f0:	00000000 65726854 2c736461 716e6520     ....Threads, enq
 8007300:	69756575 7420676e 20747365 00003223     ueuing test #2..
 8007310:	65726854 2c736461 716e6520 69756575     Threads, enqueui
 8007320:	7420676e 20747365 00003123 74737953     ng test #1..Syst
 8007330:	202c6d65 65746e69 74697267 00000079     em, integrity...
 8007340:	74737953 202c6d65 65746e69 70757272     System, interrup
 8007350:	68207374 6c646e61 00676e69 74737953     ts handling.Syst
 8007360:	202c6d65 74697263 6c616369 6e6f7a20     em, critical zon
 8007370:	00007365 00000000 00000000 00000000     es..............

08007380 <testqueues1.4892>:
 8007380:	08007060 080061f1 00000000 08002ac1     `p...a.......*..

08007390 <testbmk10.4912>:
 8007390:	08006f08 00000000 00000000 08006501     .o...........e..

080073a0 <testsem4.4839>:
 80073a0:	08007258 00000000 00000000 08005231     Xr..........1R..

080073b0 <testthd1.4823>:
 80073b0:	08007310 00000000 00000000 080028a1     .s...........(..

080073c0 <testbmk8.4910>:
 80073c0:	08006f50 00000000 00000000 080020c1     Po........... ..

080073d0 <testsem2.4837>:
 80073d0:	0800729c 08006291 00000000 08001841     .r...b......A...

080073e0 <testbmk13.4915>:
 80073e0:	08006ea8 00000000 00000000 080005a1     .n..............

080073f0 <testdyn3.4890>:
 80073f0:	08007078 08006151 00000000 08003141     xp..Qa......A1..

08007400 <testevt1.4864>:
 8007400:	08007170 080008c1 00000000 08001b31     pq..........1...

08007410 <testheap1.4872>:
 8007410:	08007118 080060f1 00000000 08000d21     .q...`......!...

08007420 <testmtx8.4850>:
 8007420:	080071c4 080060c1 00000000 080026b1     .q...`.......&..

08007430 <testmtx4.4846>:
 8007430:	08007218 080061a1 00000000 08002281     .r...a......."..

08007440 <patternheap.4871>:
 8007440:	08007410 00000000 00000000 00000000     .t..............

08007450 <testmtx1.4841>:
 8007450:	08007234 08006191 00000000 080021a1     4r...a.......!..
 8007460:	74796220 532f7365 00000000 636f6c20      bytes/S.... loc
 8007470:	6e752b6b 6b636f6c 0000532f 6d697420     k+unlock/S.. tim
 8007480:	2f737265 00000053 69617720 69732b74     ers/S... wait+si
 8007490:	6c616e67 0000532f                       gnal/S..
